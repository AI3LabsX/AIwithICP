{
  "Asset certification _ Internet Computer.pdf": "25.09.2023, 21:23 Asset certification | Internet Computer\nhttps://internetcomputer .org/how-it-works/asset-certification/ 1/2\nAsset certi\u0000cation\nA user interacting with the Internet Computer needs to be able to con\u0000rm that the responses\nthey receive are actually coming from the Internet Computer and have not been tampered with.\nTraditionally, on the Internet, this problem is solved using public-key cryptography. The server\nrunni ng the service has a secret key and uses that to sign all its responses. A user can then verify\nthe signature on the response using the server\u2019s public key.\nJust like a web server in Web2 maintains a public-key/secret-key pair, the Internet Computer\nblockchain as a whole maintains a public-key/secret-key pair. Additionally, each individual\nsubnet in the Internet Computer also maintains its own public-key/secret-key pair. When a new\nsubnet is formed, the NNS issues a certi\u0000cate for the subnet which contains a signature of the\nsubnet's public key with the Internet Computer's public key. When the subnet responds to a\nuser's message, the response contains a certi\u0000cate chain, which includes a signature on the\nresponse by the subnet's public key and the certi\u0000cate issued by the NNS to the subnet. The\nuser can verify the certi\u0000cate chain using the Internet Computer's public key similar to verifying\na certi\u0000cate chain in Web2.\nEach blockchain node shares only a piece of its subnet secret key. As a result, each node is\nincapable of signing a message by itself. But if at least 2/3rd of the nodes of a subnet agree on a\nmessage, they together can combine their secret key pieces to sign the message. The signed\nmessage can be veri\u0000ed easily using the subnet's public key. If the veri\u0000cation succeeds, it\nmeans that at least 2/3rd of the blockchain nodes runni ng the canister agreed to deliver that\nmessage. The technology used by the Internet Computer to generate and maintain the secret\nkey shares, and sign messages using the secret key shares is called chain-key technology.\nThe Internet Computer supports two types of messages: Query calls and Update calls. Query\ncalls are similar to HTTP `GET` requests and do not modify the state of the Internet Computer.\nThe query calls do not go through the consensus protocol. The user can make a query call to any\nblockchain node in the subnet, and only that (possibly malicious) blockchain node answers the\nquery. As generating a certi\u0000cate requires consensus from at least 2/3rd of the nodes of the\nsubnet, the Internet Computer doesn't issue a certi\u0000cate when responding to query calls.How it works Asset certi\u0000c ation\n25.09.2023, 21:23 Asset certification | Internet Computer\nhttps://internetcomputer .org/how-it-works/asset-certification/ 2/2For e\u0000ciency reasons, the canisters deliver web pages to the client via query calls. However, as\nthe client needs to verify the received content, the Internet Computer introduces the notion of\nCerti\u0000ed Variables. In a nutshell, a canister can a-priori choose to create a certi\u0000cate for a piece\nof data and store it in the replicated state. Any user can later access the data along with its\ncerti\u0000cate via query calls.\nWe can use the notion of the certi\u0000ed variables to certify all the assets (HTML, CSS, Javascript\n\u0000les, images, videos, etc.) of an app a-priori. There are 2 ways of performing the asset\ncerti\u0000cation. 1) The canister developer can explicitly write code to manage and certify all the\nassets. 2) The canister developer can create an \"asset canister\", by creating a canister with type\nset to \"asset\" and specifying the folder containing all the assets. The asset canister is a regular\ncanister, except that the boilerplate code for managing and certifying all the assets is taken care\nof for us.\nWhen a canister issues a response along with its certi\u0000cate, a HTTP Gateway can be used to\nverify the certi\u0000cate before passing on the response to the client.\nFor more information on certi\u0000cation, check Certi\u0000ed Variables.\nAsset Certi\u0000cation W iki Ar ticle\nRust Canister Development Security Best Practices",
  "Basics _ Internet Computer.pdf": "25.09.2023, 21:20 Basics | Internet Computer\nhttps://internetcomputer .org/basics?source=nav 1/4\nSmart contracts serve webpages\nYou can open canister smart contracts directly in your browser just like regular websites.\nHow it works\nUsers don\u2019t need tokens and wallets\nThe reverse gas model enables free-to-use, truly user-friendly dapps, ready for mass adoption.\nExplore Internet Computer Ecosystem\nDSCVR\nDistrikt\nOpenChat\nSonic\nInternet IdentityInternet Computer basics\nThe Internet Computer (ICP) allows Web3 services to run 100% on-chain, providing the only platform where developers can\nbuild and users can enjoy fully decentralized applications. ICP ditches corporate cloud, insecure bridges and expensive\noracles.\nContent served directly from chain25.09.2023, 21:20 Basics | Internet Computer\nhttps://internetcomputer .org/basics?source=nav 2/4\nDecentralized social\nnews aggregator\n40,000+ users\nProfessional social media\nplatform\n70,000+ users\nDecentralized alternative\nto WhatsApp\n50,000+ users\nSwap built end-to-end\nDeFi platform\n30,000+ users\nBlockchain\nauthentication system\n1,000,000+ usersTrue scaling\nBy adding new subnets regularly, the Internet Computer scales to an unbounded number of dapps and allows storage of unlimited data.\nBecome a node provider\nCURRENT STATUS\n546 Node machines\nwith hundreds more waiting to form new subnets\n96 Node providers\nindependent node operators\n36 Subnet blockchain\ncombined into 1 platform25.09.2023, 21:20 Basics | Internet Computer\nhttps://internetcomputer .org/basics?source=nav 3/4\nEcosystem\nGo to Ecosystem showcase\nMint and store NFT's on-chain\nExplore more NFT projects Explore new user incentives in Web3\nSocial dapps\nExplore more SocialFi projectsLeverage unlimited scalabilit\nsupersonic transaction \u0000nalit\nExplore more DeFi projects25.09.2023, 21:20 Basics | Internet Computer\nhttps://internetcomputer .org/basics?source=nav 4/4\nBlockchain operation that's climate friendly\nThanks to the unique architecture and novel cryptography, the Internet Computer hosts smart contract software, data, and computation, with\nenergy consumption levels comparable with traditional software that runs on Big Tech's cloud services and orders of magnitude lower than\ncompeting blockchains. Web3 projects that incorporate Internet Computer smart contracts can dramatically lower their carbon footprint, and help\nreduce climate change.\nICP SUSTAINABILITY REPORT\nGet the gist on Medium\nA comparison of the energy consumption per transaction between blockchains0.008Wh/tx\n0.166\n2.700\n4.760\n17.400\n30.000\n41.450\n51.590",
  "Bitcoin Integration _ Internet Computer.pdf": "25.09.2023, 21:22 Bitcoin Integration | Internet Computer\nhttps://internetcomputer .org/how-it-works/bitcoin-integration/ 1/3\nBitcoin Integration\nThe Bitcoin integration on the Internet Computer makes it possible for the \u0000rst time to create\nBitcoin smart contracts, that is, smart contracts in the form of canisters running on the Internet\nComputer that make use of real bitcoin. This integration is made possible through two key\ncomponents.\nThe \u0000rst component is chain-key signatures, which enables every canister to obtain ECDSA\npublic keys and get signatures with respect to these keys in a secure manner. Since Bitcoin\naddresses are tied to ECDSA public keys, having ECDSA public keys on a canister means that\nthe canister can derive its own Bitcoin addresses. Given that the canister can request signatures\nfor any of its public keys using the IC ECDSA interface, a canister can create Bitcoin\ntransactions with valid signatures that move bitcoins from any of its Bitcoin addresses to any\nother address.\nThe second component is the integration with Bitcoin at the network level. The Internet\nComputer replicas have the capability to instantiate a so-called Bitcoin adapter, a process\nexternal to the replica process. In a \u0000rst step, the Bitcoin adapter collects information about\nnodes in the Bitcoin peer-to-peer network and, once su\u0000ciently many Bitcoin nodes are\ndiscovered, it connects to 5 randomly chosen Bitcoin nodes. Since each replica in the subnet\nperforms this operation, the entire subnet has many, mostly distinct connections to the Bitcoin\nnetwork. The Bitcoin adapter uses the standard Bitcoin peer-to-peer protocol to get information\nabout the Bitcoin blockchain. Each Bitcoin adapter keeps track of the full Bitcoin block header\nchain.\nAt the same time, the Bitcoin adapter communicates with the replica process to learn about the\ncurrent Bitcoin state inside the replica. If the Bitcoin adapter learns that a Bitcoin block has not\nbeen made available to the replica yet by comparing the block header hashes provided by the\nreplica against its locally available block header chain, the Bitcoin adapter requests the next\nmissing block from the connected Bitcoin nodes and forwards it to the replica upon receipt.\nInside the replica, Bitcoin blocks received at the Networking layer are packed into IC blocks and\nprocessed in the Consensus and Message Routing layers and \u0000nally made available to the\nBitcoin canister in the Execution layer. The Bitcoin canister is a canister runni ng in a systemHow it works Bitcoin Integration\n25.09.2023, 21:22 Bitcoin Integration | Internet Computer\nhttps://internetcomputer .org/how-it-works/bitcoin-integration/ 2/3subnet whose purpose is to provide Bitcoin-related functionality to other canisters. In particular,\nit keeps information about the Bitcoin blockchain state and makes this information accessible to\nother canisters, such as the balance and unspent transaction outputs (UTXOs) for any address.\nAdditionally, the fees of the most recent Bitcoin transactions that were put into blocks can be\nrequested from the Bitcoin canister as well.\nThe Bitcoin canister also o\u0000ers the last piece of crucial functionality: It provides an endpoint for\ncanisters to send Bitcoin transactions, which are made available on the Networking layer where\nthey are forwarded to the Bitcoin adapter. The Bitcoin adapter in turn advertises the transactions\nto its connected Bitcoin peers and transfers the transaction upon request. Since each replica in\nthe subnet performs this step, every transaction can be dispersed quickly in the Bitcoin network.\nThe IC management canister interface provides access to all Bitcoin integration endpoints.\nTheir use is illustrated in the following sample \u0000ow:\nIn this \u0000gure, a canister \u0000rst requests the balance and then the UTXOs of a Bitcoin address.\nNext, it calls the fee endpoint to get recent fees. Lastly, the canister builds a Bitcoin transaction\nusing some of the UTXOs as inputs. For each input, the ECDSA API is called to obtain the\nrequired signatures. Finally, the transaction is submitted.\nBitcoin integration wiki page.\nBitcoin canister source code.25.09.2023, 21:22 Bitcoin Integration | Internet Computer\nhttps://internetcomputer .org/how-it-works/bitcoin-integration/ 3/3M otion Proposal 20586.\nBitcoin integration goes live.",
  "Blockchain Protocol Upgrade _ Internet Computer.pdf": "25.09.2023, 21:23 Blockchain Protocol Upgrade | Internet Computer\nhttps://internetcomputer .org/how-it-works/upgrades/ 1/5\nBlockchain Protocol Upgrade\nAny software needs to be updated on a regular basis to stay competitive in the market. This\ncould be to \u0000x bugs, add new features, change the algorithms, change the underlying\ntechnology, etc. Blockchain protocols are no di\u0000erent. As a community, we keep learning better\nways to solve our problems and would like to upgrade our blockchain protocols accordingly. For\nexample, Ethereum recently had \u201cThe Merge\u201d upgrade, which upgraded their protocol from\nProof of Work to Proof of Stake. Bitcoin had the \u201cTaproot\u201d upgrade, which improved their\nsignature veri\u0000cation.\nWhile upgrading a blockchain protocol is extremely crucial for its success, most blockchains\nincluding Bitcoin and Ethereum are not designed to do so. This is primarily because blockchains\nare not controlled by a single authority. Every upgrade proposal has to be evaluated by the\ncommunity. However, the community is usually split on the proposals. There is no quick and\nformal framework to \u0000nalize the decisions and build new features. Upgrades to the protocol\npotentially cause a fork in the network. As a result, upgrading a blockchain protocol could take\nyears of joint e\u0000ort by the community. Ethereum went through only 18 protocol upgrades in a\n7.5 year time span.\nThe Internet Computer is a unique blockchain that is designed to be easily upgradeable with a\nminimal user-perceived downtime and without any forks while still requiring consensus by the\ncommunity for each upgrade. Within 1.5 years after genesis, the Internet Computer has\nupgraded many times, adding crucial features such as deterministic time slicing, Bitcoin\nintegration, Service Nervous System (SNS), HTTPS outcalls, chain-key ECDSA signatures (based\non threshold ECDSA), increased stable memory, etc.\nThe \u201cprotocol upgrades\u201d feature is designed with the following goals: (1) Allow arbitrary changes\nto the Internet Computer Protocol; (2) Preserve the state between upgrades; (3) Minimize\ndowntime; (4) Roll out upgrades autonomously.\nProtocol upgrades are made feasible due to our blockchain governance system called Network\nNervous System (NNS). In the NNS, there is a component called \u201cregistry\u201d, which stores all the\ncon\u0000guration of the Internet Computer. A versioning system is implemented for the\ncon\u0000guration. Each mutation to the con\u0000guration shows up as a new version in the registry. TheHow it works Blockchain Protocol Upgrade\n25.09.2023, 21:23 Blockchain Protocol Upgrade | Internet Computer\nhttps://internetcomputer .org/how-it-works/upgrades/ 2/5registry has a record for each subnet which includes a protocol version, list of nodes in the\nsubnet, cryptographic key material to be used by the subnet, etc. Note that the registry stores\nthe desired con\u0000guration. The subnets might actually be runni ng one of the older con\u0000gurations.\nTo trigger a protocol upgrade, one has to submit a proposal in the NNS to change the\ncon\u0000guration of the registry. The proposal can be voted by anyone who staked their ICP tokens.\nIf a majority of voters accept the proposal, then the registry is changed accordingly.\nProposal to upgrade a subnet to a new replica version. The status of all proposals can be viewed at\nhttps://dashboard.internetcomputer.org/governance.\nWe now describe how a change in registry version upgrades the Internet Computer. Protocol\nupgrades are done on a per-subnet basis. Each subnet is run by many nodes. Each node runs 2\nprocesses \u2014 (1) the Replica and (2) the Orchestrator. The replica consists of the 4-layer software25.09.2023, 21:23 Blockchain Protocol Upgrade | Internet Computer\nhttps://internetcomputer .org/how-it-works/upgrades/ 3/5stack that maintains the blockchain. The orchestrator downloads and manages the replica\nsoftware. The orchestrator regularly queries the NNS registry for any updates. If there is a new\nregistry version, the orchestrator downloads the corresponding replica software and informs the\nreplica about it.\nIn each consensus round, one of the nodes in the subnet (called the block maker) proposes a\nblock. In every block, the block maker includes the latest registry version it downloaded from\nthe registry. Other nodes notarize the block only when they have the referenced registry\navailable.\nAfter all the nodes in the subnet agree upon the latest registry version via consensus, the\nobvious next step is to switch to the new version. To avoid forks, it is crucial that all the nodes\ncoordinate and switch their version at the same block height. To achieve this, the consensus\nprotocol is divided into epochs. Each epoch is a few hund red consensus rounds (can be\ncon\u0000gured in the registry). Throughout an epoch, all the replicas in the subnet run the same\nReplica version, even if a newer Replica version is found in the registry and included in the\nblocks. Protocol upgrades happen only at the epoch boundaries.\nThe \u0000rst block in each epoch is a summary block, which consists of the con\u0000guration\ninformation (including registry version and cryptographic key material) that will be used during\nthe epoch. The summary block of epoch x speci\u0000es both the registry version to be used\nthroughout epoch x, and the registry version to be used throughout epoch x+1. Therefore, all the\nnodes agree on what registry version to use for an epoch long before the epoch starts.25.09.2023, 21:23 Blockchain Protocol Upgrade | Internet Computer\nhttps://internetcomputer .org/how-it-works/upgrades/ 4/5Suppose a protocol upgrade of the subnet is supposed to be done at the beginning of epoch x. A\nblockmaker \u0000rst proposes the summary block. The nodes then stop processing any new\nmessages, but produce a series of empty blocks until the summa ry block is \u0000nalized, executed\nand the complete replicated state is certi\u0000ed. Then, all the nodes create a catch up package\n(CUP), which contains the relevant information that needs to be transferred from the old replica\nsoftware to the new replica software. The CUP gives enough context for the new replica\nsoftware to resume consensus. The replicas send the CUP to the orchestrator. The orchestrator\nruns the new replica software with the CUP as input. Section 8 of the whitepaper describes the\ncontents of the summary block and catch up package in detail.\nUpgrading the Internet Computer Protocol\nW hitepaper, see Section 825.09.2023, 21:23 Blockchain Protocol Upgrade | Internet Computer\nhttps://internetcomputer .org/how-it-works/upgrades/ 5/5\n",
  "Boundary Nodes - Internet Computer Wiki.pdf": "25.09.2023, 21:24 Boundary Nodes - Internet Computer Wiki\nhttps://wiki.internetcomputer .org/wiki/Boundary_Nodes 1/3Boundary Nodes\nThe boundary nodes are the gateway to the Internet Computer (IC), and allow users to seamlessly access the canister smart contracts\nrunning on it. The following figure shows how the boundary nodes form the edge of the IC and all accesses to the IC have to go through\none of the boundary nodes.\nBoundary Node Internals\nAt a closer look, boundary nodes consist of two parts: the API node, which provides an endpoint for API canister calls  (https://internetco\nmputer .org/docs/current/references/ic-interface-spec/#http-interface) , and the HTTP  gateway , which provides an HTTP  endpoint for\nusers to access the canisters hosted on the IC with their stock browser .\nAPI Node\nThe API endpoint resides at icp-api.io/api/v2  and is specified in the IC\u2019s Interface Specification  (https://internetcomputer .org/docs/cu\nrrent/references/ic-interface-spec/#http-interface) .\nWhenever a boundary node receives an API canister call, it passes it through a filter and then routes it to a replica node on the correct\nsubnet in the IC.\nFiltering within the boundary node consists only of rate-limiting. The rate-limits are in place to protect the IC from being overwhelmed\nwith external accesses.\nAfter an API canister call passed the filtering stage, the boundary node infers the destination canister ID and uses the routing table to\nlook up the subnet in which this canister is hosted. It then randomly chooses a replica within that subnet to which it forwards the API\ncall. The random selection of the target replica ensures that an API call eventually reaches an honest node when the client keeps\nretrying.25.09.2023, 21:24 Boundary Nodes - Internet Computer Wiki\nhttps://wiki.internetcomputer .org/wiki/Boundary_Nodes 2/3Finally , the boundary node forwards the API canister call to the selected replica node in the core of the IC.\nSince the API Node is simply passing the API canister call on to the IC, no trust is required.\nHTTP  Gateway\nThe HTTP  endpoint is served through two main domains: ic0.app  and icp0.io . In the following, we use for simplicity only ic0.app ,\neven though both domains could be used equally .\nUnfortunately , browsers don't natively support API canister calls and therefore cannot directly talk to the canisters hosted on the IC. The\nHTTP  gateway protocol  (https://internetcomputer .org/docs/current/references/ic-interface-spec/#http-gateway)  bridges that gap by\nproviding a mechanism to translate HTTP  requests into API canister calls allowing a client to interact with canisters. A gateway can be\nimplemented in various forms (e.g., as a stand-alone proxy , as a browser plugin, or as a service worker  (https://developer .mozilla.org/en\n-US/docs/W eb/API/Service_W orker_API) ).\nThe boundary nodes provide two dif ferent implementations of the HTTP  gateway protocol:\nService worker: under <canister_id>.ic0.app , the boundary nodes serve a service worker  (https://www .npmjs.com/package/\n@dfinity/service-worker) , which is installed in the browser and acts as an HTTP  gateway directly in the user \u2019s browser;\nicx-proxy : under <canister_id>.raw.ic0.app , the boundary node runs icx-proxy  (https://github.com/dfinity/icx-proxy) , an\nHTTP  gateway implementation suitable for all clients that do not support a service worker .\nBefore serving any HTTP  request, the HTTP  Gateway passes the incoming request through a filter , which can be used to implement\ncontent filtering allowing operators to comply with local legal frameworks (e.g., blocking gambling services in a particular geography). To\nlearn more about content filtering see Content Filtering via The Boundary Nodes .\nService W orker\nWhen accessing <canister_id>.ic0.app , the boundary node returns a service worker implementing the HTTP  gateway protocol, which\nis installed directly in the user \u2019s browser (step 1 and 2). From then on, the service worker will intercept all HTTP  requests and translate\nthem to API canister calls (step 3). These API canister calls will then go through the API endpoint of the boundary node to the IC (step\n4). The replica sends the response back through the boundary node to the service worker (step 5 and 6). For all responses, the service\nworker verifies the certificate of the response and only translates it into a proper HTTP  response for the browser if it passes all the\nchecks (step 7).\nicx-proxy\nThe HTTP  Gateway endpoint implements the HTTP  gateway protocol, which translates between HTTP  requests and API canister calls.\nThis endpoint resides at <canister_id>.raw.ic0.app . Whenever a boundary node receives such a request, it forwards it to icx-proxy ,\na service running directly on the boundary node that implements the HTTP  gateway protocol. icx-proxy  translates the HTTP  requests25.09.2023, 21:24 Boundary Nodes - Internet Computer Wiki\nhttps://wiki.internetcomputer .org/wiki/Boundary_Nodes 3/3into API canister calls and forwards them to the API endpoint of the boundary node. It verifies the certificates of the responses and\nconstructs an HTTP  response to send back to the client. Here, the user needs to trust the boundary node as the boundary node is\nconstructing the API calls and verifying the correctness of the IC\u2019 s response.\nAdditional Features of the Boundary Nodes\nGlobally-Distributed\nThe boundary nodes serving ic0.app  are globally distributed and organized in regional pools. All requests are directed to the\ngeographically closest pool and load balanced over the instances within that pool. The health of the boundary nodes is constantly\nmonitored and in case of failure, boundary nodes will be removed from the pools.\nSEO\nBots and crawlers, such as the ones used by search engines, do not support service workers. In order for them to index content hosted\nunder ic0.app  their requests are internally redirected to icx-proxy . This allows the dapps running on the Internet Computer to\nseamlessly integrate into the W eb 2.0 world. These dapps can be indexed by search engines and their metadata can be read in order to\ngenerate previews and cards on social platforms.\nCaching\nTo improve the user-perceived performance of the dapps hosted on the IC, the boundary nodes currently provide response caching.\nResponses to requests are cached for 1s.\nFuture Boundary Node Developments\nTo follow future boundary node developments check out the public roadmap  (https://internetcomputer .org/roadmap/) , the IC developer\nforum  (https://forum.dfinity .org/)  and the thread on the future boundary node architecture  (https://forum.dfinity .org/t/boundary-node-road\nmap/15562) .\nSee Also\nThe Internet Computer project website (hosted on the IC): internetcomputer .org (https://internetcomputer .org/)\nContent Filtering via Boundary Nodes",
  "Boundary nodes _ Internet Computer.pdf": "25.09.2023, 21:23 Boundary nodes | Internet Computer\nhttps://internetcomputer .org/how-it-works/boundary-nodes/ 1/2\nBoundary nodes\nThe boundary nodes form the globally distributed edge of the Internet Computer (IC) through\nwhich all the accesses to the canister smart contracts go. The boundary nodes provide a public\nendpoint for the IC and route all incoming requests to the right subnet, loadbalance requests\nacross replica nodes, and cache responses for improved performance.\nBoundary nodes are the gateway to the Internet Computer, which allow users to seamlessly access\nthe canister smart contracts.\nThe boundary nodes provide two ways of accessing canister smart contracts hosted on the\nInternet Computer: \u0000rst, one can access them using stock browsers through the HTTP gateway,\nand second, one can access them using API canister calls through the API boundary node.\nThe HTTP gateway allows users to access the dapps hosted on the IC through their browsers the\nsame way they are used to accessing any Web 2.0 service. To this end, the HTTP gateway\ntranslates all incoming HTTP requests into API canister calls, which are then routed to the right\nsubnet.How it works Bo undary nodes\n25.09.2023, 21:23 Boundary nodes | Internet Computer\nhttps://internetcomputer .org/how-it-works/boundary-nodes/ 2/2The API boundary node allows IC native applications to directly call the canister smart\ncontracts. In this case, the boundary node simply routes the API canister calls to the right\nsubnet. Hence, no trust is required between the user and the boundary node.\nBoth the HTTP gateway and the API boundary node are currently combined into the boundary\nnode. Work to separate the two into two independent services is ongoing. Once complete, the\nAPI boundary nodes will be fully under the control of the NNS, while the HTTP gateways can be\nrun by anyone in the community ensuring compliance with local jurisdictions. For more\ninformation check our updates in the forum.\nIn addition to the two endpoints, the boundary nodes provide to access the IC, the boundary\nnodes also provide caching to improve the performance of the dapps hosted on the IC.\nGo E ven De eper\nBoundary Nodes on the IC W iki",
  "Canister smart contracts serve the Web _ Internet Computer.pdf": "25.09.2023, 21:23 Canister smart contracts serve the W eb | Internet Computer\nhttps://internetcomputer .org/how-it-works/smart-contracts-serve-the-web/ 1/5\nSmart Contracts serve the web\nThe Internet Computer is the only blockchain that can host a full dapp \u2013 frontend, backend and\ndata. Any user can deploy their dapp as a canister (smart contract) on the Internet Computer.\nCanisters are computational units that bundle together code and state. Canisters can store data,\ndeliver HTML, CSS and Javascript pages, and answer API requests. Canisters are incredibly fast\nand can deliver webpages within 200ms. Canisters can store up to 32 GB of data at an\nincredibly low cost ($5 per GB per annum ). Browsing dapps hosted on the Internet Computer is\nas seamless as browsing Web2 apps hosted on cloud. All these factors enable developers to\ndeploy even large-scale social media applications entirely on-chain without needing any cloud\nservices. Try out a few dapps deployed on the Internet Computer.\nWork\u0000ow\nWe now describe how a client can access a website deployed as a canister on the Internet\nComputer. The architecture involves 4 key components.\nClient - A device owned by the user. When the user browses a website, the client device\nsends a HTTP request.\nHTTP Gateway - A HTTP Gateway is a software that implements HTTP Gateway protocol. It\nconverts HTTP requests into a format understandable by canisters. When the canister sends\nback a response, the HTTP Gateway converts the response into a HTTP response. The HTTP\ngateway can be run either on the client, on the boundary nodes or on independent servers.\nBoundary Node - Boundary nodes keep track of the architecture of the Internet Computer. In\nparticular, boundary nodes keep track of the list of subnets, list of nodes on each subnet, the\ncanisters run by each subnet, etc. On receiving a canister query, boundary nodes can route\nthe request to one of the blockchain nodes running the canister.\nCanister - Developers can host their dapp as a canister. Canister consists of a bunch of\nmethods. Anyone can send queries to the canister. A query consists of the canister method toHow it works Canister smart contracts serve the W eb\n25.09.2023, 21:23 Canister smart contracts serve the W eb | Internet Computer\nhttps://internetcomputer .org/how-it-works/smart-contracts-serve-the-web/ 2/5be executed and the inputs for the canister method. The Internet Computer receives the\nqueries sent by the users, executes the corresponding canister method and returns the\nresponse to the user.\nHTTP Gateway converts the format of HTTP Requests to canister queries, and canister responses\nto HTTP responses.\nBoundary nodes route canister queries to appropriate subnet.\nDeploying web apps on the Internet Computer\nIf a canister wishes to serve web content, it should implement a method that consumes a HTTP\nrequest (url, http method and headers) and outputs a HTTP response (status, headers and body).\nThe canister method could return HTML, CSS and Javascript content as part of the HTTP\nresponse. Refer to Internet Computer Interface Spec for more details.\nThere\u2019s also an easy way to host existing static web apps (even those built using frameworks\nsuch as React and Angular) on the Internet Computer with minimal extra code by creating an\n\u201casset canister\u201d. An asset canister works similar to a regular canister, except that a lot of\nboilerplate code to host static websites is taken care of for us. To host a static website, we\nsimply need to create a canister, specify its type as \u201casset\u201d and specify the source folder of the\nweb app. Once the asset canister is deployed to the Internet Computer, the website can be\naccessed at http://<canister id>.ic0.app and http://<canister id>.raw.ic0.app. See tutorial or\nwatch the video.\nHTTP gateway protocol\nThe browser only communicates with HTTP(s) protocol and doesn\u2019t know how to query a\ncanister. To \u0000ll the gap between the browser and Internet Computer protocols, we utilize a\nHTTP Gateway, which is a software that sits in between the browser and the Internet Computer.\nThe browser sends a http request to the http gateway. The gateway \u0000rst interprets the URL in25.09.2023, 21:23 Canister smart contracts serve the W eb | Internet Computer\nhttps://internetcomputer .org/how-it-works/smart-contracts-serve-the-web/ 3/5the http request and extracts the corresponding canister id. It then converts the http request\ninto a canister query and sends it to the boundary nodes. When the canister sends back a\nresponse, the http gateway interprets the response, veri\u0000es the signatures, converts into a http\nresponse and sends it to the browser.\nThere are many ways to implement the HTTP Gateway protocol. Currently, there are 2\nimplementations.\nThe gateway protocol is implemented as a service worker. When the user enters a URL such\nas http://<canister id>.ic0.app, the browser calls the DNS service to resolve the query.\nCurrently, the DNS maps the ic0.app domain to the boundary nodes of the Internet\nComputer. When the browser makes a request to a boundary node, it responds with a service\nworker that implements HTTP Gateway protocol. The browser then installs the service\nworker. From then on, whenever the user makes a request to http://<canister id>.ic0.app, the\nbrowser passes on the request to the service worker.\nBoundary nodes also implement the HTTP Gateway protocol. When the user enters a URL\nsuch as http://<canister id>.raw.ic0.app, the browser sends the http request to the boundary\nnode, which acts as a http gateway. There are a few other ways of implementing the HTTP\nGateway protocol. The gateway can be implemented as a browser extension. The chromium\nbrowser could also be modi\u0000ed to include HTTP Gateway as part of the browser.\nSEO\nThe dapps runni ng on the Internet Computer seamlessly integrate into the Web 2.0 world as\ncrawlers are able to access them directly on-chain. This allows dapps to be indexed by search\nengines and for their metadata to be read in order to generate previews and cards on social\nplatforms. A tutorial on using the Search Engine Optimization (SEO) features of the Internet\nComputer can be found in this blog post.\nServing web content\nBuilding a front-end dapp on the IC\nHosting a static website on the IC\nHTTP Gateway Protocol25.09.2023, 21:23 Canister smart contracts serve the W eb | Internet Computer\nhttps://internetcomputer .org/how-it-works/smart-contracts-serve-the-web/ 4/5W eb Serving W iki Ar ticle\n25.09.2023, 21:23 Canister smart contracts serve the W eb | Internet Computer\nhttps://internetcomputer .org/how-it-works/smart-contracts-serve-the-web/ 5/5\n",
  "Canister smart contracts _ Internet Computer.pdf": "25.09.2023, 21:23 Canister smart contracts | Internet Computer\nhttps://internetcomputer .org/how-it-works/canister-lifecycle/ 1/3\nCanisters\nWhat are canisters\nOn the Internet Computer smart contracts come in the form of canisters. These are\ncomputational units which bundle together code and state. Canisters expose endpoints which\ncan be called both by other canisters and by parties external to the IC, such as browsers or\nmobile apps. There are two types of endpoints. Updates are calls that can modify the state of the\ncanisters and queries which cannot do that. A good mental model for these is that updates are\nused to write to the state of a canister and queries are used to read from that state. The code of\na canister consists of a W ebAssembly (Wasm) module. The state consists of the usual heap of\nthe Wasm module, together with stable memory, a special type of memory which plays an\nimportant role in the life-cycle of a canister.\nHow do canisters work\nCanisters behave much like actors from the actor-based concurrency model. Their code is single\nthreaded and is executed in complete isolation of other canisters. Canisters communicate with\none another via asynchronous messaging. When processing a message, a canister can make\nchanges to its state, send messages to other canisters, or even create other canisters. Unlike in\nthe traditional actor model, communication is bidirectional. Canister messages are either\nrequests or replies. For each request sent, the IC records a callback to be invoked when the\ncallee sends back a response. If the IC determines that there is no way for the callee to respond\nthen the system will produce a response. Another novel aspect of the canister based model is\nthe interplay between message processing and canister trapping. While processing a request a\ncanister may send requests to other canisters and wait for (some of) the replies, before\nproducing a reply to the original request. If a canister traps, its state is rolled back to the point\nright after it made the last outgoing call.\nResource chargingHow it works Canister smart contracts\n25.09.2023, 21:23 Canister smart contracts | Internet Computer\nhttps://internetcomputer .org/how-it-works/canister-lifecycle/ 2/3As they execute, canisters use resources in the form of memory, computation and network\nbandwidth. On the IC all of these are paid for using a unit called cycles. To this end, each\ncanister has a local cycles account from which the system deducts cycles as execution\nproceeds. Charging for memory usage is straightforward. The system keeps track of the memory\nused by the canister and regularly charges the canister\u2019s balance. For e\u0000ciency, this charging\nhappens at regular intervals but not every round. In contrast, charging for computation at the\ntime that computation is performed. To this end, the canisters are instrumented with code that\nallows the IC to count the num ber of instructions executed while processing a message. Every\nround, there is an upper bound on the numb er of instructions that can be executed during that\nround. If this num ber of instructions is exceeded, then execution is paused and continued in a\nsubsequent round. However, cycles for the computation performed during any round are\nalready charged at the end of that round. To prevent a buggy or malicious canister from\ncompletely taking over an execution core, the total numb er of rounds the execution of a canister\ncan take is also bounded.\nCharging for bandwidth is also done at the moment of use. When a canister wants to send a\nrequest to another canister, the system calculates the numb er of cycles that sending the\nmessage costs (the cost of sending has a \u0000xed component and a component that depends on\nthe size of the payload) and deducts the cost from the canister\u2019s balance. Furthermore, it also\ndeducts the cost of sending a maximal size reply from the callee since for inter-canister\nmessages the caller pays for reply. The cycles corresponding to the di\u0000erence between the\nmaximal size and the actual size of the reply are refunded to the canister when the reply arrives.\nWhen canisters run out of cycles, they are uninstalled (their code and state are deleted, but the\nrest of the information associated with the canisters are kept). To avoid that deletion happens\ntoo suddenly, canisters have associated a so-called freezing threshold. Once the canister\u2019s\nbalance dips below the freezing threshold (through charging by the system) then the canister\nstops processing any new requests; replies are still being processed. The system throws an error\nif at any time a canister attempts to perform an action (e.g. attaching cycles or sending a\nmessage) which would result in the cycles balance dipping below the freezing threshold.\nCanister management\nCanisters are managed by controllers which can be users or even other canisters. The control\nstructure of canisters could be centralized (e.g. when the controllers include some centralized\nentity), decentralized (when the controller is a DAO) or even non-existent, in which case the\ncanister is an immutable smart contract. Controllers are in charge of deploying and maintaining\nthe canisters to the IC and they are the only entities who are allowed to perform management\noperations on canisters. The most common such operations are deploying a canister smart25.09.2023, 21:23 Canister smart contracts | Internet Computer\nhttps://internetcomputer .org/how-it-works/canister-lifecycle/ 3/3contract to the IC and starting and stopping canisters. The controller of canisters can change the\ncanister parameters, including adding and removing controllers or changing the freezing\nthreshold.\nControllers can update the code that runs on canisters by submitting a new Wasm module\nwhich should replace the older one. By default, updating the Wasm module of a canister wipes\nout the Wasm memory but the content of the stable memory remains unchanged. The IC o\u0000ers\nan upgrade mechanism where three actions are executed atomically: serializing the Wasm\nmemory of the canister and writing it to stable memory, installing the new Wasm code and then\ndeserializing the content of the stable memory. Of course, a canister may ensure at all times that\nthe data that needs to be persisted across upgrades is stored in the stable memory in which\ncase the upgrade process is signi\u0000cantly simpler.\nThis talk covers how to create canister smart contracts on the Internet Computer, how to install\nand upgrade their software, and how to top up canisters with cycles.\n",
  "Certified Variables _ Internet Computer.pdf": "25.09.2023, 21:23 Certified V ariables | Internet Computer\nhttps://internetcomputer .org/how-it-works/response-certification/ 1/2\nCerti\u0000ed Variables\nWhy do you trust data obtained from a blockchain? Well, all transactions and the subsequent\nchanges to smart contract state made their way through the blockchain consensus protocol,\nwhich guarantees correctness as long as the underlying trust assumptions hold. But verifying\ncorrectness based on the consensus protocol is tedious: A client has to download and validate\nthe blockchain data. Even in the case of more e\u0000cient mechanisms such as Bitcoin's SPV or\nEthereum's light clients, clients still have to perform signi\u0000cant amounts of work, such as\ndownloading and validating block headers. This makes it di\u0000cult for applications with restricted\nuptime and resources, such as mobile or web applications, to operate on blockchain data\nwithout defaulting to centralized intermediaries.\nThe Internet Computer is di\u0000erent: Using chain-key cryptography, the Internet Computer can\ngenerate digital signatures that can be validated with a single, permanent public key belonging\nto the Internet Computer. Unlike with traditional digital signatures, however, the private key\nmaterial never  exists in a single place. It is always securely distributed between many di\u0000erent\nnodes, and valid signatures can only be generated when the majority of these nodes cooperates\nin a cryptographic protocol. A client application only has to embed the Internet Computer's\npublic key, and can immediately validate all certi\u0000ed responses it receives from the Internet\nComputer, without putting any trust into the particular node it received the response from.\nThe Internet Computer's certi\u0000cation feature is exposed to canisters through certified variables .\nFrom an application perspective, certi\u0000ed variables can be set during an update call to a\ncanister, when the canister changes its state during a transaction that went through consensus.\nThe certi\u0000cate can then be read in a subsequent query call, so the canister can respond to a\nclient's request in a trustworthy way but without incurring the additional delay of consensus.\nCerti\u0000ed variables also underlie many of the Internet Computer's advanced features such as\ncerti\u0000ed assets and Internet Identity.\nMore technically, each canister can specify a single 32-byte value that will be certi\u0000ed by the\nsubnet. Well-known concepts such as M erkle trees or, more generally, authenticated data\nstructures can be used to extend the certi\u0000cation from this single 32-byte value to arbitraryHow it works Certi\u0000e d Variables\n25.09.2023, 21:23 Certified V ariables | Internet Computer\nhttps://internetcomputer .org/how-it-works/response-certification/ 2/2amounts of data. Libraries such as certi\u0000ed-map make the feature easily accessible for\ndevelopers.\nHow Internet Computer Responses Are Certi\u0000ed as Authentic\nCerti\u0000ed Variables & Assets\n",
  "Chain-Key Cryptography _ Internet Computer.pdf": "25.09.2023, 21:21 Chain-Key Cryptography | Internet Computer\nhttps://internetcomputer .org/how-it-works/chain-key-technology/ 1/4\nChain-Key Cryptography\nSignatures\nA digital signature scheme is a very traditional type of public-key cryptosystem, in which a\nsecret key (held only by the signer) is used to generate a digital signature on a message, and a\npublic key (available to everyone) may be used to e\u0000ciently verify a digital signature on a\nmessage. The basic security property achieved by such a scheme is that a valid signature on a\nmessage cannot be created without explicitly invoking the signing algorithm with the\ncorresponding secret key.\nA threshold signature scheme is a digital signature scheme where the secret signing key is never\nstored in one location (which would become a single point of failure). Rather, the secret key is\ne\u0000ectively split up into secret shares, and each secret share is stored on a di\u0000erent machine. To\nsign a message, these machines must agree to sign the message and coordinate with one\nanother to generate a digital signature in a distributed fashion (importantly, without ever\nreconstructing the secret signing key in one location).\nChain-Key Technology\nWhile threshold signature schemes is a technology that has been around for a long time, the IC\nis the \u0000rst blockchain to fully integrate this technology in the core of its design. As described\nabove, the technology enables chain-key cryptography and all of its bene\u0000ts -- E\u0000cient\nveri\u0000cation of blockchain outputs, autonomous evolution of the IC topology, a source of\nunpredictable and unbiasable pseudo-random numb ers for canisters.\nEach subnet in the IC is associated with the public veri\u0000cation key of such a threshold signature\nscheme.\n\u0000\u0000\u0000Most importantly, this public key may be used to verify the outputs of the IC, including\nresponses to ingress messages from external users, as well as messages from one canister toHow it works Chain-Key Cryptography\n25.09.2023, 21:21 Chain-Key Cryptography | Internet Computer\nhttps://internetcomputer .org/how-it-works/chain-key-technology/ 2/4another. This is one of the fundamental di\u0000erences between the IC and other blockchains: the\nstate of other blockchains can only be validated by running the entire protocol from the\ngenesis block, whereas on the IC, it can be validated just by verifying a single digital\nsignature. As such, this is one of the key technologies that enables unprecedented scalability\non the Internet Computer.\n\u0000\u0000\u0000This public key is also used to verify the entire state of a subnet at regular intervals, which\nenables a number of functions, such as adding new nodes to a subnet and allowing crashed\nnodes to quickly catch up to the rest. This enhances both the scalability of the IC and is\ncrucial to enable the topology of the IC to autonomously evolve over time as orchestrated by\nthe NNS.\nIn addition, these threshold signatures are used as a way to create a source of unpredictable\npseudo-random numbers, which is used in two ways:\n\u0000\u0000\u0000as a source of unpredictable and unbiasable pseudo-random numbers available to any smart\ncontract, which is a totally unique feature in the blockchain world that enables applications\nthat would be impossible to implement on other blockchains (for example, an NFT ra\u0000e);\n\u0000\u0000\u0000as a mechanism for pseudo-randomly selecting the leader in the IC consensus protocol,\nwhich enhances the e\u0000ciency and fairness properties of consensus.\nImplementation\nThe threshold signature scheme implemented by the IC is a threshold version of the well-known\nBLS signature scheme. One reason for using the BLS signature scheme is that it is the only one\nthat yields a threshold signing protocol that is very simple and e\u0000cient. Indeed, a machine\nholding a share of the secret signing key can very easily generate a share of a signature on a\nmessage, and these signature shares can be combined to form a BLS signature on a message \u2013\nno further interaction between these machines is required.\nAnother reason for using the BLS signature scheme is that signatures are unique, meaning that\nfor a given public key and message, there is only one valid signature on that message. This\nunique-signature property is essential for the application to generating unpredictable and\nunbiased pseudo-random num bers for smart contracts: after a smart contract requests a\npseudo-random num ber (and not before!), a signature on a special message is generated, and\nthis signature is passed through a hash function to derive a seed from which the required25.09.2023, 21:21 Chain-Key Cryptography | Internet Computer\nhttps://internetcomputer .org/how-it-works/chain-key-technology/ 3/4pseudo-random num bers are generated. By the security property of the signature scheme,\nneither this seed nor the derived pseudo-random numb ers can be predicted or biased.\nWhile signing with threshold BLS is quite straightforward, designing a secure, decentralized\nprotocol for generating and distribution the shares of the secret signing key \u2013 that is, a DKG, or\nDistributed Key Generation protocol \u2013 remains a challenge. While there has been quite a bit of\nresearch on DKG design, the vast majority of DKG protocols in the literature do not meet the\ndemanding requirements of the Internet Computer, in that they either assume a synchronous\nnetwork (meaning that the protocols will fail or become insecure if messages are unexpectedly\ndelayed) or provide no robustness (meaning that the ability to produce signatures is completely\nlost if a single node should crash) or both. Neither of these assumptions are acceptable on the\nIC: security and liveness must hold even an an asynchronous network with many faulty nodes.\nDFINITY has designed, analyzed, and implemented a new DKG protocol that works over an\nasynchronous network and is quite robust (it will still succeed if up to a third of the nodes in a\nsubnet are crashed or corrupt) while still delivering acceptable performance. In addition to\ngenerating a new key, this protocol can also be used to reshare an existing key. This functionality\nis essential to enable autonomous evolution of the IC topology as subnet membership changes\nover time.\nChain Key Cryptography: The Scienti\u0000c Breakthrough Behind the Internet Computer\nIntegrating The Internet Computer and Bitcoin Networks\nVideo on non-interactive distributed key generation\nAppl ied Crypto: Introducing Noninteractive Distributed Key Generation\nNIDKG W hite Paper25.09.2023, 21:21 Chain-Key Cryptography | Internet Computer\nhttps://internetcomputer .org/how-it-works/chain-key-technology/ 4/4\n",
  "Chain-key signatures _ Internet Computer.pdf": "25.09.2023, 21:21 Chain-key signatures | Internet Computer\nhttps://internetcomputer .org/how-it-works/threshold-ecdsa-signing/ 1/2\nChain-key signatures\nCha in-key signatures extend chain-key technology to allow transactions targeted at other\nblockchains to be computed fully on-chain using the Internet Computer Protocol. Using chain-\nkey signatures, the IC can integrate with other blockchains in a completely trustless manner.\nIndeed, using chain-key signatures is the strongest, most decentralized way of integrating\nblockchains as no additional trust assumptions besides that of the two blockchains are required,\nparticularly no additional parties that manage signature keys or their shares.\nJust like chain-key technology, a key component of chain-key signatures is threshold\ncryptography. The threshold signature schemeused to implement chain-key cryptography is\nbased on BLS signatures. While BLS signatures have distinct advantages, they are simply not\ncompatible with other blockchains. In order to work with other blockchains, the IC must use\nthreshold signatures that are compatible with the digital signature schemes of those other\nblockchains. By far, the most commonly used signature scheme used on other blockchains\n(including Bitcoin and Ethereum) is the ECDSA signature scheme. Because of this, thr esho ld\nECDSA signatures are currently supported on the IC, with implementations of other threshold\nsignature schemes in the planning stages.\nECDSA signatures are widely used in the blockchain industry. This feature will enable canister\nsmart contracts to have an ECDSA public key and to sign with regard to it. The corresponding\nsecret key is threshold-shared among the nodes of the subnet holding the canister smart\ncontract. This is a prerequisite for the direct integration between the Internet Computer and\nBitcoin and Ethereum.\nImplementing a secure and e\u0000cient threshold signing protocol for ECDSA is much more\nchallenging than for BLS signatures. While there has been a \u0000urry of research on threshold\nECDSA in recent years, none of these protocols meet the demanding requirements of the\nInternet Computer: they all either assume  a synchr onous network (meaning that the protocols\nwill fail or become insecure if messages are unexpectedly delayed) or provide no robustness\n(meaning that the ability to produce signatures is completely lost if a single node should crash)\nor both. Neither of these assumptions are acceptable on the IC: security and liveness must hold\neven an an asynchr onous network with many faulty nodes.How it works Chain-key signatures\n25.09.2023, 21:21 Chain-key signatures | Internet Computer\nhttps://internetcomputer .org/how-it-works/threshold-ecdsa-signing/ 2/2DFINITY has designed, analyzed, and implemented a new threshold ECDSA signing protocol\nthat works over an asynchr onous network and is quite robust (it will still produce signatures if up\nto a third of the nodes in a subnet are crashed or corrupt) while still delivering acceptable\nperformance. Papers written by DFINITY's researchers describe the protocol in detail and\nprove the key elements of its security.\nECDSA W hite Paper\nECDSA GitHub\nM otion Proposal 21340\nThe Internet Computer Community Adopts Threshold ECDSA Signatures M otion Proposal\n",
  "Chain-key Tokens _ Internet Computer.pdf": "25.09.2023, 21:22 Chain-key Tokens | Internet Computer\nhttps://internetcomputer .org/how-it-works/chain-key-tokens/ 1/6\nChain-Key Tokens\nOne important way how di\u0000erent blockchains can cooperate is by bringing tokens from one\nblockchain to another one, for example, bringing Bitcoin to the Ethereum chain. In traditional\nblockchain architectures, this is mostly accomplished through wrapping. More decentralized\n(and secure) alternatives to wrapping exist and can replace it: Meet cha in-key cryptography and\ncha in-key tokens!\nA wrapped token represents an underlying asset, which is typically native on a di\u0000erent\nblockchain than the wrapped token. For example, a wrapped bitcoin token represents real\nbitcoin, but is a di\u0000erent token than bitcoin and available on a di\u0000erent chain, for example, on\nthe Ethereum blockchain. Traditional wrapping always involves intermediaries that need to be\ntrusted.\nA more secure alternative to wrapping tokens is to use advanced threshold cryptography to\nobtain cha in-key tokens. Chain-Key Bitcoin, the \u0000rst major chain-key token on the Internet\nComputer, is a token on ICP with a 1:1 backing with real bitcoin held 100% on chain on ICP by a\nsmart contract. Thus, it is a Bitcoin \u2018twin\u2019 on the Internet Computer that features low transaction\nfees and latency and high throughput, similar in properties to a Bitcoin Layer 2. We use Chain-\nKey Bitcoin as an example for chain-key tokens throughout this page. Chain-key fungible tokens\nshould implement the ICRC-1 token standard so that they can be easily integrated by services,\nfor example, wallets and DEXs. This helps make chain-key tokens readily available for a wide\nrange of services.\nTraditional Wrapped Tokens\nIn traditional blockchain architectures, token wrapping involves an o\u0000-chain trusted\nintermediary and a token ledger smart contract. A user who wants to have tokens of a speci\u0000c\ntype, say a wrapped bitcoin token, sends tokens of the underlying asset, such as bitcoin, to the\nintermediary. The intermediary, once it has con\u0000rmed the transfer of the underlying token on the\ntoken's native blockchain, keeps the received tokens in custody and instructs the token ledger to\ncreate, or mint, the same amount of wrapped tokens that it has received of the underlying token.How it works Chain-key Tokens\n25.09.2023, 21:22 Chain-key Tokens | Internet Computer\nhttps://internetcomputer .org/how-it-works/chain-key-tokens/ 2/6Minting increases the supply of the wrapped token. The newly minted wrapped tokens can then\nbe used on the token's blockchain, and the token ledger keeps track of all accounts.\nIf a user wants to redeem wrapped tokens for the underlying asset, this again involves the\nintermediary: The user sends the wrapped token to an address controlled by the intermediary\nand makes an unwrap request. The intermediary removes the amount of received wrapped\ntokens from the wrapped token's supply and returns the corresponding amount of underlying\ntokens to the user on the blockchain that natively hosts the underlying asset.\nRegular users can just use the wrapped tokens and normally need not bother with the wrapping\nand unwrapping themselves, unless they own the underlying token and want to bring it to\nanother chain or obtain the underlying token via its wrapped version. Thus, wrapped tokens are\nconvenient for most users and as easy to use as any native token on the same blockchain.\nThis traditional o\u0000-chain approach of wrapping works well from a functional perspective, but\nhas the major drawback of involving an intermediary whose integrity is crucial for the security of\nthe wrapping and unwrapping of the token. The main problem is that the intermediary can get\ncompromised, for example, hacked, defrauded by an insider, or go out of business, which may\nresult in a total loss of the underlying tokens in the worst case. Strategies such as multi-signature\nschemes with keys held by multiple parties to try to decentralize the intermediary can provide\nsome mitigation, but do not change the fact that wrapping is done by an o\u0000-chain entity or\ngroup of entities. In short, this architecture is not fully decentralized. Overall, this traditional way\nof realizing wrapped tokens is not desirable for reasons of security, risk, and its inherent\ncentralized nature.\nAnother potential risk comes into play with those wrapping architectures: Ideally, a wrapped\ntoken is always backed 1:1 by the underlying token. In practice, however, the intermediary can\nuse the tokens held in custody to create pro\u0000t, for example, by using them for risky investments.\nIn the worst case, if things go wrong, this can lead to the loss of tokens and a depegging of the\nwrapped token.\nChain-Key Tokens\nChain-key tokens, such as Chain-Key Bitcoin, are an advanced cryptography-based\nreplacement for wrapped tokens o\u0000ering stronger security: With chain-key tokens, all\noperations are performed completely on chain by smart contracts, without involving any o\u0000-\nchain intermediaries. This eliminates the intermediary-related risks of traditional wrapping\narchitectures. Replacing wrapping with on-chain operations only becomes possible through the\nnative integrations between blockchain networks and particularly the use of advanced\ncryptography \u2014 cha in-key signatures. Chain-Key Bitcoin (ckBTC) is the \u0000rst chain-key token25.09.2023, 21:22 Chain-key Tokens | Internet Computer\nhttps://internetcomputer .org/how-it-works/chain-key-tokens/ 3/6available on ICP. For each ckBTC token, a real bitcoin is held on chain by a canister smart\ncontract.\nWe next give an overview on how chain-key tokens function based on a native chain integration\nand advanced cryptography.\nArchitecture\nThe architecture of any chain-key token on ICP is using the following building blocks as its\nfoundation:\n\u0000\u0000\u0000Some form of native integration with another blockchain that hosts the underlying token, for\nexample, the Bitcoin network and its only token, Bitcoin, must be available. This integration\nmust allow canisters on ICP to query balances of addresses of the underlying token on its\nnative chain as well as send transactions to the underlying chain. This integration with the\nnative chain must be done such that no intermediaries are required, that is, is completely\ndecentralized and realized on chain.\n\u0000\u0000\u0000A chain-key implementation of the signature scheme used for signing transactions on the\nblockchain hosting the underlying asset must be available, for example, chain-key ECDSA for\nBitcoin. This functionality makes it possible to sign transactions for the chain of the underlying\ntoken fully on chain using threshold cryptography without involving an intermediary.\nThose two building blocks comprise the native integration with a particular blockchain. ICP has\nalready been integrated with the Bitcoin network using this approach, and an integration with\nEthereum is planned. Based on this foundation, chain-key token implementations can be built at\nthe smart-contract layer. One possible architecture to implement a chain-key token for a\nspeci\u0000c underlying token, for example, Bitcoin, uses two canister smart contracts: A cha in-key\ntoken ledger and a cha in-key token smart contract. For the cha in-key token ledger, the ICRC-1\ntoken standard should be used for wide compatibility in the ecosystem. The same open source\nledger code base can be used and parameterized for any chain-key token to be deployed. In\naddition to the chain-key token ledger, a cha in-key token smart contract is used in this\narchitecture. This canister essentially replaces the o\u0000-chain intermediary of the traditional\nwrapping architecture with on-chain functionality for the chain-key token architecture. This\ncanister is also called minter as it is responsible for creating (and removing) supply of the chain-\nkey token based on in- and out-\u0000owing underlying tokens. It keeps any underlying tokens it\nreceives in on-chain custody as long as corresponding chain-key tokens are in circulation, thus\nensuring a 1:1 backing of the chain-key token with the underlying asset. The 1:1 backing of the\nchain-key token by its underlying token can be veri\u0000ed by anyone by checking that the Bitcoin25.09.2023, 21:22 Chain-key Tokens | Internet Computer\nhttps://internetcomputer .org/how-it-works/chain-key-tokens/ 4/6UTXOs the minter claims to hold indeed are held by Bitcoin addresses controlled by the minter,\nthereby further enhancing trust.\nHigh-level architecture for chain-key tokens on ICP\nNote that the token ledger and minter functionalities can also be integrated into a single smart\ncontract or more than two \u2014 this is a question of software architecture. However, splitting the\nfunctionality into two canisters as outlined is a sensible approach for the reason of modularity as\nthe same ledger canister code can be reused for any chain-key token and only the minter needs\nto be adapted to the mechanics of the token of the underlying chain, particularly to account for\ndi\u0000erences between UTXO- and account-based underlying chains, like Bitcoin and Ethereum,\nrespectively.\nCreating Chain-key Tokens from Underlying Tokens\nWhen a user wants to obtain chain-key tokens for some underlying tokens, for example, bitcoin,\nthey send the underlying tokens to an address on the origin blockchain owned by the chain-key\ntoken smart contract (minter), instead of an intermediary as done for wrapping. The chain-key\ntoken smart contract has an address on the origin blockchain, which is made possible through\nchain-key cryptography, hence the name of chain-key tokens, or chain-key Bitcoin as a concrete\nexample: In the Bitcoin example, using chain-key ECDSA signing technology \u2014 concretely, an\nadvanced form of threshold ECDSA, the chain-key Bitcoin smart contract can have and use\nECDSA key pairs, much like any user of the Bitcoin network, but fully on chain. That means the\nsmart contract can obtain ECDSA public keys and from the public keys it derives addresses on\nthe Bitcoin network, to which bitcoin can be sent on the Bitcoin network by anyone. Once this\nchain-key token smart contract has received Bitcoin from a user and the transaction has\nreceived a su\u0000cient num ber of con\u0000rmations on the Bitcoin network, the canister instructs the\ntoken ledger for the chain-key token to create, or mint, an amount of chain-key Bitcoin tokens\ncorresponding to the received amount of bitcoin. This approach leads to the chain-key token\nbeing 1:1 backed with the underlying token, which is held in on-chain custody by the minter\ncanister smart contract.25.09.2023, 21:22 Chain-key Tokens | Internet Computer\nhttps://internetcomputer .org/how-it-works/chain-key-tokens/ 5/6Allowing the chain-key token smart contract to know about the balances of the addresses in the\nunderlying chain it controls requires an integration between ICP and the Bitcoin network \u2014 the\nblockchain hosting the native asset to be issued a chain-key token for: ICP nodes connect to\nnodes of the Bitcoin network and pull in and validate Bitcoin blocks, extract the UTXOs and\nmaintain the Bitcoin UTXO set on chain. Any smart contract can then query the balance and\nUTXOs of a Bitcoin address. This is what is described as (1) in the section on architecture above.\nRedeeming Chain-key Tokens for Underlying Tokens\nA chain-key token can circulate on the ICP as long as needed. There is no need to frequently\nbring in and transfer out underlying tokens, and normally there is no need for most users to do\nthis themselves. However, a user may want to redeem chain-key tokens they hold at some point\nto receive the underlying asset. In this case, they send the amount of chain-key tokens to\nredeem, for example, ckBTC in our example, to the chain-key token canister (minter) for the\ntoken with a request to redeem them. The canister \u0000rst removes the received chain-key tokens\nfrom the supply on the chain-key token's ledger. Next, it creates a transaction on the blockchain\nof the underlying token, the Bitcoin network in this example, to transfer the same amount of\nunderlying tokens (modulo fees) that it has received of chain-key tokens to a user-provided\naddress on the Bitcoin network. This step involves chain-key signatures \u2014 concretely an\nadvanced form of threshold ECDSA signing \u2014 to authorize the transaction on the underlying\nblockchain (foundation (2) above). The chain-key-signed transaction is then sent out via inter-\nchain communication from ICP nodes to Bitcoin nodes, another crucial functionality of the\nnative blockchain integration explained in (1) above.\nSpeci\u0000cs of Chain-Key Bitcoin\nSince Bitcoin uses the UTXO model for tracking account balances, the wrapping contract needs\nto implement proper handling of UTXOs, which is far from trivial. This involves, for example, a\ngood heuristic selection of UTXOs to consume when transferring bitcoin back to users, as well\nas handling error cases, for example, when transactions do not get mined on the Bitcoin network\ndue to too low fees. Implementing this properly and considering all edge cases is hard and\nrequires well-thought-out algorithms in the implementation of the chain-key token canister.\nThe Future: Chain-Key ERC-20 Tokens\nWhen the Internet Computer blockchain will integrate with additional blockchains in the future,\nmore chain-key tokens will become available on ICP. The token ledger of a new chain-key token25.09.2023, 21:22 Chain-key Tokens | Internet Computer\nhttps://internetcomputer .org/how-it-works/chain-key-tokens/ 6/6can use the same ICRC-1 ledger code base, parameterized for the respective new chain-key\ntoken. The chain-key token canister smart contracts, or minter, needs to be re-written for\ndi\u0000erent blockchains. The next major blockchain integration being planned is ICP <> ETH,\nbringing Ethereum's ERC-20 tokens to the IC as chain-key tokens. This requires a new variant of\nthe minter canister for ERC-20 tokens that is then replicated for each token.",
  "DAO crypto evolved _ Internet Computer.pdf": "25.09.2023, 21:24 DAO crypto evolved | Internet Computer\nhttps://internetcomputer .org/sns 1/8\nDevelopers can now hand over their Web3 service to an SNS.\nThe communi ty can buy governance tokens to take ownership\nand control through the SNS DAO and shape the dapp\u2019s\nfuture.\nLAUNCH AN SNS DAO\nHOW TO PARTICIPATE (FAQ)DAO crypto evolved\nA Service Nervous Systems (SNS) is an advanced form of a DAO. A digital democracy\nthat can run any dapp such as a social network in a fully decentralized way, fully on\nchain. No corporation, no board of directors, no CEO required.\n25.09.2023, 21:24 DAO crypto evolved | Internet Computer\nhttps://internetcomputer .org/sns 2/8\nEasy to get started\nWhen you, as a dapp developer, decide to hand over your Web3 dapp to an SNS, you decide on\nthe SNS parameters and submit a proposal to the NNS, the Internet Computer\u2019s DAO. When the\nproposal is accepted, the NNS launches the new SNS and assigns it full control over the app.\nThe newly-created SNS tokenizes the dapp through an initial decentralization swap: Part of the\ndapp\u2019s governance tokens (utility tokens) are bought by the community, providing funding the\nDAO. Part of the dapp\u2019s utility tokens are allocated to the original developer(s) as a reward for\ntheir initial e\u0000orts. The rest remains in a treasury the SNS DAO controls, and is used to fund the\nfuture development of the dapp.\nYour dapp is now fully decentralized!\nCommuni ty owned\nThe dapps that people love and engage with on a daily basis, like social media platforms, games,\nor online news media outlets, can now be owned and governed by the people themselves \u2014 the\nusers and developers of those dapps. This comes with substantial bene\u0000ts: The users own the\nservice, instead of the service monetizing the users. The users can shape how \u201ctheir\u201d service\nshould evolve in the future. No centralized entity, like a corporation, can unilaterally make\ndecisions negatively a\u0000ecting the users and their personal data. This greatly reduces the\nplatform risk for entrepreneurs who build services on top of decentralized apps.25.09.2023, 21:24 DAO crypto evolved | Internet Computer\nhttps://internetcomputer .org/sns 3/8Autonomous\nAfter an SNS DAO has taken control of a dapp, it is governed by the token holders in a\ncompletely decentralized way through its SNS DAO. In contrast to existing DAOs, in which\ngovernance applies only to smart contract logic, i.e., just a small part of a Web3 application, an\nSNS DAO controls every aspect of a dapp.\nToken holders submit and vote on proposals to govern how the dapp should evolve, e.g., to\ndecide on code updates. When a proposal is approved by the community, the SNS executes it\nautonomously, e.g., to update the code of the dapp. No single entity can stop the process.\nTokenized\nPeople participating in the dapp\u2019s governance earn voting rewards, much like in the Internet\nComputer\u2019s NNS DAO. Liquid democracy allows token holders to delegate certain decisions to\nthose they deem more appropriate to make them, resulting in better overall decisions on the\nprogress of the DAO.\nThe dapp\u2019s utility token not only enables this advanced form of governance, but the tokenization\nof the dapp can help drive adoption and user engagement, e.g., through airdrops or tokens\nearned by contributing users.\nTruly decentralized25.09.2023, 21:24 DAO crypto evolved | Internet Computer\nhttps://internetcomputer .org/sns 4/8Decentralizing dapps through SNSs is the third level of decentralization on the Internet\nComputer. The \u0000rst level is the ICP blockchain that runs on decentralized node machines\ndistributed throughout the world, operated by independent entities, and hosted in independent\ndata centers. The second level is the Network Nervous System (NNS) that governs the\ndecentralized ICP blockchain. The third level is the SNS-based decentralization of dapps running\non the decentrally-governed decentralized platform. Only such decentralization on every level\n\u2014 the platform itself, the platform's governance, and the governance of the individual dapps\nrunni ng on this platform \u2014 enables truly decentralized apps. Only possible on the Internet\nComputer.\nOpen Chat is an early \"open internet service.\" An SNS DAO assumed control of its\nsmart contracts, and swapped $ICP for its governance tokens, placing its community\n25.09.2023, 21:24 DAO crypto evolved | Internet Computer\nhttps://internetcomputer .org/sns 5/8\nin control, and creating a powerful community treasury.\nSee how OpenChat decentralized, fully on-chain\nWhat is an SNS DAO\nHow to raise funding for an SNS DAOHave an SNS transform your Web3 app into a\ntrue dapp\nLAUNCH AN SNS DAO\nHow to participate (FAQ)\nEngage your community\nUsers become your biggest contributors. Co-create a dapp your community wants.25.09.2023, 21:24 DAO crypto evolved | Internet Computer\nhttps://internetcomputer .org/sns 6/8\nSpeed up user adoption\nUsers become your biggest advocates. The success of your dapp is the success of its community.\nFund the future of your dapp\nUsers become your biggests supporters. Get your dapp funded through a community-driven\ndecentralization swap.\n25.09.2023, 21:24 DAO crypto evolved | Internet Computer\nhttps://internetcomputer .org/sns 7/8Fully On-chain with DFINITY\nNext Generation DAOs\nEpisode #2 | SNS\nWhat an SNS DAO is NOT\nNot an ICO\nNo funds are directly handed over to developers. The creation of an SNS is initiated by a\ndecentralized entity (the NNS), and ICP raised by the decentralization swap is allocated to the\ntreasury of the newly born SNS DAO. The founders receive a portion of the NNS DAO tokens in\nthe form of locked neurons.\nNot an IPO\nThis is not a liquidity exit or a public listing. It\u2019s the start of a new journey where you as the initial\ncreator and your users have the opportunity to form a digital community, 100% on-chain, to co-\nevolve and grow the platform or application.\nWhat an SNS DAO IS\nDecentralization Swap\nLaunching an SNS DAO requires the following:\nAn existing Web3 dapp to be decentralized.\nSubmission of an NNS proposal requesting a decentralization swap.\nNNS approval of the decentralization swap.\nICP investments to meet minimum funding requirements.\n25.09.2023, 21:24 DAO crypto evolved | Internet Computer\nhttps://internetcomputer .org/sns 8/8Once these steps are completed, newly minted SNS governance tokens are distributed\namong participants of the swap and the developers who now control the SNS DAO.\nWhat remains from the decentralization swap is put in a treasury that is used for funding\nthe future development of the dapp.\n",
  "Fault tolerance _ Internet Computer.pdf": "25.09.2023, 21:23 Fault tolerance | Internet Computer\nhttps://internetcomputer .org/how-it-works/fault-tolerance/ 1/5\nFault tolerance\nWhether due to hardware failure, bugs, power outages, or even attacks: Individual nodes may\nfail at any time. The Internet Computer is designed to be fault tolerant, which means that the\nnetwork will make progress even if some nodes fail or misbehave.\nHandling node  failures\nIn each round a block is proposed by the consensus layer and the messages in the block are\nprocessed subsequently by the execution layer. The proposed block and the resulting state need\nto be signed by at least 2/3rd of the nodes in the subnet in order for the subnet to make\nprogress. As long as less than 1/3rd of the nodes in a subnet fail or misbehave, even in an\narbitrary, Byzantine manner, the subnet will continue making progress.\nLet us consider a scenario where less than 1/3rd of the nodes in a subnet fail while the remaining\nnodes of the subnet continue to make progress. We will now describe how a failed node can\nrecover automatically and catch up with the other normally-operating nodes. A newly joined\nnode also uses the same process to catch up with the existing nodes in the subnet.\nHere\u2019s one natural solution. A failed or newly joined node could download all the consensus\nblocks it missed from its peers, and process each block one by one. Unfortunately, new nodes\nwill take a long time to catch up if they have to process all the blocks from subnet genesis.\nAnother solution is to let the failed or newly joined node directly sync the latest state from its\npeers. However, the peers are continuously updating their state as they process new blocks.\nSyncing the latest state while the peers are updating it could lead to inconsistencies.\nICP follows a mix of both the approaches. The consensus protocol is divided into epochs. Each\nepoch comprises a few hund red consensus rounds. At the beginning of each epoch, all the\nnodes make a backup copy of their blockchain state, and create a catch- up package (CUP). The\nCUP at height h contains all relevant information required for consensus to resume  from height\nh. This includes the hash of the blockchain state after processing the block at height h. The CUPHow it works Fault tolerance\n25.09.2023, 21:23 Fault tolerance | Internet Computer\nhttps://internetcomputer .org/how-it-works/fault-tolerance/ 2/5is then signed by at least 2/3rd of the nodes in the subnet. Each normally-operating node then\nbroadcasts the CUP.\nAll the nodes in the subnet listen to the CUP messages broadcast by their peers. Suppose a node\nobserves that a received CUP has a valid signature (signed by at least 2/3 of the nodes in the\nsubnet) and has a di\u0000erent blockchain state hash than the locally available state hash. Then the\nnode initiates the state sync protocol to sync the blockchain state at that height (the height at\nwhich the CUP is published). The blockchain state is organized as a Merkle tree and can\ncurrently reach a size of up to half a terabyte. The syncing node might already have most of the\nblockchain state and may not need to download everything. Therefore, the syncing node tries to\ndownload only the subtrees of the peers\u2019 blockchain state that di\u0000er from its local state. The\nsyncing node \u0000rst requests for the children of the root of the blockchain state. The syncing node\nthen recursively downloads the subtrees that di\u0000er from its local state.\nThe catching-up replica only syncs the parts of the replicated state that di\u0000er from the up-to-date\nreplica\nNote that while the failed/newly joined nodes are syncing the blockchain state, the well-\nfunctioning nodes continue to process new blocks and make progress. The well-functioning\nnodes use their backup copy of the blockchain state (created at the same time as the CUP) to\nsupply the state to syncing nodes. After the syncing node \u0000nishes syncing the blockchain state,\nit will request the consensus blocks generated since the CUP and process the blocks one by\none. Once fully synced, the node can then process messages regularly like the other nodes.\nHandling regular subnet failures25.09.2023, 21:23 Fault tolerance | Internet Computer\nhttps://internetcomputer .org/how-it-works/fault-tolerance/ 3/5In rare cases, an entire subnet can get stuck and fail to make progress. A subnet can fail due to\nmany reasons such as software bugs that lead to non-deterministic execution. This can also\nhappen when more than 1/3rd of the nodes in the subnet fail at the same time. In this case, the\nwell-functioning nodes fail to create and sign a catch-up package (CUP), and thereby the failed\nnodes cannot recover automatically.\nWhen a subnet fails, manual intervention is needed for recovery. In a nutshell, as the subnet\nnodes fail to create and sign a CUP automatically, someone needs to manually create a CUP. The\nCUP needs to be created at the maximum blockchain height where the state is certi\u0000ed by at\nleast 2/3rd of the nodes in the subnet. The subnet nodes naturally cannot trust a manually\ncreated CUP for security reasons. Therefore, we need a community consensus that the CUP is\nvalid. The Internet Computer has a blockchain governance system called the Network Nervous\nSystem (NNS). We need to manually submit a proposal to the NNS to use the created CUP for\nthe subnet. Anyone who staked their ICP can vote on the proposal. If a majority of the voters\naccept the proposal, the CUP is stored in the NNS registry.\nEach node runs 2 processes \u2014 (1) Replica and (2) Orchestrator. The replica consists of the 4-\nlayer software stack that maintains the blockchain. The orchestrator downloads and manages\nthe replica software. The orchestrator regularly queries the NNS registry for any updates. If the\norchestrator observes a new CUP in the registry, then the orchestrator restarts the replica\nprocess with the newly created CUP as input. As described earlier, the CUP at height h has\ninformation relevant to resume the consensus from height h. Once the replica starts, it will\ninitiate a state sync protocol if it observes that the blockchain state hash in the CUP di\u0000ers from\nthe local state hash. Once the state is synced, it will resume  processing consensus blocks.\nNote that this recovery process requires submitting a proposal to the NNS, and therefore works\nonly for recovering regular subnets (not the NNS subnet). This process of recovering a subnet is\noften termed as disaster recovery in many Internet Computer docs.\nHandling NNS canister failures\nThe Internet Computer has a special subnet called the Network Nervous System (NNS) which\nhosts a lot of canisters that govern the entire Internet Computer. This includes the root canister,\ngovernance canister, ledger canister, registry canister, etc.\nSuppose a canister in the NNS fails while the NNS subnet continues to make progress. This\ncould be due to a software bug in the canister\u2019s code. We then need to \u201cupgrade\u201d the canister,\ni.e., restart the canister with a new Web Assembly (WASM) code. Generally speaking, each\ncanister in the Internet Computer has a (possibly empty) list of \u201ccontrollers\u201d. The controller has25.09.2023, 21:23 Fault tolerance | Internet Computer\nhttps://internetcomputer .org/how-it-works/fault-tolerance/ 4/5the right to upgrade the canister\u2019s WASM code by sending a request to the subnet\u2019s\nmanagement canister. The lifeline canister is assigned as a controller for the root canister. The\nroot canister is assigned as a controller for all the other NNS canisters. The root canister has a\nmethod to upgrade other NNS canisters (via calling the management canister). Similarly, the\nlifeline canister has a method to upgrade the root canister (via calling the management canister).\nSuppose the governance canister is working. Then we can manually submit an NNS proposal to\ncall the root/lifeline canister\u2019s method to upgrade the failed canister. Anyone who staked ICP\ncan vote on the proposal. If a majority of the voters accept, then the failed canister will be\nupgraded.\nHandling NNS subnet failures\nIn the worst case, the entire NNS subnet could get stuck and fail to make progress. In such a\ncase, all the node providers who contributed a node to the NNS subnet need to manually\nintervene, create a CUP and restart their node with the new CUP.\n25.09.2023, 21:23 Fault tolerance | Internet Computer\nhttps://internetcomputer .org/how-it-works/fault-tolerance/ 5/5\n",
  "History - Internet Computer Wiki.pdf": "25.09.2023, 21:21 History - Internet Computer Wiki\nhttps://wiki.internetcomputer .org/wiki/History 1/3\nThe Internet ComputerHistory\nIn 2013, the Bitcoin network experienced tremendous growth, which inspired many people. At the time, DFINITY  Foundation\nfounder Dominic W illiams was running an MMO  (https://en.wikipedia.org/wiki/Massively_multiplayer_online_game)  computer\ngame he had built and grown to several million users, in the role of an engineering entrepreneur , using custom technical\ninfrastructure. He caught the Bitcoin bug like many others, and having already worked extensively with cryptography and\ndistributed systems, he transitioned to working full-time in blockchain.\nBy the end of 2013, Dominic was seeking technical means to build faster blockchains that\ncould process more transactions per second, which he hoped would support a trade in\nvirtual goods within the computer games ecosystem, and he acquired the domain name\n\"gamecoin.org.\" This activity led to him spending 2014 working on a blockchain project\ncalled \"Pebble.\" His work on Pebble pioneered two major firsts in blockchain: (1) the\nadaptation of traditional distributed computing mathematical techniques for use within a\nblockchain setting, and (2) an ef fort to design a scalable blockchain that could process\nhundreds of thousands of transactions a second.\nDominic released v0.977 of the Pebble white paper in October 2014. Although it\nrepresented the product of substantial work, at 98 pages in length, at the time it was only\ncirculated among early crypto industry insiders, and cryptographers, including V italik\nButerin, Nick Szabo, Elaine Shi and Dan Boneh. The project had great potential, and\npropounded several important new approaches to blockchain design, but was ultimately not pursued, largely owing to Dominic's\nemerging interests as part of the early Ethereum community .\nWhile working on Pebble in 2014, Dominic had become involved with the early Ethereum community , becoming an avid early supporter\nof the project, which he remains to this day . At the time, the concept of a blockchain that could run software (i.e. smart contracts), which\nstored and processed data within an unstoppable, tamperproof and autonomous on-chain environment, was both revolutionary and\ncontroversial within the industry . Ethereum was pioneering a new \"general-purpose\" form of blockchain, which departed from \"coins-\nonly\" designs, such as Pebble. This upset some parts of the Bitcoin community . Vitalik Buterin  (https://en.wikipedia.org/wiki/V italik_Buter\nin), the founder of Ethereum, credits Dominic with co-inventing the term \"Bitcoin Maximalism\"  (https://twitter .com/V italikButerin/status/98\n7360195553759232)  during this era.\nAt some point, the concept of a blockchain playing the role of a \" World Computer \" was mooted within the Ethereum community . One\ninterpretation was that such a network would perform a trickle of simple but important smart contract computations for the world.\nHowever , Dominic's interpretation, based on his work, was that World Computer  blockchain would inevitably eventually host much of\nhumanity's systems and services, and all its data and compute, largely replacing traditional IT , and transforming social media, gaming,\nfinance, enterprise systems and many other domains.\nIn 2015, however , Dominic was a lone heretic, and was largely alone in believing that the creation of a true World Computer  blockchain\nwas technically feasible, let alone that it might be capable of successfully playing that role in competition with centralized computing\ninfrastructure. Since Dominic strongly believed otherwise, based on his accumulated technical experiences and work on crypto theory ,\nhe decided to dedicate himself to blockchain research that might realize the concept, originally , he hoped, in the form a more advanced\nEthereum 2.0. He stopped work on Pebble, and directed all his future ef forts towards the realization of the World Computer  blockchain\nvision.\nIn early 2015, Dominic's thinking about blockchain design had become more mature, and he began proposing new approaches to\nconsensus, applied cryptography and blockchain network architecture. Around that time, he began using the name DFINITY  as a brand\nfor his work, which takes its characters from decentralized in finity . During this era, Dominic was pioneering multiple technical\napproaches that have been proven over time, and innovations that remain powerful ideas today . Much of his early 2015 work was also\ntargeted towards improving the performance and scalability of existing Proof-of-W ork networks like Bitcoin.\nHere in May 2015 Dominic gives a talk discussing Sybil resistance and consensus at San Francisco Bitcoin Devs  (https://www .youtube.\ncom/watch?v=dfGDhDR_3Gc) , in which he describes the \"3 E's of Sybil Resistance\" and discusses consensus work originating from the\nPebble project. Other interesting historical material that provides insights into his role at the time, include a panel on scalability with\nVitalik Buterin and Gavin W ood (https://www .youtube.com/watch?v=1KaQsrqC94s) , and a talk introducing basic aspects of consensus\ntheory  (https://www .youtube.com/watch?v=3iSw03pJ-gk) , at Ethereum's DEVCON1 later that year .\nThrough the period 2015 to 2016, V italik Buterin, and associates such as Vlad Zamfir , were the Ethereum project's primary consensus\nresearchers, and were highly focused on developing cryptoeconomic  (https://en.wikipedia.org/wiki/Cryptoeconomics)  schemes,\nincluding under the Casper banner . Meanwhile, Dominic was more focused on finding new ways to leverage advanced cryptography\nand distributed computing math, and devising alternative blockchain architectures, which might enable a World Computer  to be\nproduced. Owing to the long-term nature of Dominic's work, and its more technical approach, eventually it became clear to him that\nDFINITY  should become an independent project.\nAlthough the DFINITY  project eventually trod its own longer path, important traces of DFINITY  thinking remain within the Ethereum\nproject. For example, early in 2015, Dominic first proposed using a scheme called Threshold Relay , which involved using BLS\ncryptography  (https://en.wikipedia.org/wiki/BLS_digital_signature)  to generate random numbers, then using those numbers to drive a\nblockchain \u2014 essentially by selecting random committees of nodes that would produce and finalize blocks by \"attesting\" to, or\n\"witnessing\" them. Ethereum 2.0's Beacon Chain  (https://ethereum.org/en/upgrades/beacon-chain/)  is partly a realization of that 2015\nconcept.25.09.2023, 21:21 History - Internet Computer Wiki\nhttps://wiki.internetcomputer .org/wiki/History 2/3\n2018 DFINITY Foundation white paper describing\nits consensus system.Dominic's own work at DFINITY  also had many important antecedents. For example, he himself became interested in the idea of using\ncryptography to generate random numbers in a network and using them to drive consensus after reading the Random Oracles in\nConstantinople: Practical Asynchronous Byzantine Agreement using Cryptography  (https://allquantor .at/blockchainbib/pdf/cachin2000ra\nndom.pdf)  research paper , among others, in 2014. One of the authors of this paper , famous cryptographer and distributed computing\nscientist Victor Shoup  (https://www .shoup.net/) , later joined the DFINITY  Foundation  in 2021.\nEarly in 2015, Dominic's Threshold Relay  scheme was redesigned to use BLS threshold cryptography  (https://en.wikipedia.org/wiki/BLS\n_digital_signature)  to generate random numbers. This was thanks to a meeting with famous cryptographer Dan Boneh  (https://crypto.sta\nnford.edu/~dabo/)  at Stanford University , which was near to where he lived at the time in Palo Alto, California. Dan Boneh is the B in\n\"BLS,\" and later , early in 2017, the DFINITY  Foundation hired Ben L ynn (https://crypto.stanford.edu/~blynn/)  from Google, who was the\n\"L\".\nFor some years after Dominic began promoting his Threshold Relay system for producing random numbers in a decentralized setting, in\na way that is unmanipulable, unpredictable, and unstoppable, using BLS threshold cryptography , Vitalik Buterin raised concerns about\nthe safety of using BLS. A fun back and forth on the subject at a Silicon V alley Ethereum meetup  (https://youtu.be/h2pONw0eTTk?t=170\n7) in late 2016 reflects the congenial and collegiate back and forth that was characteristic in the community at the time. V italik eventually\nbecame convinced about the safety of BLS, and Ethereum 2.0 now relies on BLS.\nThe complexity of Dominic's early technical designs, and general disbelief about the viability of building a World Computer  blockchain,\nmade it hard for him to muster support for his ideas, and persuade the Ethereum community to work on implementations. However , in\n2016, Dominic was co-founder of a crypto incubator called String Labs. After a DeFi project to produce \"mirror assets\" was complicated\nby regulatory concerns, Dominic persuaded co-founder Tom Ding that String Labs should instead incubate DFINITY , and help it become\na standalone project. String Labs was primarily backed by Chinese venture capital, which also played a crucial early role in the early\nyears of the Ethereum ecosystem.\nAt this time, they were joined by Timo Hanke, the developer of AsicBoost  (https://decentralpost.com/asicboost/) , and the CT O of\nCoinT erra, from the Bitcoin community , and other people. Dominic decided to follow the fundraising example provided by Ethereum, and\ncreate a neutral not-for-profit foundation to drive development of a World Computer  blockchain protocol. Accordingly , the DFINITY\nFoundation was formed in Zug, Switzerland, with Dominic as President, in October 2016, later moving to Z\u00fcrich, Switzerland, when it\nestablished a large research center there.\nTo bootstrap the ecosystem, the ICP token  ledger was created using smart contracts on the Ethereum network in January 2017, which\nincluded allotments for early contributors, and an endowment for the DFINITY  Foundation. A seed donation was then run February\n2017, which allocated ICP  (then called DFN) to the public on behalf of the DFINITY  Foundation, to raise funding for its work.\nIn the February 2017 Seed donation round, ICP  was allocated to Seed donors in exchange for donations of bitcoin (BTC) and ether\n(ETH), which was marked-to-market, such that a contribution of 1 Swiss franc was rewarded by 30 ICP . This meant that hundreds of\nmembers of the public were allocated ICP  at approximately 3 cents each. Through this seed donation, the DFINITY  Foundation\nreceived $3.9 million in initial funding, although total cash receipts were greater , as the value of the ETH and BTC received increased\nsubstantially before it was sold by the foundation.\nThis initial funding allowed the foundation to begin expanding its operations. Notable early\ntechnical hires included Ben L ynn, and Andreas Rossberg  (https://people.mpi-sws.org/~ro\nssberg/) , also from Google, who was the co-inventor of WebAssembly . They were also\njoined by Artia Moghbel  (https://www .linkedin.com/in/artiam/)  heading up operations, who\npreviously worked for a VC that had invested into the MMO game Dominic had earlier\ndeveloped. By October 2017, Dominic was able to demonstrate an initial version of its test\nnetwork  (https://www .youtube.com/watch?v=aOzxxeOYJpY)  to the world, which included\nan implementation of Threshold Relay , and a basic version of Probabilistic Slot\nConsensus , together with a novel smart contract execution environment, and a smart\ncontract language derived from Haskell, for the first time.\nIn January 2018, DFINITY  published its first formal white paper describing its consensus\nsystem, although it had been described informally for some time. With this, and the test\nnetwork in hand, the DFINITY  Foundation decided to raise significant additional funds and\nscale-out its operations \u2014 since it the scope of the R&D work required to deliver a true\nWorld Computer  was substantially broader than originally anticipated.\nThe DFINITY  Foundation raised more than one hundred millions dollars in two fundraising\nrounds in 2018, the Strategic Round and the Presale Round. This enabled it to scale its\noperations more aggressively . The major challenge was building out an R&D organization\nthat could ef fectively combine blue sky computer science and cryptography research\nactivity , with engineering operations. In practice, this was a process that took many years,\nand many bumps on the road were passed en route to the organization as it is today .\nIn 2018, the DFINITY  Foundation's CT O (Chief Technology Of ficer), Jan Camenisch  (http\ns://jan.camenisch.org/) , a famous cryptographer , was hired from IBM, where he worked as a Principal Research Staf f Member . He\nbecame instrumental in building out the Z\u00fcrich research center . This included recruiting numerous well-known cryptographers to the\nWorld Computer  mission, whom he had often worked with before. Arguably , the DFINITY  Foundation employs more well-known and\nhighly respected cryptographers than any other organization in the tech industry . This is in sharp contrast to other blockchain projects,\nwhich often do not employ any cryptographers at all, preventing them developing custom cryptography to meet their needs.\nCollectively , DFINITY  Foundation cryptographers, researchers and engineers have published more than 1500 papers, collected more\nthan 88,000 citations, and have created more than 190 patents. As the Z\u00fcrich research center grew , it became the largest employer of\nex-Googlers in Switzerland, with many joining from Google Research. Across all research centers, including California, more than 20%\nof all staf f members joined from Google or IBM, and more than 20% are alumni of Z\u00fcrich ETH and EPFL. The DFINITY  Foundation has\na better balance of the sexes than most tech organizations, and 43% of department heads across the world are women.25.09.2023, 21:21 History - Internet Computer Wiki\nhttps://wiki.internetcomputer .org/wiki/History 3/3\n2021 Dfinity Foundation paper, non-interactive\ndistributed key generation and key resharing\n2022 DFINITY Foundation paper, \"The Internet\nComputer for Geeks\"To launch the Internet Computer , the R&D team had to implement protocols that would\nallow it to establish chain key cryptography  material on nodes in a decentralized network\nsetting. This was achieved using a groundbreaking non-interactive DKG ( distributed key\ngeneration ) and key re-sharing protocol, devised by Jens Groth  (http://www0.cs.ucl.ac.uk/\nstaff/j.groth/) , another famous cryptographer working at DFINITY . This works in\nconjunction with updated protocols, described in \"The Internet Computer for Geeks\"\npaper .\nThe scale of the technical challenges involved in creating a protocol that incorporated\nsuch advanced cryptography and protocol math was enormous, and was achieved only\nthrough the incredible ef forts of a large and highly dedicated team of cryptographers,\ncomputer science researchers and engineers. The Internet Computer also uses a\ncompletely novel blockchain architecture, which is necessary to deliver the World\nComputer  vision, and depends on many innovations in areas spanning its WebAssembly -\nbased smart contract execution environment to new computer languages such as Motoko .\nThe Internet Computer network is also adaptive, self-governing and self-updating, thanks\nto an advanced DAO called the Network Nervous System  that runs within its protocols. It\nrepresents an enormous technical achievement.\nThe Internet Computer runs on a sovereign network of special node machines , which is\ndedicated hardware. Before its May 2021 genesis event and production network launch, a\ncommunity of independent node providers  had to be established, who would purchase or\nbuild these machines, and run them from data centers around the world. This was\nbootstrapped by the DFINITY  Foundation.\nThe Internet Computer network underwent genesis May 2021, and transitioned into a\ndecentralized production mode. This will be seen as an momentously impactful event in\nthe history of tech and blockchain. Nonetheless, at launch, the Internet Computer project\nfaced a firestorm of attacks from other projects in the blockchain industry , who feared its\ncapabilities. The DFINITY  Foundation, which is primarily a research and development\norganization, was ill-equipped to deal with the attacks, and was substantially disrupted for\nsome time. The full scale of the attacks and corruption directed at the project is now\nslowly being exposed, including by investigative journalism ef forts such as\nhttps://cryptoleaks.info .\nThe attacks that were launched also substantially disrupted the markets for the Internet\nComputer network's ICP utility token, and led to misconceptions and disinformation about\nthe project becoming widespread. Thankfully , this situation is slowly clearing, and\nmoreover , it did little to dent developer interest in the project.\nThe Internet Computer community is fast growing and strong. There are now thousands of\ndevelopers building on the Internet Computer network, and thousands of web3 and other\nprojects running. Indeed, its developer community regularly clocks more \"GitHub\ncommits\" than any other in the blockchain industry . Projects running on the Internet\nComputer are unique in the blockchain industry , because they run entirely from the\nblockchain, without reliance on cloud computing and centralized traditional IT  to function,\nas is required with other blockchains. Smart contracts running on the Internet Computer\ncan create transactions on other blockchains, and its capabilities are now being used to\norchestrate multi-chain systems, and create user experiences and functionality for\nservices running on other chains .\nThe DFINITY  Foundation, and the fast growing Internet Computer community , are focused on building-out a new web3 internet\necosystem, and eventually moving the vast majority of online systems and services onto the Internet Computer , in a replacement of\ntraditional IT  that drives a blockchain singularity .",
  "How it works _ Internet Computer.pdf": "25.09.2023, 21:21 How it works | Internet Computer\nhttps://internetcomputer .org/how-it-works?source=nav 1/23Realizing the vision of the World\nComput er\nLearn how the Internet Computer blockchain realizes the vision of the World\nComputer. Dive into its technology, open-source repositories, in-depth video\nacademy sessions, white papers, publications, and detailed technology articles.\nArchitecture\nCore IC Protocol Chain-key technology Tokenomics & Governance Chain-evolution technology Smart c25.09.2023, 21:21 How it works | Internet Computer\nhttps://internetcomputer .org/how-it-works?source=nav 2/23Architecture of the Internet Computer\nThe Internet Computer (IC) realizes the vision of a World Computer \u2013 an open and\nsecure blockchain-based network that can host programs and data in the form of smart\ncontracts, perform computations on smart contracts in a secure and trustworthy way,\nand scale in\u0000nitely.\nSmart contracts on the Internet Computer are called canister smart contracts, or\ncanisters, each consisting of a bundle of WebAssembly (Wasm) bytecode and smart\ncontract data storage. Each canister has its own, isolated, data storage that is only\nchanged when the canister executes code.\nCanisters are hosted on subnets, the top-level architectural building block of the IC. A\nsubnet is an independent blockchain, runni ng on node machines, or nodes, deployed in\nglobally-distributed data centers. A single subnet can securely host tens of thousands of\ncanister smart contracts, totalling in hund reds of gigabytes of memory \u2013 there are\ncurrently dozens of subnets, growing to thousands in the future. For each canister\nhosted on a subnet, its code and data is stored on every node in the subnet, and its code\nis executed by every node in the subnet. This replication of storage and computation is\nessential to achieve fault tolerance, so that canister smart contracts will continue to\nexecute even if some nodes in the subnet are faulty (either because they crash, or even\nworse, are hacked by a malicious party). This replication is powered by the core Internet\nComputer Protocol (ICP), which implements a high-throughput, low-latency consensus\nmechanism and an e\u0000cient virtual machine for WebAssembly execution, backed by a\nblockchain.\nThe IC's multi-subnet architecture is much more powerful than the well-known sharding\napproach because it enables smart contracts on di\u0000erent subnets to communicate with\neach other seamlessly \u2013 much like services in a traditional microservices architecture,\nbut fully on chain. Canisters communicate via asynchronous messages, i.e., they don't\nblock on sending a message, but process the response when it eventually arrives. This\nnovel approach to inter-canister calls allows for scaling out the IC by simply adding more\nsubnets.\nThe core ICP makes heavy use of chain-key cryptography, a toolbox of advanced\ncryptographic protocols (based on threshold cryptography) that enables the\ndecentralized operation of the IC with unprecedented scalability. Chain-key\ncryptography also includes a sophisticated collection of technologies for robustly and\nsecurely addressing operational concerns, such as how to deal with faulty nodes or\nprotocol upgrades, which we call chain-evolution technology (for example, enabling\nnodes to easily join a subnet without validating every block beginning from the genesis\nCore IC Protocol Chain-key technology Tokenomics & Governance Chain-evolution technology Smart c25.09.2023, 21:21 How it works | Internet Computer\nhttps://internetcomputer .org/how-it-works?source=nav 3/23block, as in other blockchains). Another building block in the chain-key crypto toolbox\nare chain-key signatures. They enable a canister to interact with (write to) other\nblockchains using threshold cryptography.\nHaving scalable and decentralized technology to power the operation of the network is\nnot enough. In order to meet the requirements of complete decentralization, the IC\nneeds a fully decentralized approach to governance. Governance of the IC platform is\naccomplished through a tokenized Decentralized Autonomous Organization (DAO),\nwhich is called the Network Nervous System (NNS). Each individual dapp on the IC can\nhave its own governance system similar to the NNS by customizing and deploying an\nout-of-the-box tokenized DAO based on the Service Nervous System (SNS) for the dapp.\nThe Internet Computer was launched and open-sourced on May 10th 2021 by the\nDFINITY Foundation. The Internet Computer is now an independent network controlled\nby ICP token holders but DFINITY continues supporting its evolution.\nGo deeper\nCore IC Protocol\nCore IC Protocol Chain-key technology Tokenomics & Governance Chain-evolution technology Smart c25.09.2023, 21:21 How it works | Internet Computer\nhttps://internetcomputer .org/how-it-works?source=nav 4/23Overview\nThe Internet Computer is powered by the Internet Computer Protocol (ICP), from which\nits utility token, the ICP token, derives its name. The core part of the IC protocol, the\ncore IC protocol, is a 4-layer protocol that is runni ng on the nodes of each subnet. By\nrunni ng the core IC protocol, the nodes of a subnet realize a blockchain-based\nreplicated state machine that makes progress independently of the other subnets (but\ncommunicates asynchronously with them). This architecture of many concurrently-\noperating subnets enables the IC to scale practically without limits. Subnets process\nmessages, which are submitted by users or come from other subnets.\nThe core IC protocol comprises the following four layers, from bottom to top:\n\u0000\u0000\u0000Peer-to-peer\n\u0000\u0000\u0000Consensus\n\u0000\u0000\u0000Message routing\n\u0000\u0000\u0000Execution\nThe lower two layers, P2P and consensus, together implement a selection and ordering\nof incoming messages and provide messages to the upper two layers in the form of\nblocks. The upper two layers, message routing and execution, receive blocks containing\nordered messages from the lower part of the stack and execute them in a completely\ndeterministic manner on every node of the subnet. This realizes a replicated state\nmachine, where every node in the subnet transitions from the same starting state to the\nsame ending state in every round (it must be ensured that every node executes the same\nmessages in the same order, i.e., fully deterministically).\nGo deeper\nCore IC Protocol Chain-key technology Tokenomics & Governance Chain-evolution technology Smart c25.09.2023, 21:21 How it works | Internet Computer\nhttps://internetcomputer .org/how-it-works?source=nav 5/23\nPeer-to-peer\nThe peer-to-peer layer (P2P) of the Internet Computer, the bottommost layer in the\nprotocol stack, is responsible for the secure and reliable communication between the\nnodes of a subnet. The P2P layer realizes a virtual peer-to-peer broadcast network\nbetween the nodes of a subnet, building upon the Internet Protocol (IP) connectivity\nbetween the nodes. This makes the P2P layer the communications fabric that connects\nall the nodes of a subnet. Using P2P, a node can broadcast a network message, also\ncalled artifact, to all the nodes in the subnet. Artifacts can be things like input to\ncanisters submitted by users or protocol messages (e.g., block proposals) generated by\nthe IC protocol. P2P ensures that artifacts to be broadcast are eventually delivered to all\nnodes of the subnet. Eventual delivery re\u0000ects the asynchronous nature of real-world\ncommunication networks, which we assume for the Internet Computer protocol.\nGo deeper\nCore IC Protocol Chain-key technology Tokenomics & Governance Chain-evolution technology Smart c25.09.2023, 21:21 How it works | Internet Computer\nhttps://internetcomputer .org/how-it-works?source=nav 6/23\nConsensus\nEvery blockchain needs a consensus mechanism that allows the nodes to agree on the\nmessages to be processed, as well as their ordering. Consensus is the component of the\ncore IC protocol that drives the subnets of the IC. Each subnet is a blockchain that runs\nthe IC core protocol, including consensus, independently of the other subnets. The\npurpose of the consensus protocol is to output the same block of ordered messages on\neach node of a subnet in a given round so that each node can make the same state\ntransition when deterministically executing those messages.\nThe IC\u2019s consensus protocol is designed to meet the following requirements: low latency\n(almost instant \u0000nality); high throughput; robustness (graceful degradation of latency\nand throughput in the presence of node or network failures). The IC consensus protocol\nalso provides cryptographically guaranteed \u0000nality. This is in contrast to Bitcoin-like\nprotocols which only provides probabilistic \u0000nality, where a block is considered \u0000nal\nonce a su\u0000cient num ber of blocks have built on top of it in the blockchain.\nGo deeper\nCore IC Protocol Chain-key technology Tokenomics & Governance Chain-evolution technology Smart c25.09.2023, 21:21 How it works | Internet Computer\nhttps://internetcomputer .org/how-it-works?source=nav 7/23\nMessage routing\nIn every IC round, the message routing component receives a block of messages to be\nprocessed from consensus \u2013 the same block on each node of the subnet \u2013 and places\nthe messages into the input queues of their target canisters, a process called induction.\nThen, it triggers the execution round which will potentially lead to new canister\nmessages in the executed canisters' output queues. Once execution is done, the\nmessages in the output queues are routed by the message routing component to the\nrecipients.\nThe recipients may include canisters residing on a di\u0000erent subnet. The message routing\nlayer implements the routing of inter-canister messages between subnets, such that\nthose messages can be included in blocks and be inducted on the recipient's subnet.\nThis is referred to as cross-subnet messaging or simply XNet messaging. Secure XNet\nmessaging is a key ingredient for the architecture of loosely-coupled subnets and thus a\nprerequisite for the scalability of the IC.\nAnother crucial functionality implemented by the message routing layer is state\ncerti\u0000cation, that is, the subnet certifying parts of the replicated subnet state in every\nround in a decentralized manner. Among others, this certi\u0000cation is used by other\nsubnets to verify the authenticity of the subnet-to-subnet streams or to allow users to\nauthentically read the processing status of messages previously submitted by them.\nState certi\u0000cation and secure XNet messaging enable, among others, the secure and\ntransparent communication of canisters across subnet boundaries, a challenge that any\nblockchain that has multiple shards struggles with.\nGo deeper\nCore IC Protocol Chain-key technology Tokenomics & Governance Chain-evolution technology Smart c25.09.2023, 21:21 How it works | Internet Computer\nhttps://internetcomputer .org/how-it-works?source=nav 8/23\nExecution\nThe execution layer, the topmost layer of the core IC protocol stack, is responsible for\nexecuting canister smart contract code. Code execution is done by a WebAssembly\n(Wasm) virtual machine deployed on every node. WebAssembly bytecode can be\nexecuted deterministically, which is important for a blockchain system, and with near-\nnative speed. Canister messages, i.e., ingress messages by users or messages by other\ncanisters, have been inducted into the queues of the canisters on the subnet by message\nrouting. Message routing then hands over control to the execution layer, which\ndeterministically executes messages, either until all messages in the canisters' queues\nare consumed or the cycles limit for the round has been reached, to ensure bounded\nround times.\nThe execution layer has many unique features, which sets apart the IC from other\nblockchains:\n\u0000\u0000\u0000Deterministic time slicing (DTS) - The execution of very large messages requiring\nbillions of Wasm instructions to be executed can be split across multiple IC rounds.\nThis capability of executing messages over multiple rounds is unique to the Internet\nComputer blockchain.\n\u0000\u0000\u0000Concurrency - Execution of canister Wasm bytecode is done concurrently on multiple\nCPU cores, which is possible due to each canister having its own isolated state.\n\u0000\u0000\u0000Pseudorandom number generator - Execution layer has access to unpredictable and\nunbiasable pseudorandom number generator. Canisters can now execute algorithms\nCore IC Protocol Chain-key technology Tokenomics & Governance Chain-evolution technology Smart c25.09.2023, 21:21 How it works | Internet Computer\nhttps://internetcomputer .org/how-it-works?source=nav 9/23that require randomness.\nGo deeper\nChain-key cryptography\nThe Internet Computer protocol uses a toolbox of advanced cryptographic mechanisms,\ncollectively known as chain-key cryptography, which allows the IC to achieve\nfunctionalities and scalability that are impossible on other blockchains.\nA key component of chain-key cryptography is a threshold signature scheme, which is\nlike an ordinary digital signature scheme, except that the secret signing key is distributed\namong all the replicas in a subnet in such a way that the key cannot be stolen by\ncompromising one (or even a large fraction) of the replicas in the subnet. The technology\nhas many bene\u0000ts including:\n\u0000\u0000\u0000Anyone can verify the content received from the Internet Computer by simply\nvalidating a signature without syncing the entire blockchain.Chain-key technology\nCore IC Protocol Chain-key technology Tokenomics & Governance Chain-evolution technology Smart c25.09.2023, 21:21 How it works | Internet Computer\nhttps://internetcomputer .org/how-it-works?source=nav 10/23\u0000\u0000\u0000The topology of IC can evolve autonomously -- New nodes and subnets can be\nadded, faulty nodes can be recovered and protocol can be upgraded autonomously.\n\u0000\u0000\u0000A source of unpredictable and unbiasable pseudo-random numbers for canisters.\nCanisters can securely run algorithms that need randomness.\nGo deeper\nChain-key signatures\nChain-key signatures extends chain-key technology to allow transactions targeted at\nother blockchains to be computed fully on-chain using the Internet Computer Protocol.\nUsing chain-key signatures, the IC can integrate with other blockchains such as Bitcoin\nand Ethereum in a completely trustless manner without needing any bridges. Canisters\ncan now securely store and transact Bitcoin. The secret key of the Bitcoin is shared\nbetween all the nodes runni ng the canister. The canister can trasact Bitcoin using a\nchain-key signed transaction only when at least 2/3rd of the nodes agree to make the\ntransaction. Indeed, using chain-key signatures is the strongest, most decentralized way\nof integrating blockchains as no additional trust assumptions besides that of the two\nblockchains are required, particularly no additional parties that manage signature keys or\ntheir shares.\nGo deeper\nCore IC Protocol Chain-key technology Tokenomics & Governance Chain-evolution technology Smart c25.09.2023, 21:21 How it works | Internet Computer\nhttps://internetcomputer .org/how-it-works?source=nav 11/23\nBitcoin integration\nThe Bitcoin integration on the Internet Computer rests on two pillars: Chain-key\nsignatures and a direct interaction between Internet Computer nodes and the Bitcoin\npeer-to-peer network. While chain-key signatures make it possible for canisters to have\ntheir own Bitcoin addresses and create valid transactions spending bitcoins held by\nthese addresses, the direct message exchange between the Internet Computer and the\nBitcoin network serves to maintain information about the Bitcoin blockchain state, such\nas address balances, in the Internet Computer and to transmit Bitcoin transactions\noriginating from canisters to the Bitcoin network.\nGo deeper\nCore IC Protocol Chain-key technology Tokenomics & Governance Chain-evolution technology Smart c25.09.2023, 21:21 How it works | Internet Computer\nhttps://internetcomputer .org/how-it-works?source=nav 12/23\nChain-key tokens\nChain-key tokens \u2014 and Chain-Key Bitcoin (ckBTC) \u2014 are a cryptography-based\nreplacement to wrapped tokens with strong decentralization advantages: Chain-key\ntokens eliminate the risks associated with the traditional intermediary-based token\nwrapping, while also having the same bene\u0000t of making a token from another blockchain\navailable for transfers and trading. Chain-key cryptography makes this possible: Taking\nthe example of Bitcoin, a canister smart contract can own ECDSA key pairs and derive\nBitcoin addresses to which transfers of real Bitcoin can be made on the Bitcoin network.\nWhen receiving bitcoin, the canister mints and issues ckBTC in a 1:1 ratio to the sender of\nthe bitcoin. Conversely, redeeming ckBTC for the underlying bitcoin removes the ckBTC\nfrom circulating supply and refunds the bitcoin. This makes a chain-key token a \u2018twin\u2019 of\nthe original token with the same properties and valuation, but hosted on the Internet\nComputer.\nGo deeper\nTokenomics & Governance\nCore IC Protocol Chain-key technology Tokenomics & Governance Chain-evolution technology Smart c25.09.2023, 21:21 How it works | Internet Computer\nhttps://internetcomputer .org/how-it-works?source=nav 13/23\nTokenomics\nThe Internet Computer makes use of an utility token called ICP. The ICP token is used for\na variety of functions on the platform. Users can stake ICP giving them the right to vote\nand earn voting rewards. Investors can use ICP to participate in SNS swaps launched on\nthe Internet Computer, i.e., the initial o\u0000erings of the native DAOs. Developers use ICP\ntoken to purchase cycles to power their dapps on the Internet Computer. And node\nproviders are remunerated in ICP for the compute power they provide to the Internet\nComputer platform.\nGo deeper\nCore IC Protocol Chain-key technology Tokenomics & Governance Chain-evolution technology Smart c25.09.2023, 21:21 How it works | Internet Computer\nhttps://internetcomputer .org/how-it-works?source=nav 14/23\nNetwork Nervous System\nThe Internet Computer is a decentralized system run by many independent nodes. The\nNetwork Nervous System (NNS) coordinates their e\u0000ort by determining which subnet a\nnode belongs to (the topology), which protocol version they should run, and when they\nshould upgrade to a new protocol version.\nNNS decision making is done via an open tokenized governance system. The NNS is one\nof the largest decentralized autonomous organizations (DAOs). Anyone can become a\nparticipant of the NNS by staking ICP tokens and contribute to decisions.\nGo deeper\nCore IC Protocol Chain-key technology Tokenomics & Governance Chain-evolution technology Smart c25.09.2023, 21:21 How it works | Internet Computer\nhttps://internetcomputer .org/how-it-works?source=nav 15/23\nService Nervous System (SNS)\nSimilarly to how the Internet Computer is controlled by the Network Nervous System, a\ndecentralized application on the IC can be controlled by a community. The Internet\nComputer\u2019s built-in solution for a DAO (decentralized autonomous organization) that\ntokenizes and decentralizes a dapp is called the Service Nervous System (SNS). In the\nprocess of creating an SNS, new tokens are minted and sold in a community-based\nfundraising. The dapp\u2019s control is handed over to the SNS and everyone who has SNS\ntokens can contribute to decisions on how the dapp evolves going forward. This allows\ndistributing the power and ownership of the dapp over a numb er of parties, thereby\neliminating single points of failure and gaining censorship resistance. Moreover, the\nnewly created tokens can be used to create incentives to foster user adoption and\nparticipation.\nGo deeper\nChain-evolution technology\nCore IC Protocol Chain-key technology Tokenomics & Governance Chain-evolution technology Smart c25.09.2023, 21:21 How it works | Internet Computer\nhttps://internetcomputer .org/how-it-works?source=nav 16/23\nIn\u0000nite scalability\nThe Internet Computer scales its capacity horizontally by creating new subnets that host\nadditional canisters \u2014 just like traditional cloud infrastructure scales by adding new\nmachines. Once the IC's Network Nervous System (NNS) decided to create a new\nsubnet, it selects a group of spare nodes that have joined the IC but have not yet been\nallocated to any subnet and creates the initial con\u0000guration of the new subnet. The\nselected group of nodes then begins to form a new subnet blockchain.\nGo deeper\nCore IC Protocol Chain-key technology Tokenomics & Governance Chain-evolution technology Smart c25.09.2023, 21:21 How it works | Internet Computer\nhttps://internetcomputer .org/how-it-works?source=nav 17/23\nFault tolerance\nIn any large-scale distributed system, it is inevitable that individual nodes fail due to\nhardware breaking, network connectivity issues, or even the owner deciding to remove\nthe nodes from the network. In such cases, the IC's Network Nervous System selects a\nspare node that replaces the failed node in its subnet. The new node then joins the\nsubnet and performs a state synchronization with its existing nodes and begins\ncontributing to the subnet blockchain's consensus protocol.\nGo deeper\nCore IC Protocol Chain-key technology Tokenomics & Governance Chain-evolution technology Smart c25.09.2023, 21:21 How it works | Internet Computer\nhttps://internetcomputer .org/how-it-works?source=nav 18/23Protocol upgrade\nThe Internet Computer blockchain is governed by the Network Nervous System (NNS),\nits algorithmic governance system. One of the many duties of the NNS is to orchestrate\nupgrades of the Internet Computer to a new protocol version when the community has\nadopted an upgrade proposal. Making upgrades to any blockchain requires solutions to\nseveral challenging problems posed by the nature of decentralized systems including\nhow to allow arbitrary changes to the protocol, preserve state of all canister smart\ncontracts, minimize downtime, and roll out upgrades autonomously.\nGo deeper\nCanisters\nSmart contracts on the Internet Computer come in the form of canisters: computational\nunits that bundle together code and state. Each canister de\u0000nes functions that can be\ncalled by other canisters and parties external to the IC, such as browsers or mobile apps.\nCanisters communicate with one another via asynchronous messages but the executionSmart contracts\nCore IC Protocol Chain-key technology Tokenomics & Governance Chain-evolution technology Smart c25.09.2023, 21:21 How it works | Internet Computer\nhttps://internetcomputer .org/how-it-works?source=nav 19/23of each such message is done in complete isolation, allowing for massive levels of\nconcurrent execution. Canisters are managed by controllers. Control structure of\ncanisters could be centralized (e.g. when the controllers include some centralized\nentity), decentralized (when the controller is a DAO) or even non-existent, in which case\nthe canister is an immutable smart contract. Controllers are the only entities which can\ndeploy the canister to the Internet Computer, start/stop their execution and update their\ncode. The controllers also need to ensure that canisters hold su\u0000cient cycles. These are\nthe unit used on the IC to acquire resources for canister execution (memory, network\nbandwidth and computational power). To this end the IC monitors the resource usage of\ncanisters and deducts their cost from a cycle balance maintained locally by each\ncanister.\nGo deeper\nMotoko\nMotoko is a new programming language for smart contracts. It is designed to seamlessly\nsupport the programming model of the Internet Computer and makes it easier to take\nadvantage of the unique features of the blockchain. Motoko is strongly typed, actor-\nbased, and has built-in support for orthogonal persistence and asynchronous message\npassing. Productivity and safety features include automatic memory management,\ngenerics, type inference, pattern matching, and both arbitrary- and \u0000xed-precision\narithmetic. Messaging transparently employs the Internet Computer\u2019s Candid interface\nde\u0000nition language and wire format for typed, high-level, and cross-language\ninteroperability.\nCore IC Protocol Chain-key technology Tokenomics & Governance Chain-evolution technology Smart c25.09.2023, 21:21 How it works | Internet Computer\nhttps://internetcomputer .org/how-it-works?source=nav 20/23Go deeper\nCerti\u0000ed variables\nCanister smart contracts can declare variables as certi\u0000ed. Whenever set, these\nvariables will automatically get a Merkle tree certi\u0000cate, signed by the Internet\nComputer blockchain. This allows anyone to verify the authenticity of this type of data\nusing the Internet Computer's public key.\nGo deeper\nWeb access\nCore IC Protocol Chain-key technology Tokenomics & Governance Chain-evolution technology Smart c25.09.2023, 21:21 How it works | Internet Computer\nhttps://internetcomputer .org/how-it-works?source=nav 21/23\nSmart Contracts serve the web\nThe Internet Computer is the only blockchain that can host a full dapp \u2013 frontend,\nbackend and data. This is a crucial and distinguishing feature allowing dapps to run 100%\non-chain inheriting the security and decentralization of blockchain without sacri\u0000cing\nspeed or a\u0000ordability. This is possible because the IC can securely serve HTTP requests.\nGo deeper\nCore IC Protocol Chain-key technology Tokenomics & Governance Chain-evolution technology Smart c25.09.2023, 21:21 How it works | Internet Computer\nhttps://internetcomputer .org/how-it-works?source=nav 22/23Asset certi\u0000cation\nAssets are served from the Internet Computer in a tamper-proof way using certi\u0000cation:\nEach asset is accompanied by a certi\u0000cate, which is signed by the entire subnet allowing\nthe user to verify that a response is correct and authentic even when communicating\nwith a malicious node.\nGo deeper\nBoundary nodes\nThe boundary nodes are the gateway to the Internet Computer and enable seamless\naccess to the canister smart contracts with stock browsers. They provide an HTTP\nendpoint and translate all incoming user requests to API canister calls, which are\nprocessed on-chain. In addition, the boundary nodes act as a cache to improve the\nperformance of the dapps hosted on the Internet Computer.\nGo deeper\nCore IC Protocol Chain-key technology Tokenomics & Governance Chain-evolution technology Smart c25.09.2023, 21:21 How it works | Internet Computer\nhttps://internetcomputer .org/how-it-works?source=nav 23/23\nInternet Identity\nThe main means of identity and authentication used on the web are usernames and\npasswords, which are hard to manage and well-known for their security vulnerabilities.\nTo solve these pitfalls, the Internet Computer blockchain pioneered a more advanced\nand much more secure method of cryptographic authentication, known as Internet\nIdentity, which is more convenient to use, works across all of a user's devices, and helps\nto protect user privacy.\nInternet Identity is a gateway to applications on the Internet Computer. When you use\nInternet Identity, websites cannot collect and share information about your online\nactivity. This is because Internet Identity helps you create and manage anonymous,\nindependent accounts for every website so that you get the privacy of having many\ndi\u0000erent accounts without the burden of managing them.\nGo deeper\nCore IC Protocol Chain-key technology Tokenomics & Governance Chain-evolution technology Smart c",
  "Infinite scalability _ Internet Computer.pdf": "25.09.2023, 21:23 Infinite scalability | Internet Computer\nhttps://internetcomputer .org/how-it-works/scalability/ 1/3\nIn\u0000nite scalability\nEver wondered about the meaning behind DFINITY? It\u2019s Decentralized + In\u0000nity. It\u2019s named that\nway because the Internet Computer is designed to scale in\u0000nitely. It means that the Internet\nComputer can host an unlimited num ber of canisters (smart contracts), store an unlimited\namount of memory, process an unlimited amount of transactions per second. In simple words,\nInternet Computer is designed to host even large scale social media platforms in a fully\ndecentralized way.\nThere are two types of widely-used approaches to improve the scalability of a system: (1)\nVertical Scaling, and (2) Horizontal Scaling. Vertical scaling means adding more CPU, RAM and\ndisk to a single computer. Horizontal scaling means adding more computers to the system.\nThere is a limit to vertical scaling. But with horizontal scaling, one can achieve unlimited\nscalability. Internet Computer is one of the \u0000rst blockchains to successfully use horizontal\nscaling.\nThe nodes in the Internet Computer are divided into subnets, each containing a few dozen\nnodes. The set of nodes in a subnet together maintain one blockchain. Each subnet can host\nthousands of canisters and process messages received by those canisters. Each subnet has a\nlimited capacity in terms of the num ber of canisters (a few thousand), amount of storage\n(hund reds of GBs), and bandwidth (a few hund red transactions per second). But as more subnets\nare added to the Internet Computer, its overall capacity increases proportionately. There is no\nlimit on the num ber of subnets that can be added.\nAnother crucial design aspect that is a prerequisite for limitless scaling is the inter-subnet\ncommunication of canisters: A canister of a subnet can send asynchronous messages to any\ncanister on any other subnet. XNet messages are ingested by the receiving subnet's consensus\nlayer and their integrity is validated based on the sending subnet's threshold signature \u2014\nanother application of chain-key cryptography. This architecture of XNet messaging leads to a\n\"loose coupling\" of the subnets that does not require a central component such as a shard chain\nas used in other blockchains with multiple \"shards\" that would create a bottleneck when scaling\nout. Therefore newly added subnets can immediately send and receive XNet messages to any\nother subnet and an increasing numb er of subnets does not hit a natural bottleneck as in other,\nmore simplistic, architectures.How it works In\u0000n ite scalability\n25.09.2023, 21:23 Infinite scalability | Internet Computer\nhttps://internetcomputer .org/how-it-works/scalability/ 2/3\nThe Internet Computer is divided into subnets. Each subnet hosts many canisters. One of the\nsubnets hosts Network Nervous System canisters.\nCreating a new subnet has two steps. (1) Adding new nodes to the Internet Computer, and (2)\nCreating a subnet with the available nodes Anyone can purchase the node hardware and add it\nto the Internet Computer by following the node provider onboarding process.\nWe now describe how to create a new subnet with the available nodes. The Internet Computer\nhas a decentralized governance system called Network Nervous System (NNS). Essentially, the\nNNS consists of a group of canisters that manage the Internet Computer. In the NNS, there is a\ncomponent called \u201cregistry\u201d, which stores the full con\u0000guration of the Internet Computer. The\nregistry has a record for each subnet which includes a protocol version, the list of nodes in the\nsubnet, protocol con\u0000guration parameters, etc.\n25.09.2023, 21:23 Infinite scalability | Internet Computer\nhttps://internetcomputer .org/how-it-works/scalability/ 3/3Proposal to create a new subnet. The status of all proposals can be viewed on the [IC Dashboard]\n(https://dashboard.internetcomputer.org/governance).\nTo add a new subnet, one has to submit a proposal to the NNS to add a record for a new subnet\nto the registry. The proposal consists of the list of nodes to be included in the new subnet. The\nproposal can be voted on by anyone who staked their ICP tokens. If a majority of voters accept\nthe proposal, then the registry canister instructs the NNS subnet to generate \u2014 in a fully\ndecentralized way using chain-key cryptography \u2014 the cryptographic key material to be used\nby the new subnet and a catch up package containing the genesis block. The registry canister\nthen adds a record containing the con\u0000guration of the subnet.\nWe now describe how a new subnet is created after a record is added to the registry. Each node\nruns 2 processes, the (1) Replica and the (2) Orchestrator. The replica consists of the 4-layer\nsoftware stack that maintains the blockchain. The orchestrator downloads and manages the\nreplica software. When a new node is onboarded, the node provider has to install IC OS on the\nnode, which contains the orchestrator software. The orchestrator regularly queries the NNS\nregistry for any updates. If the orchestrator sees that the node is included in a registry record,\nthen the orchestrator downloads the corresponding replica software, and runs the replica with\nthe Catch Up Package included in the registry as input. The replica then starts accepting\nmessages and the consensus protocol extends the genesis block present in the catch up\npackage.",
  "Internet Computer Consensus _ Internet Computer.pdf": "25.09.2023, 21:21 Internet Computer Consensus | Internet Computer\nhttps://internetcomputer .org/how-it-works/consensus/ 1/6\nConsensus\nEach subnet of the IC is its own blockchain that makes progress concurrently to the other\nsubnets: it runs its own instance of the IC core protocol stack, including consensus. Recall that\nthe goal of consensus is to produce blocks agreed upon by the nodes of the subnet, which yields\nan ordered sequence of messages to be executed. This is crucial so that the upper two layers of\nthe protocol stack \u2013 message routing and execution \u2013 receive the same inputs in every round on\neach node.\nThe IC\u2019s consensus protocol is designed to meet the following requirements: low latency (almost\ninstant \u0000nality); high throughput; robustness (graceful degradation of latency and throughput in\nthe presence of node or network failures). The IC consensus protocol achieves these goals by\nleveraging chain-key cryptography.\nThe IC consensus protocol provides cryptographically guaranteed \u0000nality. The option of\nchoosing probabilistic \u0000nality \u2013 similar to what is done in Bitcoin-like protocols, by considering\na block \u0000nal once a su\u0000cient num ber of blocks have built on top of it in the blockchain \u2013 is not\nacceptable for the IC for two reasons: (1) probabilistic \u0000nality is a very weak notion of \u0000nality and\n(2) probabilistic \u0000nality would increase the time to \u0000nality drastically.\nThe IC consensus protocol achieves all of these goals making only minimal assumptions about\nthe communication network. In particular, it does not assume any bounds on the time it takes for\nprotocol messages to be delivered \u2013 that is, it only assumes an asynchr onous network rather\nthan a synchr onous network. Indeed, for a decentralized network that is globally distributed,\nsynchr ony is simply not a realistic assumption. While it is possible to design consensus protocols\nthat work in a purely asynchr onous setting, these protocols generally have very poor latency. In\norder to achieve good latency, the IC consensus protocol requires protocol messages to be\ndelivered in a timely manner to make progress. However, the correctness of the protocol is\nalways guaranteed, regardless of message delays, so long as less than a third of the nodes in the\nsubnet are faulty.How it works Internet Computer Consensus\n25.09.2023, 21:21 Internet Computer Consensus | Internet Computer\nhttps://internetcomputer .org/how-it-works/consensus/ 2/6\nThe consensus protocol maintains a tree of notarized blocks (with a special origin block at the\nroot). The protocol proceeds in rounds. In each round, at least one notarized block is added to\nthe tree as a child of a notarized block that was added in the previous round. When things go\nright, there will be only one notarized block added to the tree in that round, and that block will\nbe marked as \u0000nalized. Moreover, once a block is marked as \u0000nalized in this way, all ancestors\nof that block in the tree of notarized blocks are implicitly \u0000nalized. The protocol guarantees that\nthere is always a unique chain of \u0000nalized blocks in the tree of notarized blocks. This chain of\n\u0000nalized blocks is the output of consensus.\nAt a high level, a consensus round has the following three phases:\nBlock making: In every round, at least one node, called a block maker, proposes a block by\nbroadcasting it to all nodes in the subnet using P2P. As we will see, when things go right,\nthere is only one block maker, but sometimes there may be several.\nNotarization: For a block to become notarized, at least two thirds of the nodes must validate\nthe node and support its notarization.\nFinalization: For a block to become \u0000nalized, at least two thirds of the nodes must support its\n\u0000nalization. As we will see, a node will support the \u0000nalization of a block only if it did not\nsupport the notarization of any other block, and this simple rule guarantees that if a block is\n\u0000nalized in a given round, then there can be no other notarized block in that round.\nLet us next look at the di\u0000erent phases of a consensus round in more detail.25.09.2023, 21:21 Internet Computer Consensus | Internet Computer\nhttps://internetcomputer .org/how-it-works/consensus/ 3/6Bloc k M aking\nA block maker is a node that proposes a block for the current round. As explained below, a\ncryptographic mechanism called a random beacon is used to select one node (chosen at\nrandom) as the primary block maker (or leader) for the current round. The primary block maker\nassembles a block consisting of the ingress messages (submitted directly to the node or\nreceived from other nodes in the subnet via P2P) and XNet messages (sent to this subnet from\nother subnets). After assembling a block, the primary block maker proposes this block by\nbroadcasting it to all nodes in the subnet using P2P.\nIf the network is slow or the primary block maker is faulty, the block proposed by the primary\nblock maker may not get notarized within a reasonable time. In this case, after some delay, and\nusing the same random beacon mechanism, other block makers are chosen to step in and\nsupplant the primary block maker. The protocol logic guarantees that one block eventually gets\nnotarized in the current round.\nThe block makers for a round are chosen through a random permutation of the nodes of the\nsubnet based on randomness derived from a random beacon. As discussed in the section on\nchain-key cryptography, chain-key cryptography may be used to produce unpredictable and\nunbiasable pseudo-random num bers. Consensus uses these pseudo-random numbers to de\u0000ne\na pseudo-random permutation on the nodes of the subnet. This assigns a rank to each node in\nthe subnet. The lowest-rank node in the subnet acts as the primary block maker. As time goes by\nwithout producing a notarized block, nodes of increasing rank gradually step in to supplant the\n(potentially faulty) nodes of lower rank as block maker.\nIn the scenario where the primary block maker is not faulty, and protocol messages get\ndelivered in a timely manner, only the primary block maker will propose a block, and this block\nwill quickly become notarized and \u0000nalized.25.09.2023, 21:21 Internet Computer Consensus | Internet Computer\nhttps://internetcomputer .org/how-it-works/consensus/ 4/6\nNotarization\nWhen a node receives a block proposed by a block maker for the round, it validates the block for\nsyntactic correctness. If the block passes this validity check, the node supports the notarization\nof the block by broadcasting a notarization sha re for the block to all nodes in the subnet. A\nnotarization share is a signature share computed using the BLS multi-signature scheme. A block\nbecomes notarized when at least two thirds of the nodes in the subnet support its notarization.\nIn this case, the BLS multi-signature shares may be aggregated to form a compact notarization\nfor the block.\nIn the case where the block proposed by the primary block maker gets notarized within a certain\namount of time, a node will not support the notarization of any other block in that round.\nOtherwise, a node may eventually support the notarization of blocks proposed by other block\nmakers of higher rank (but if it has already supported the notarization of a block proposed by a\nblock maker of some rank, it will not support the notarization of blocks proposed by block\nmakers of higher rank).25.09.2023, 21:21 Internet Computer Consensus | Internet Computer\nhttps://internetcomputer .org/how-it-works/consensus/ 5/6\nNotarization support of increasing-rank block proposals in a round\nFinalization\nIn a given round, the logic of the protocol guarantees that a node will always obtain a notarized\nblock (assuming less than a third of the nodes in the subnet are faulty). Once it obtains a\nnotarized block, the node will not subsequently support the notarization of any other block.\nMoreover, if the node did not previously support the notarization of any other block, the node\nwill also support the \u0000nalization of this block. It supports the \u0000nalization of this block by\nbroadcasting a \u0000nalization sha re for the block to all nodes in the subnet. A \u0000nalization share is a\nsignature share computed using the BLS multi-signature scheme. A block becomes \u0000nalized\nwhen at least two thirds of the nodes in the subnet support its \u0000nalization. In this case, the BLS\nmulti-signature shares may be aggregated to form a compact \u0000nalization for the block.\nGo E ven De eper\nAchieving Consensus on the Internet Computer\nConsensus W hite Paper\nExtended Abs tract published at POD C'22\nConsensus on the IC wiki25.09.2023, 21:21 Internet Computer Consensus | Internet Computer\nhttps://internetcomputer .org/how-it-works/consensus/ 6/6\n",
  "Internet Computer Execution Layer _ Internet Computer.pdf": "25.09.2023, 21:21 Internet Computer Execution Layer | Internet Computer\nhttps://internetcomputer .org/how-it-works/execution-layer/ 1/6\nExecution\nThe execution layer is the topmost layer of the IC core protocol stack. It deterministically\nschedules and executes the messages that have been agreed on by consensus and inducted into\nthe canister queues by message routing, thereby changing the state of the subnet in a\ndeterministic manner on all the nodes. The execution of the same sequence of messages on\nevery node of the subnet guarantees that the same ending state is obtained on each node of the\nsubnet after completion of the round.\nA canister smart contract on the IC consists of a Web Assembly (Wasm) bytecode representing\nthe smart contract program and a set of memory pages representing its state. The Wasm\nbytecode can be modi\u0000ed by installing or updating the canister. The smart contract state gets\nmodi\u0000ed when executing messages on the canister smart contract. Both the bytecode and the\nmemory pages, i.e., the state, of the canister, are maintained by every node machine of the\nsubnet the canister is installed on. Each node in the subnet holding the same canister state and\nensuring that the state transitions in the same way on every node in every round is the\nfoundation of realizing a replicated state machine and the security and resilience properties\nthereof that make blockchains so unique.\nReplicated M essage ExecutionHow it works Internet Computer Execution Layer\n25.09.2023, 21:21 Internet Computer Execution Layer | Internet Computer\nhttps://internetcomputer .org/how-it-works/execution-layer/ 2/6Replicated execution proceeds in rounds. In one IC round, the message routing layer invokes the\nexecution layer once for executing (a subset of) the messages in the canister input queues.\nDepending on how much e\u0000ort (CPU cycles) the execution of the messages of a round requires,\na round ends with all messages in the queues being executed or the cycles limit of the round\nbeing reached and parts of the messages left to future rounds for execution.\nEach message execution can lead to memory pages of the canister's state being modi\u0000ed\n(becoming \"dirty\" in operating systems terminology), new messages to other canisters on the\nsame or di\u0000erent subnets being created, or a response to be generated in case of an ingress\nmessage. Changes to memory pages are tracked and corresponding pages \u0000agged as \"dirty\" so\nthat they can be processed when certifying the state.\nWhen a message execution leads to the generation of a new canister message targeted at a\ncanister in the local subnet, this message can be queued up directly by execution in the input\nqueue of the target canister and scheduled in the same round or an upcoming round. This\nmessage does not need to go through consensus since the generation and enqueuing of the new\nmessage is completely deterministic and thus happens in exactly the same way on all the nodes\nof the subnet.\nNew messages targeted at other subnets are placed into the target cross-subnet queue (XNet\nqueue) and are certi\u0000ed by the subnet at the end of the round as part of the per-round state\ncerti\u0000cation. The receiving subnet can verify that the XNet messages are authenticated by the\nsubnet by validating the signature with the originating subnet's public key.\nThe execution layer is designed at its core to execute multiple canisters concurrently on\ndi\u0000erent CPU cores. This is possible because each canister has its own isolated state and\ncanister communication is asynchronous. This form of concurrent execution within a subnet\ntogether with the capability of all of the IC's subnets executing canisters concurrently makes the\nIC scalable like the public cloud: The IC scales out by adding more subnets.\n25.09.2023, 21:21 Internet Computer Execution Layer | Internet Computer\nhttps://internetcomputer .org/how-it-works/execution-layer/ 3/6Non -replicated M essage Execution\nNon-replicated message execution, aka queries, are operations executed by a single node and\nreturn a response synchronously, much like a regular function invocation in an imperative\nprogramming language. The key di\u0000erence to messages, which are also called update calls, is\nthat queries cannot change the replicated state of the subnet, while update calls can. Queries\nare, as the name suggests, essentially read operations performed on one replica of the subnet,\nwith the associated trust model of a compromised replica being able to return any arbitrary\nresult of its choice.\nAnalogous to update calls, queries are executed concurrently by multiple threads on a node.\nHowever, all the nodes of the subnet can concurrently execute di\u0000erent queries because queries\nare not executed in a replicated way. Query throughput of a subnet thus increases linearly with\nan increasing num ber of nodes in the subnet, while the update call performance decreases with\nan increasing num ber of nodes.\nQueries are similar to read operations on a local or cloud Ethereum node on the Ethereum\nblockchain. A dApp should use queries for non-critical operations only. Whenever an\ninformation item to be read is critical, e.g., \u0000nancial data based on which decisions are made,\nupdate calls should be used to obtain such information as the response of an update call is\ncerti\u0000ed by the subnet with a BLS threshold signature and veri\u0000able with the subnet's public key.\nDe termi nistic Time Slicing\nEach execution round progresses alongside the creation of blockchain blocks, which happens\nroughly once every second. This restricts how much computation can be performed in a single\nround, with the current limit being around 2 billion instructions given the existing node\nhardware.\nHowever, the Internet Computer can handle longer tasks that need up to 20 billion instructions,\nand some special tasks, like code installation, can even go up to 200 billion instructions. This is\nacheived using a technique called \"Deterministic Time Slicing\" (DTS). The idea is to pause a\nlengthy task at the end of one round and continue it in the next. As a result, a task can span\nmultiple rounds without slowing down the block creation rate. DTS is automatic and transparent\nto smart contracts, so developers don't need to write any special code to use it.\nM emory  Handling25.09.2023, 21:21 Internet Computer Execution Layer | Internet Computer\nhttps://internetcomputer .org/how-it-works/execution-layer/ 4/6Management of the canister bytecode and state (collectively memory) is one of the key\nresponsibilities of the execution layer. The replicated state that can be held by a single subnet is\nnot bounded by the available RAM in the node machines, but rather by the available SSD\nstorage. Available RAM, however, impacts the performance of the subnet, particularly the\naccess latency of memory pages. This depends a lot on the access patterns of the workload,\nhowever, \u2013 much like in traditional computer systems.\nThe node machines that comprise the IC are equipped with tens of terabytes of high-end SSD\nstorage and over half a terabyte of RAM to be able to hold large amounts of replicated canister\nstate and Wasm code and achieve good performance when accessing memory. The states\nobtained while executing canisters are certi\u0000ed (i.e. digitally signed) by the state management\ncomponent of message routing. Certi\u0000cation of some parts of the states, including the ingress\nhistory and the messages that are sent to other subnetworks are certi\u0000ed every round. The\nentire state of a subnetwork, including the state of all canisters hosted by that subnetwork is\ncerti\u0000ed once every (much longer) checkpointing interval.\nMemory pages representing canister state are persisted to SSD by the execution layer, without\ncanister programmers needing to take care of this. Having all memory pages transparently\npersisted enables ortho gonal persistence and frees the smart contract programmers from\nreading from and writing to storage as on other blockchains or as in traditional IT systems. This\ndramatically simpli\u0000es smart contract implementation and helps reduce the TCO of a dApp and\ngo to market faster. Programmers can always have the full canister smart contract state on the\nheap or in stable memory. The di\u0000erence is that the heap is cleared on updates of the canister\ncode, while stable memory remains stable throughout updates, hence its name. Any state on the\nheap that is to be preserved through a canister update must be transferred to stable memory by\na canister programmer before an update and restored from there after the update. Best\npractices are that large canister state be held directly in stable memory to avoid shu\u0000ing around\nlarge amounts of storage before and after each upgrade. This also avoids the risk of exceeding\nthe cycles limit allowed in an upgrade operation.\nCycles Accou nting\nThe execution of a canister consumes resources of the Internet Computer, which are paid for\nwith cycles. Each canister holds a local cycles account and ensuring that the account holds\nsu\u0000cient cycles is the responsibility of its maintainer, which can be a developer, a group of\ndevelopers or a decentralized autonomous organization (DAO) \u2013 users do never pay for sending\nmessages to canisters on the IC. This resource charging model is known as reverse gas model\nand is a facilitator for mass adoption of the IC.25.09.2023, 21:21 Internet Computer Execution Layer | Internet Computer\nhttps://internetcomputer .org/how-it-works/execution-layer/ 5/6Technically, the Wasm code runni ng in a canister gets instrumented, when the Wasm bytecode\nis installed or updated on the IC, with code that counts the executed instructions for smart\ncontract messages. This allows for deterministically determining the exact amount of cycles to\nbe charged for a given message being executed. Using Wasm as bytecode format for canister\nhas helped greatly to reach determinism as Wasm itself is a format that is largely deterministic in\nits execution. It is crucial that the cycles charging be completely deterministic so that every\nnode charges exactly the same amount of cycles for a given operation and that the replicated\nstate machine properties of the subnet are maintained.\nThe memory the canister uses in terms of both its Wasm code and canister state needs to be\npaid for with cycles as well. Much like in the public cloud, consumed storage is charged for per\ntime unit. Compared to other blockchains, it is very inexpensive to store data on the IC.\nFurthermore, networking activities such as receiving ingress messages, sending XNet messages,\nand making HTTPS Outcalls to Web 2.0 servers are paid for in cycles by the canister.\nPricing for a resource on the IC is extremely competitive. Prices for a given resource, e.g.,\nexecuting Wasm instructions, scale with the replication factor of the subnet, i.e., the number of\nnodes that power the subnet.\nRandom Numbe r Generation\nMany applications bene\u0000t from, or require a secure random numb er generator. Yet, generating\nrandom num bers in the na\u00efve way as part of execution trivially destroys determinism as every\nnode would compute di\u0000erent randomness. The IC solves this problem by the execution layer25.09.2023, 21:21 Internet Computer Execution Layer | Internet Computer\nhttps://internetcomputer .org/how-it-works/execution-layer/ 6/6having access to a decentralised pseudorandom numb er generator called the random tape. The\nrandom tape is built using chain-key cryptography. Every round, the subnetwork produces a\nfresh threshold BLS signature which, by its very nature, is unpredictable and uniformly\ndistributed. This signature can then be used as seed in a cryptographic pseudorandom\ngenerator. This gives canister smart contracts access to a highly-e\u0000cient and secure random\nnum ber source, which is another unique feature of the Internet Computer.",
  "Internet Identity_ Anonymizing Blockchain Authentication System _ Internet Computer.pdf": "25.09.2023, 21:24 Internet Identity: Anonymizing Blockchain Authentication System | Internet Computer\nhttps://internetcomputer .org/how-it-works/web-authentication-identity/ 1/6\nInternet Identity\nInternet Identity is a privacy-enhancing blockchain based authentication framework to built on\nthe Internet Computer. It integrates with the APIs of WebAuthn, a widely used, secure\nauthentication framework supported by modern browsers and operating systems. Users can\nconnect passkeys to their Internet Identity, and use the secure TPM chip inside these devices for\nauthentication instead of passwords or clunky 2FAs. Alternatively, Internet Identity supports\ndevices like YubiKeys or Ledger hardware wallets.\nPrivacy\nUsing chain-key cryptography, Internet Identity ensures private authentication by creating a\nunique principal id for each dapp the user authenticates with. This prevents the tracking of users\nacross dapps, making each session private.\nCreate an Intern et Identity\nIf you don't yet have an Internet Identity, you can create one at https://identity.ic0.app/.How it works Internet Identity: Anonymizing Blockchain Authentication System\n25.09.2023, 21:24 Internet Identity: Anonymizing Blockchain Authentication System | Internet Computer\nhttps://internetcomputer .org/how-it-works/web-authentication-identity/ 2/6\nIf you click \"Create Internet Identity\", you are asked to create a passkey. A passkey can be any\ndevice that has a TPM chip inside it, such as a laptop with a \u0000ngerprint sensor, a smartphone\nwith face ID. Alternatively, Internet Identity supports portable HSMs, such as YubiKeys or\nLedger devices.25.09.2023, 21:24 Internet Identity: Anonymizing Blockchain Authentication System | Internet Computer\nhttps://internetcomputer .org/how-it-works/web-authentication-identity/ 3/6\nAfter the Internet Identity is created, users can already use it to securely and privately\nauthenticate with ICP based dapps, or add more passkeys. It is generally advised to have\nmultiple passkeys connected to your Internet Identity as well as a recovery method setup, such\nas a recovery phrase.25.09.2023, 21:24 Internet Identity: Anonymizing Blockchain Authentication System | Internet Computer\nhttps://internetcomputer .org/how-it-works/web-authentication-identity/ 4/6\nOnce you added a passkey, you will be assigned an Internet Identity numb er. You should save\nsomewhere safe, where you can easily access it. While your browser remembers this number, it\nwill forget it if its cache is cleared, in which case you will need to type it in manually.25.09.2023, 21:24 Internet Identity: Anonymizing Blockchain Authentication System | Internet Computer\nhttps://internetcomputer .org/how-it-works/web-authentication-identity/ 5/6\nAs mentioned previously, it is also important to add a recovery phrase in case your device gets\nlost or stolen. Your Internet Identity also allows you to login to the Network Nervous System\n(NNS) dapp. NNS is the DAO that governs the Internet Computer, and allows ICP token holders\nto participate in its governance by staking their tokens.\nInternet Identity App\nInternet Identity W iki\nInternet Identity Speci\u0000cation\nOpe n Source - Internet Identity\nW eb Authentication and Identity on the Internet Computer\nInternet Identity: Easy W eb3 Authentication\nVerifying the Internet Identity Code: A W alkthrough25.09.2023, 21:24 Internet Identity: Anonymizing Blockchain Authentication System | Internet Computer\nhttps://internetcomputer .org/how-it-works/web-authentication-identity/ 6/6IC internals: Internet Identity storage\n",
  "Message Routing _ Internet Computer.pdf": "25.09.2023, 21:21 Message Routing | Internet Computer\nhttps://internetcomputer .org/how-it-works/message-routing/ 1/7\nMessage Routing\nThe Internet Computer blockchain enables users to send messages to canister smart contracts\nand canisters to send messages between themselves. For scalability, the Internet Computer is\ncomposed of many subnet blockchains and the Internet Computer's Network Nervous System\ncan add new subnets as required. The message routing component routes messages to and from\ncanisters across all of the Internet Computer's subnet blockchains and ensures that new subnets\ncan be added seamlessly.\nMessage routing is the lower of the two upper layers of the protocol stack. It implements\nfunctionality that is crucial for the operation of the IC. Its responsibilities can be roughly grouped\nas follows:\nInduction of messages received in blocks from consensus;\nInvocation of the execution layer after successful induction;\nRouting of inter-canister messages resulting from execution within and between subnets;\nCerti\u0000cation of the state of the subnet;\nSynchronization of the state of the subnet to newly joining and fallen behind nodes.\nNote that, although the layer derives its name from the functionality of routing messages, all the\nfunctionality listed above is equally important for the IC. Particularly, state certi\u0000cation and\nsynchronization are heavily used in chain-evolution technology to enable resumption of nodes.\nMessage Processing\nWhenever consensus produces a \u0000nalized block of messages, that is, a block that has been\nconsidered correct (notarized) and \u0000nalized by at least two thirds of the subnet's nodes, this\nblock is handed over to message routing. This marks the transition between the lower and upper\nhalf of the protocol stack: The lower two layers are responsible for agreeing, in each round,\namong all nodes in the subnet on a block of messages to be executed. This block is then handedHow it works M essage Routing\n25.09.2023, 21:21 Message Routing | Internet Computer\nhttps://internetcomputer .org/how-it-works/message-routing/ 2/7over to the upper layers for deterministic processing, which, more concretely, means passing it\nover to message routing which takes over the further orchestration of deterministic processing.\nOnce message routing receives a block of messages \u2013 recall that a block comprises both\ningress messages submitted by users and XNet messages sent by canisters \u2013 the messages are\nextracted from the block and each message is placed into the input queue of its target canister.\nThis process is called induction and all the queues are collectively referred to as induction pool.\nAfter induction, the execution layer \u2013 the topmost layer of the core IC protocol stack \u2013 is\ntriggered to deterministically sche dule messages in the induction pool for execution and to\nexecute them. The actual execution of messaging happens inside a sandbox, which can be\nthought of as a virtual machine responsible for the execution of canister messages. Message\nrouting and execution modify the subnet state in a deterministic way, i.e., the state of the node is\nchanged in the same way on every (honest) node of the subnet, which is crucial for achieving the\nreplicated state machine properties of a subnet. The execution of a message can write to\nmemory pages of the canister the message is executed on and change other metadata in the\nstate. The execution of a message can also lead to the creation of new messages targeted at\nother canisters. Such a message can be either targeted at a canister on the local subnet or\nanother subnet. In the former case, execution can directly place the new message into the input\nqueue of the target canister. In the latter case, i.e., a new message that is targeted at another\nsubnet, the message is placed into the so-called XNet stream for the target subnet where they\ncan be picked up by block makers of the target subnets after the streams are certi\u0000ed.\nInter-Canister Messaging\nAs mentioned above, the execution of a canister message can lead to the creation of a new\ninter-canister message sent to a local or remote (on a di\u0000erent subnet) canister. Let us go\ndeeper into how inter-canister messaging works.\nIntra-Subnet Inter-Canister Messaging\nIntra-subnet, i.e., local, inter-canister messages originating from an executing canister method\ndo not need to go through consensus as they deterministically result from messages that have\nbeen agreed by a previous consensus round and their further execution remains completely\ndeterministic. This holds transitively, that is, inter-canister messages can create new inter-\ncanister messages, resulting in a tree of messages. Local message invocations can be executed\nas long as the cycles limit for the round has not yet been exhausted. If the cycles limit is\nexhausted but there are still local messages left, they will be handled in the same way as intra-\nsubnet messages. It is important to note that this local canister-to-canister messaging is not25.09.2023, 21:21 Message Routing | Internet Computer\nhttps://internetcomputer .org/how-it-works/message-routing/ 3/7synchr onous message invocation as one might be used to from EVM-based blockchains. Rather,\nlocal messages are put into the input queue of the target canister and are scheduled for\nexecution asynchronously. This is the standard inter-canister messaging semantics known for\nthe Internet Computer.\nInter-Subnet Inter-Canister Messaging\nRemote inter-canister messages, that is, messages sent to canisters on other subnets, are\nhandled by routing them into the respective outgoing subnet stream for the target subnet. This\nrouting happens at the end of the deterministic execution cycle, i.e., after execution hands back\ncontrol to message routing. The XNet messages in the stream are certi\u0000ed (signed) using a\nMerkle-tree-style data representation at the end of the round by the subnet using BLS threshold\ncryptography as part of the per-round state certi\u0000cation. That is, every message in the outgoing\nstream is certi\u0000ed by the originating subnet. Replicas on the receiving subnet obtain the XNet\nmessages during block making (part of consensus), validate the threshold signature, and include\nvalid XNet messages in a consensus block. Thanks to using a Merkle-tree-like datastructure to\nencode and authenticate the XNet streams, parts of the streams can be consumed in a round by\nthe receiving subnets and signatures can still be validated.\nState Certi\u0000cation\nThe replicated state of a subnet comprises all the relevant information required for the operation\nof the subnet:\nItems certi\u0000ed per round:\nResponses to ingress messages\nXnet messages to be sent to other subnets\nCanister metadata (module hashes, certi\u0000ed variables)\nItems certi\u0000ed per checkpoint:\nThe entire replicated state\nCerti\u0000cation is always done using BLS threshold signatures computed collectively by the\nsubnet, thus certi\u0000cations are computed by the subnet as a whole in a decentralized manner.\nThe properties of the threshold signature guarantee that such a certi\u0000cation can only exist if the\nmajority of the subnet agrees on the state.25.09.2023, 21:21 Message Routing | Internet Computer\nhttps://internetcomputer .org/how-it-works/message-routing/ 4/7State certi\u0000cation and secure XNet messaging enable, among others, the secure and\ntransparent communication of canisters across subnet boundaries, a challenge that any\nblockchain that has multiple shards struggles with. It also provides crucial building blocks to\nallow users to read certi\u0000ed parts of the replicated state, e.g., responses to messages submitted\nby them. Furthermore, it allows nodes to join a subnet e\u0000ciently without replaying all blocks\nsince genesis or fallen behind nodes to catch up to the most recent state of a subnet. All of this\nmakes message routing an integral layer of the core IC protocol crucial for realizing some of the\nIC's unique and distinguishing features.\nPer-Round Certi\u0000cation\nAt the end of a round, i.e., when all messages have been executed or the cycles limit for the\nround has been reached (to ensure rounds cannot take arbitrarily long), the message routing\nlayer performs a certi\u0000cation of parts of the replicated state. A BLS threshold signature is\ncomputed to certify the part of the state tree containing\nResponses to ingress messages,\nXnet messages to be sent to other subnets, and\nCanister metadata (module hashes, certi\u0000ed variables).\nThe responses to ingress messages are often referred to as ingress history. The certi\u0000ed\nresponses can be read and validated against the subnet's public key by users as the response to\ntheir ingress messages. Each of the public keys of the individual subnets are, in turn, certi\u0000ed by\nthe NNS using the same mechanism. This means that one can verify that certi\u0000ed responses\nindeed come from the IC only using the public key of the NNS. This way of validating responses\nto state-changing messages to a blockchain is extremely powerful when compared to other\napproaches seen in the \u0000eld like reading the response from a transaction log.\nThe per-round state certi\u0000cation ensures that any item of data relevant for interactions of users\nand subnets and between di\u0000erent subnets on the Internet Computer is authenticated. This\nparticularly enables secure and veri\u0000able inter-subnet communication, a crucial feature of the\nInternet Computer as well as an enabler of its scalability.\nPer-Checkpoint Certi\u0000cation\nWasm code changed through canister updates and written-to (\"dirty\") memory pages of\ncanisters and some other metadata in the replicated state do not get certi\u0000ed in every round.\nInstead they are only certi\u0000ed whenever a so-called che ckpoint is created. A checkpoint is a25.09.2023, 21:21 Message Routing | Internet Computer\nhttps://internetcomputer .org/how-it-works/message-routing/ 5/7copy of the replicated state that is persisted to disk. Such a checkpoint is written every multiple\nhund red rounds (or around 10 minutes), and for each checkpoint the subnet also computes a\ncerti\u0000cation. This allows newly joining and fallen behind nodes to join in without re-executing all\nblocks. The state certi\u0000cation is done incrementally by incorporating the changes since the last\ncheckpoint certi\u0000cation into the so called manifest of the previous checkpoint. The manifest can\nabstractly be viewed as a relatively \u0000at Merkle tree and the incremental computation can be\nachieved by updating the leaves that have changed and propagating changes up the tree.\nFinally, the root hash of the manifest is signed with a BLS threshold signature by the subnet,\nthereby certifying the entire contents of the manifest. The signed result is called a catch- up\npackage as it can be used by nodes to e\u0000ciently catch up to the point in time when the\ncheckpoint was made. (Note that a catch-up package also contains other things required to\nresume, which are omitted here for the sake of simplicity). The run time of this certi\u0000cation\noperation is linear in the num ber of memory pages that have changed and not the overall state\nsize on the subnet. This is crucial as a subnet can hold terabytes of state in the future and a full\nrecerti\u0000cation of multiple terabytes of replicated state would not be practical at every\ncheckpoint interval.\nState Synchronization\nThe message routing layer implements another feature quite unique to the Internet Computer.\nAs described above, on every checkpointing the entire subnet state is certi\u0000ed by the subnet\nthrough a BLS threshold signature on a Merkle-tree-like structure \u2013 the manifest \u2013 and made\navailable as part of a catch-up package. As the name already suggests, a catch-up package\nallows a node to catch-up if it has fallen behind, e.g., because it was down for some time. In\naddition, it allows new nodes to join, e.g., if the subnet is to grow in size or a node needs to be\nreplaced because of having been destroyed in a disaster. Such a node can download the latest\ncatch-up package and validate its signature with the public subnet key. Once veri\u0000ed, the new\nnode can download the state corresponding to the checkpoint. The downloading of the state\nrequires the transfer of large amounts (gigabytes to terabytes) of data from the nodes's peers.\nThis is done e\u0000ciently and in parallel from all peers, by using a protocol that chunks the state\nand allows for di\u0000erent chunk s to be downloaded from di\u0000erent peers. Technically, the artifact\ntransfer protocol of the P2P layer is used for transferring the state. Every chunk is authenticated\nthrough the catch-up package individually through its hash. The tree-like structure of the\nmanifest allows to verify each of these chunk s individually relative to the root hash in the catch-\nup package. The chunking  protocol is not dissimilar to the approach that Bittorrent uses for\ndownloading large \u0000les from many peers.\nIf a node is not newly added, but only had a downtime and needs to catch up, it may still have an\nolder checkpoint. In this case, only the chunk s di\u0000erent to the local checkpoint need to be25.09.2023, 21:21 Message Routing | Internet Computer\nhttps://internetcomputer .org/how-it-works/message-routing/ 6/7downloaded, which can signi\u0000cantly reduce the to-be-transferred data volume. E\u0000ciently\ncomputing the di\u0000 between a new state that is to be fetched and the locally available state can\nagain make use of the Merkle-tree-like structure of the manifest. That is, one can di\u0000 the\nmanifest to \u0000nd out the chunk s of the state that di\u0000er.\nOnce the full state corresponding to the checkpoint has been authentically downloaded, the\nnode catches up to the current block height by processing all the blocks that have been\ngenerated in the subnet since the checkpoint and \"replaying\" them, i.e., executing them as it\nwould during normal node operation, to successively make state transitions of its local state to\n\u0000nally reach the most recent one of the subnet.\nNote that without state synchronization it might practically not be possible for nodes to (re-)join\nin a \"busy\" subnet: they would need to replay all blocks from the very \u0000rst block ever created on\nthe subnet as it is done in other blockchains. Thanks to the state sync protocol allowing to\ndownload recent checkpoints, only few blocks need to be replayed as opposed to replaying\nevery block from the start of the blockchain. The reason why this is important is that the IC is\nintended to replace public cloud, i.e., to have a high throughput of operations per time unit,\nmuch like real-world cloud servers runni ng their applications. Consider a subnet that has been\nrunni ng for multiple years with high CPU utilization. This would make it infeasible for a newly\njoining node to catch up with the subnet when trying to replay all blocks starting with the\ngenesis block of the subnet as it would have to redo multiple CPU years worth of computation.\nThus, state synchronization is a necessary feature for a blockchain that wants to operate\nsuccessfully under real-world conditions where nodes do fail and need replacement.\nGo even deeper\nCheck out the wiki page describing the message routing layer in more detail.25.09.2023, 21:21 Message Routing | Internet Computer\nhttps://internetcomputer .org/how-it-works/message-routing/ 7/7\n",
  "Network Nervous System - Internet Computer Wiki.pdf": "25.09.2023, 21:22 Network Nervous System - Internet Computer Wiki\nhttps://wiki.internetcomputer .org/wiki/Network_Nervous_System 1/7Network Nervous System\nThe NNS is the decentralized autonomous organization (DAO) that governs the Internet Computer (IC). It is a fully on-chain,\ndecentralized system and is, for instance, responsible for making protocol level upgrades to continuously improve the\nInternet Computer . It does this via an implementation of liquid democracy in which ICP  neuron holders vote on proposals that\nshape the development of the Internet Computer . Once such a proposal is accepted, it is autonomously executed.\nWhile other blockchains take weeks or months to upgrade (sometimes called hard fork) and typically require substantial\nmanual work and coordination to do so, the IC upgrades itself on a weekly basis\n(https://dashboard.internetcomputer .org/releases ). Its ability to upgrade and iterate is a comparative \"superpower .\"\nThe NNS works by allowing users to stake ICP  governance tokens to create voting neurons. Anyone can create a neuron, which\ntogether exert the will of the community , mediated through algorithms. Neurons are like accounts where notice of withdrawals must be\ngiven, where the length of the notice period is a configuration known as the \u201cdissolve delay .\u201d The voting power of neurons, and their\nrelative claim to voting rewards, is proportional to the quantity of staked ICP , the length of the configured dissolve delay , and their \u201cage.\u201d\nNeurons can be made to vote manually , or automatically , by following other neurons in a form of liquid democracy .\nNeuron holders are placed in a cryptoeconomic game, where they are incentivized to vote to adopt and reject proposals, or to configure\nneuron follows that cause them to vote automatically in a desirable way , according to what is most likely to drive the value of the Internet\nComputer network over the long term.\nThis is the first time in history when a decentralized infrastructure will self-direct with the aim of competing with proprietary centralized\ninfrastructures run by commercial organizations with leaders and boards.\nOverview\nThe purpose of the NNS is to allow the Internet Computer network to be governed in an open, decentralized, and secure manner . It has\ncomplete control over all aspects of the network. For example, it can upgrade the protocol and software used by the node machines that\nhost the network; it can create new subnet blockchains to increase network capacity; it can split subnets to divide their load; it can\nconfigure economic parameters that control how much must be paid by users for compute capacity; and, in extreme situations, it can\nfreeze malicious canister smart contract software in order to protect the network; and many other things. The NNS works by accepting\nproposals, and deciding to adopt or reject them based on voting activity by \u201cneurons\u201d that network participants have created.\nNeurons are also used by participants to submit new proposals. After submission, proposals are either adopted or rejected, which can\nhappen almost immediately , or after some delay , depending upon how the totality of neurons vote. Each proposal is an instance of a\nspecific \u201cproposal type,\u201d which determines what information it contains. For each type of proposal, the NNS maintains a corresponding\nsystem function, which it invokes whenever a proposal of that type is adopted. When a proposal is adopted by the NNS, it invokes the\ncorresponding system function by drawing information from the proposal\u2019 s content to fill the parameters. Each type of proposal belongs\nto a specific \u201cproposal topic,\u201d such as \u201c#NodeAdmin\u201d or \u201c#NetworkEconomics,\u201d which determines details about how it will be\nprocessed.T o prevent users (neurons) from spamming the NNS with proposals, a fee is levied on the neuron that submitted a proposal\nif it is rejected.\nThe NNS decides whether to adopt or reject proposals by watching how neurons emit votes. Anyone can create a neuron by locking\nbalances of the Internet Computer \u2019s native utility token (ICP) that is hosted on a ledger inside the NNS. When a user creates a neuron,\nthe locked balance of ICP  can only be unlocked by disbursing (\u201cdestroying\u201d) the neuron. Users are incentivized to create neurons\nbecause they earn rewards when they vote on proposals. Rewards take the form of newly minted ICP  that are created by the NNS. The\nquantity of ICP  rewards disbursed to a neuron derive from such factors as the size of the locked balance, the minimum lockup period\nremaining (the \u201cdissolve delay\u201d), the neuron\u2019 s \u201cage,\u201d the proportion of possible votes it has participated in, and the sum of voting activity\nacross all neurons, since the overall total rewards disbursed is capped and must be divided between voters.\nAt any moment, each neuron has a currently configured \u201cdissolve delay .\u201d This determines how long it will take to dissolve if it is placed\ninto \u201cdissolve mode.\u201d Once a neuron has been placed into \u201cdissolve mode,\u201d its dissolve delay falls over the passage of time, rather like\na kitchen timer , until it reaches zero, whereupon its owner can perform a final disburse action to unlock the balance of ICP . The dissolve\ndelay creates an economic incentive for neuron owners to vote with a view toward maximizing the value of their locked ICP  balances at\na future date. ICP  is a proxy for the success of the network over the long term, sans short-term volatility , this creates an economic\nincentive to vote in the best interests of the network. Neuron owners can freely configure higher dissolve delays, up to a maximum delay\nof eight years, but cannot decrease the dissolve delay other than by the natural passage of time. The NNS pays higher voting rewards\nthe higher the dissolve delay , encouraging users to enter a game in which an economic incentive is created to vote according to a very\nlong-term vision.\nNeuron owners may find it hard to manually vote directly on every proposal submitted to the NNS. Firstly , large volumes of proposals\nmay be submitted to the NNS, often at awkward times, and owners may not be available or have the necessary time to evaluate each\none. Secondly , neuron owners may lack the necessary expertise to evaluate proposals themselves. The NNS uses a form of liquid\ndemocracy to address these challenges. For any proposal topic, a neuron can be configured to vote automatically by following the votes\nof a group of neurons, voting to adopt proposals whenever more than half of the followees vote to adopt, and voting to reject whenever\nat least half of the followees vote to reject. A catch-all follow rule may also be defined to make a neuron vote automatically on proposals\nwith topics for which no follow rule has been defined. It is assumed that neuron owners will manage how their neurons follow other\nneurons in the best interests of the network, which is also in their own economic interests, owing to their locked ICP  balances.\nIt is expected that a large proportion of the overall supply of ICP  will be locked in order to earn rewards. This secures the Internet\nComputer \u2019s network governance, by making it both dif ficult and exorbitantly expensive for an attacker to acquire a suf ficiently large\nstake to gain significant influence. Since neuron owners may wish to maximize their rewards by voting on all proposals, most neurons25.09.2023, 21:22 Network Nervous System - Internet Computer Wiki\nhttps://wiki.internetcomputer .org/wiki/Network_Nervous_System 2/7will either be actively managed or configured to follow other neurons so that they can vote automatically . In practice, once trusted\nneurons have voted on proposals, a majority of the other neurons will also vote as the result of cascading follow relationships. This\nmeans that the NNS can usually quickly determine whether a majority of the overall voting power represented by all neurons wishes to\nadopt or reject a proposal, and decide on the proposal accordingly . However , the NNS cannot depend on obtaining such a majority\nsince, in principle, neuron owners may not define follow rules, or they may simply choose not to vote.\nProposals\nFormat\nEach proposal submitted to the NNS has the following fields:\nSummary:  Text providing a short description of the proposal, composed using a maximum of 280 bytes.\nURL:  The web address of additional content required to evaluate the proposal, specified using HTTPS. For example, the\naddress might describe content supporting the assignment of a DCID (data center id) to a new data center .\nProposer:  The ID of the neuron that submitted the proposal. When a proposal is submitted, a \u201ccharge\u201d is placed on its balance\nin case it is rejected. So the balance needs to be big enough to pay the charge on (all) rejection(s). A neuron is required to\nhave a dissolve delay \u2265 6 months to vote, and this applies to submitting proposals too.\nProposal T ype: The type of the proposal. This infers what topic it belongs to (e.g., #NodeAdmin), the system function that will\nprocess the proposal if it is adopted, and the type and structure of the parameters that will be passed to that function.\nParameters:  The parameters that will be passed to the system function that will be invoked if the proposal is adopted, as\ndetermined by its type. When a proposal is submitted, the NNS checks the parameters.\nThe NNS assigns a unique identity to each proposal that it receives.\nThe NNS assigns a unique identity to each proposal that it receives.\nTopics\nThe topic of a proposal, which is inferred from its type, determines how it will be processed. For example, the NNS may require voters\nto have a greater degree of agreement, or to try to process proposals faster , for some topics. Also, neurons follow other neurons on a\nper-topic basis. Initial topics include:\n#NeuronManagement:  A special topic by means of which a neuron can be managed by the followees for this topic (in this\ncase, there is no fallback to default). V otes on this topic are not included in the voting history of the neuron. For proposals on\nthis topic, only the neuron\u2019 s followees on the topic that the proposals pertain to are allowed to vote. Because the set of eligible\nvoters of proposals on this topic is restricted, proposals on this topic have a shorter than normal voting period.\nExchangeRate:  All proposals provide information in \u201creal time\u201d about the market value of ICP , as measured by an International\nMonetary Fund (IMF) Special Drawing Right (SDR) , which allows the NNS to convert ICP  to cycles (which power\ncomputation) at a rate that keeps their real-world cost constant. Because proposals on this topic are very frequent, they have a\nshorter voting period, and votes on this topic are not included in the voting history of the neuron.\n#NetworkEconomics:  Proposals that administer network economics \u2014 for example, determining what rewards should be\npaid to node operators.\n#Governance:  All proposals that administer governance \u2014 for example, motions and the configuration of certain parameters.\n#NodeAdmin:  All proposals that administer node machines somehow , including but not limited to upgrading or configuring the\nOS, upgrading or configuring the virtual machine framework, and upgrading or configuring the node replica software.\n#ParticipantManagement:  All proposals that administer network participants \u2014 for example, granting and revoking DCIDs\n(data center identities) or NPIDs (node provider identities).\n#SubnetManagement:  All proposals that administer network subnets \u2014 for example, creating new subnets, adding and\nremoving subnet nodes, and splitting subnets.\n#NetworkCanisterManagement:  Installing and upgrading \u201csystem\u201d canisters  that belong to the network \u2014 for example,\nupgrading the NNS.\n#KYC:  Proposals that update KYC information for regulatory purposes \u2014 for example, during the initial Genesis distribution of\nICP in the form of neurons.\n#NodeProviderRewards:  Topic for proposals to reward node providers.\nTypes\nInitial proposal types include:\nManageNeuron (#NeuronManagement, Restricted V oting)  This type of proposal calls a major function on a specified target\nneuron. Only the followees of the target neuron may vote on these proposals, which ef fectively provides the followees with\ncontrol over the target neuron. This can provide a convenient and highly secure means for a team of individuals to manage an25.09.2023, 21:22 Network Nervous System - Internet Computer Wiki\nhttps://wiki.internetcomputer .org/wiki/Network_Nervous_System 3/7important neuron. For example, a neuron might hold a large balance, or belong to an organization of high repute, and be\npublicized so that many other neurons can follow its vote. In both cases, managing the private key of the principal securely\ncould be problematic. (Either a single copy is held, which is very insecure and provides for a single party to take control, or a\ngroup of individuals must divide responsibility \u2014 for example, using threshold cryptography , which is complex and time\nconsuming). To address this using this proposal type, the important neuron can be configured to follow the neurons controlled\nby individual members of a team. Now they can submit proposals to make the important neuron perform actions, which are\nadopted if and only if a majority of them vote to adopt. (Submitting such a proposal costs a small fee, to prevent denial-of-\nservice attacks.) Nearly any command on the target neuron can be executed, including commands that change the follow\nrules, allowing the set of team members to be dynamic. Only the final step of dissolving the neuron once its dissolve delay\nreaches zero cannot be performed using this type of proposal, since this would allow control/\u201cownership\u201d over the locked\nbalances to be transferred. (The only exception to this rule applies to not-for-profit organizations, which may be allowed to\ndissolve their neurons without using the initial private key .) To prevent a neuron falling under the malign control of the\nprincipal\u2019 s private key by accident, the private key can be destroyed so that the neuron can only be controlled by its followees,\nalthough this makes it impossible to subsequently unlock the balance.\nManageNetworkEconomics (#NetworkEconomics)  This is a single proposal type which can update one or several\neconomic parameters:\nReject cost: The amount of ICP  the proposer of a rejected proposal will be charged \u2014 to prevent the spamming of\nfrivolous proposals.\nMinimum Neuron Stake: Set the minimum number of ICP  required for creation of a neuron. The same limit must also be\nrespected when increasing dissolve delay or changing the neuron state from dissolving to aging.\nNeuron Management fee: The cost in ICP  per neuron management proposal. Here the NNS is doing work on behalf of a\nspecific neuron, and a small fee will be applied to prevent overuse of this feature (i.e., spam).\nMinimum ICP/SDR rate: To prevent mistakes, there is a lower bound for the ICP/SDR rate, managed by network\neconomic proposals.\nDissolve delay of spawned neurons: The dissolve delay of a neuron spawned from the maturity of an existing neuron.\nMaximum node provider rewards: The maximum rewards to be distributed to node providers in a single distribution event\n(proposal).\nTransaction fee: The transaction fee that must be paid for each ledger transaction.\nMaximum number of proposals to keep per topic: The maximum number of proposals to keep, per topic. When the total\nnumber of proposals for a given topic is greater than this number , the oldest proposals that have reached a \u201cfinal\u201d state\nmay be deleted to save space.\nMotion (#Governance)  A motion is a text that can be adopted or rejected. No code is executed when a motion is adopted. An\nadopted motion should guide the future strategy of the Internet Computer ecosystem.\nApproveGenesisKYC (#KYC)  When new neurons are created at Genesis, they have GenesisKYC=false. This restricts what\nactions they can perform. Specifically , they cannot spawn new neurons, and once their dissolve delays are zero, they cannot\nbe disbursed and their balances unlocked to new accounts. This proposal sets GenesisKYC=true for batches of principals.\n(Special note: The Genesis event disburses all ICP  in the form of neurons, whose principals must be KYCed. Consequently , all neurons\ncreated after Genesis have GenesisKYC=true set automatically since they must have been derived from balances that have already\nbeen KYCed.)\nAddOrRemoveNodeProvider (#Participant Management)  Assign (or revoke) an identity to a node provider , associating key\ninformation regarding the legal person associated that should provide a way to uniquely identify it.\nRewardNodeProvider (#NodeProviderRewards)  Propose to reward a Gen-1 node provider an amount of ICP  as\ncompensation for providing Gen-1 nodes to the IC.\nSetDefaultFollowees (#Governance)  Specify the list of followees that a freshly created neuron should have.\nThe following is a list of proposal types that call other NNS canisters:\nCreateSubnet (#SubnetManagement)  Combine a specified set of nodes, typically drawn from data centers and operators in\nsuch a way as to guarantee their independence, into a new decentralized subnet. The execution of this external update first\ninitiates a new instance of the distributed key generation protocol. The transcript of that protocol is written to a new subnet\nrecord in the registry , together with initial configuration information for the subnet, from where the nodes comprising the subnet\npick it up.\nAddNodeT oSubnet (#SubnetManagement)  Add a new node to a subnet. The node cannot be currently assigned to a subnet.\nThe execution of this proposal changes an existing subnet record to add a node. From the perspective of the NNS, this update\nis a simple update of the subnet record in the registry .25.09.2023, 21:22 Network Nervous System - Internet Computer Wiki\nhttps://wiki.internetcomputer .org/wiki/Network_Nervous_System 4/7InstallNetworkCanister (#NetworkCanisterManagement)  A proposal to add a new canister to be installed and executed in\nthe NNS subnetwork. The root canister , which controls all canisters on the NNS except for itself, handles this proposal type.\nThe call also expects the W asm module that shall be installed.\nUpgradeNetworkCanister (#NetworkCanisterManagement)  A proposal to upgrade an existing canister in the NNS\nsubnetwork. This proposal type is executed by the root canister . Beyond upgrading the W asm module of the target canister ,\nthe proposal can also set the authorization information and the allocations.\nBlessReplicaV ersion (#NodeAdmin)  A proposal to bless a new version to which the replicas can be upgraded. The proposal\nregisters a replica version (identified by the hash of the installation image) in the registry . Besides creating a record for that\nversion, the proposal also appends that version to the list of \u201cblessed versions\u201d that can be installed on a subnet. By itself, this\nproposal does not ef fect any upgrade. (In the future, there will only be one blessed version of the replica software at any given\ntime.)\nRecoverSubnet (#SubnetManagement)  Update a subnet\u2019 s recovery CUP  (used to recover subnets that have stalled). Nodes\nthat find a recovery CUP  for their subnet will load that CUP  from the registry and restart the replica from that CUP .\nUpdateSubnetConfig (#SubnetManagement)  Update a subnet\u2019 s configuration. This proposal updates the subnet record in\nthe registry , with the changes being picked up by the nodes on the subnet when they reference the respective registry version.\nSubnet configuration comprises protocol parameters that must be consistent across the subnet (e.g., message sizes).\nAssignNPID (#ParticipantManagement)  Assign an identity to a node operator associating key information regarding its\nownership, the jurisdiction in which it is located, and other information. The node operator is stored as a record in the registry .\nIt contains the remaining node allowance for that node operator , that is the number of nodes the node operator can still add to\nthe IC. When an additional node is added by the node operator , the remaining allowance is decreased.\nRootUpgrade (#NetworkCanisterManagement)  A proposal to upgrade the root canister in the NNS subnetwork. The\nproposal is processed by the Lifeline canister , which controls the root canister . The proposal updates the W asm module as\nwell as the authorization settings.\nSetICPSDR (#ExchangeRate)  Instruct the NNS about the market value of 1 ICP  as measured by an IMF SDR. This setting\naffects cycles pricing (as the value of cycles shall be constant with respect to IMF SDRs).\nUpgradeSubnetT oReplicaV ersion (#SubnetManagement)  Update the replica version running on a given subnet. The\nproposal changes the replica version that is used on the specified subnet. The version must be contained in the list of blessed\nreplica versions. The upgrade is performed when the subnet creates the next regular CUP .\nClearProvisionalWhitelist (#NetworkEconomics)  Clears the provisional whitelist, which allows the listed principals to create\ncanisters with cycles. The mechanism is only needed for bootstrap and testing and must be deactivated afterward.\nRemoveNodeFromSubnet (#SubnetManagement)  Remove a node from a subnet. It then becomes available for\nreassignment. The execution of this proposal changes an existing subnet record to remove a node. From the perspective of\nthe NNS, this update is a simple update of the subnet record in the registry .\nSetAuthorizedSubnetworks (#Governance)  Informs the cycles minting canister that a certain principal is authorized to use\ncertain subnetworks (from a list). Can also be used to set the \u201cdefault\u201d list of subnetworks that principals without special\nauthorization are allowed to use.\nSetFirewallConfig (#SubnetManagement)  Change the Firewall configuration in the registry (configures which boundary\nnodes subnet blockchain replicas will communicate with).\nUpdateNodeOperatorConfig (#NodeAdmin)  Change a node operator \u2019s allowance in the registry .\nStopOrStartNNSCanister (#NetworkCanisterManagement)  Stop or start an NNS canister .\nICP tokens\nICP are native utility tokens that play three key roles in the network:\n1. Facilitating Network Governance  ICP tokens can be locked to create neurons that participate in network governance by voting,\nthrough which they can earn economic rewards.\n1. Production of Cycles for Compute  ICP provides a source store of value that can be converted into \u201ccycles,\u201d which power\ncomputation in the role of fuel that is burned when it is used. The NNS converts ICP  to cycles at a variable rate, so chosen to\nensure users of the network can always create new cycles at approximately constant cost in real terms, such that the cost of\nacquiring fuel is predictable.25.09.2023, 21:22 Network Nervous System - Internet Computer Wiki\nhttps://wiki.internetcomputer .org/wiki/Network_Nervous_System 5/71. Rewarding Participants  The network mints new ICP  to reward and incentivize those playing important roles that enable the\nnetwork to function, including: a) the provision of \u201cvoting rewards\u201d to those participating in governance, and b) the provision of\n\u201cnode provider rewards\u201d to those operating the node machines that are hosting the network.\nLedger\nThe ICP  ledger is hosted within the NNS, and records all balances of ICP  in the manner of a spreadsheet. Each row is called an\n\u201caccount,\u201d which has two fields (i.e., there are two \u201ccolumns\u201d):\n1. Account identifier (bytes)  A unique value that is derived from the identity of the \u201cprincipal\u201d that \u201ccontrols\u201d the account. Currently ,\nthe principal must either be: (i) the owner of a public key pair , or (ii) a canister smart contract that is part of the NNS. Account\nidentifiers are derived by hashing the concatenation of a domain separator , the principal ID, and the subaccount (or zeros if no\nsubaccount is given).\n1. Balance  (positive integer , representing one hundredth of a millionth of an ICP) The quantity of ICP  assigned to the principal of the\naccount.\nWhen the principal is a public key or Canister , they can apply the following operation to an account:\n1. Send  Send a portion of the ICP  balance to another account. If all the ICP  is sent to another account, then the sending account\nceases to exist (i.e., is deleted from the ledger).\n2. Notify  When the destination of the funds sent is the account of an NNS canister (e.g., an account of the governance canister), the\nsender can ask the ledger to notify the recipient canister of the incoming transfer . The recipient canister can then act on this\nnotification. Two examples where this ability is used are creating a neuron and refreshing the stake of a neuron. These are\ndetailed below .\nOperations that require interaction between the ledger and the governance system (Neurons):\n1. Create neuron  When the principal is a public key holder , they may lock a portion of their balance inside a new neuron.\nTechnically , creating the neuron is done in two stages. First transfer the ICP  to be staked to an account of the governance canister\n(which corresponds to a new neuron \u2014 the details of the association are omitted here). Then notify the governance canister of the\nincoming transfer which updates its internal neuron bookkeeping. If the entire balance is locked inside a new neuron, the account\nceases to exist (i.e., is deleted from the ledger). To move these ICP  to a dif ferent account, such as back to the original account,\nwhere they can once again be controlled like a normal balance, the associated neuron must be fully dissolved and disbursed\n(destroyed). The new neuron that has been created is controlled by the private key of the principal that created it.\n2. Refresh stake  The stake of a neuron may be increased by transferring to its address/account in the ledger and notifying the\ngovernance canister of the incoming transfer . Refreshing the stake will change the maturity and age of the neuron prorated. For\nexample, if the stake is doubled, the maturity and age will be halved, so spawning will yield the same amount and the age bonus\nwill be the same as before (in absolute terms).\nNeurons\nA neuron locks a balance of ICP  and enables its owner to participate in network governance, through which they can earn rewards.\nAttributes\nNeurons have the following attributes:\nIdentity (uint64)  The general identity of the neuron object. When a neuron is configured to follow another neuron, this is the\nvalue that is used. This is a random 64-bit value selected at neuron creation.\nAccount (bytes, private)  The ledger account where the locked ICP  balance resides.\nController (principal ID, private)  The principal that actually controls the neuron. The principal must identify a public key pair ,\nwhich acts as a \u201cmaster key ,\u201d such that the corresponding secret key should be kept very secure. The principal might control\nmany neurons.\nHot Keys (list of principal ID, private)  Keys that can be used to perform actions with limited privileges, such as voting,\nwithout exposing the secret key corresponding to the principal (e.g., could be a W ebAuthn key).\nCreatedAt (timestamp)  When the Neuron was created.\nAgingSince (timestamp)  The timestamp corresponding to the time this neuron has started aging. This is either the creation\ntime or the last time at which the neuron has stopped dissolving. This value is meaningless when the neuron is dissolving,\nsince a dissolving neuron always has an age of zero.25.09.2023, 21:22 Network Nervous System - Internet Computer Wiki\nhttps://wiki.internetcomputer .org/wiki/Network_Nervous_System 6/7DissolveState  At any time, at most one of WhenDissolved and DissolveDelay are specified.\nWhenDissolved (timestamp)\nWhen the dissolve timer is running, this stores the timestamp in seconds from the Unix epoch, at which point the neuron becomes\ndissolved. At any time while the neuron is dissolving, the neuron owner may pause dissolving, in which case DissolveDelay will get\nassigned to: WhenDissolved minus the timestamp when the action is taken.\nDissolveDelay (duration)\nWhen the dissolve timer is stopped, this stores how much time the dissolve timer will be started with. It can be eight years at most. At\nany time while in this state, the neuron owner may (re)start dissolving, in which case WhenDissolved will get assigned to the timestamp\nwhen the action is taken plus DissolveDelay .\nMaturity (positive number )  The maturity of a neuron which reflects the amount of voting rewards allocated to a neuron.\nWhen new neurons are created, their maturity is zero. When neurons vote, over time the NNS increases their maturity to\nreward them.\nFollow Relationships (mapping from topic to list of followees, private)  A neuron can be configured to vote automatically\nby following other neurons on a topic-by-topic basis. For any valid topic, a list of followees can be specified, and the neuron\nwill follow the vote of a majority of the followees on a proposal with a type belonging to that topic. If a null topic is specified, this\nacts as a catch-all that enables the neuron to follow the vote of followees where a rule has not been specified.\nRecent V otes (public)  A record of recent votes is maintained. This can provide a guide for those wishing to evaluate whether\nto follow a neuron, or how their followees are voting.\nNotForProfit (boolean)  Whether this neuron is \u201cnot for profit,\u201d making it dissolvable by voting.\nThe following attributes can be computed:\nAge (seconds)  (computed from AgingSince and current time) The period of time that has elapsed since the neuron was\ncreated or last stopped dissolving. Conceptually , whenever a neuron starts dissolving, then its age is reset to zero and remains\nzero while it is dissolving. If a dissolving neuron has dissolving turned of f, the current time becomes the ef fective neuron\ncreation date for the purposes of calculating the age.\nState (LOCKED or DISSOL VING or DISSOL VED)  (computed from DissolveState and the current time)\nLOCKED: In this state, the neuron is locked with a specific DissolveDelay . It accrues age by the passage of time and it\ncan vote if DissolveDelay is at least six months. The method start_dissolving can be called to transfer the neuron to the\nDISSOL VING state. The method increase_dissolve_delay can be used to increase the dissolve delay without af fecting\nthe state or the age of the neuron.\nDISSOL VING: In this state, the neuron\u2019 s effective dissolve delay decreases with the passage of time. While dissolving,\nthe neuron\u2019 s age is considered zero. Eventually it will reach the DISSOL VED state. The method stop_dissolving can be\ncalled to transfer the neuron to the LOCKED state, and the neuron will start aging again. The method\nincrease_dissolve_delay can be used to increase the dissolve delay , but this will not stop the timer or af fect the age of\nthe neuron.\nDISSOL VED: In the dissolved state, the neuron\u2019 s stake can be disbursed using the disburse method. It cannot vote as its\ndissolve delay is considered to be zero. If the method increase_dissolve_delay is called in this state, the neuron will\nbecome locked with the specified dissolve delay and start aging again. Neuron holders have an incentive not to keep\nneurons in the dissolved state for a long time: if the holders want to make their tokens liquid, they disburse the neuron\u2019 s\nstake, and if they want to earn voting rewards, they increase the dissolve delay . If these incentives turn out to be\ninsuf ficient, the NNS may decide to impose further restrictions on dissolved neurons.\nControlByProposals (boolean)  (true if the neuron has a non-empty list of followees on the #NeuronManagement topic) If a\nneuron specifies followees on the ManageNeuron topic, it can be managed by proposals of type ManageNeuron\n(#NeuronManagement), which may only be voted upon by the neuron\u2019 s own followees. This provides a foundation for the\nmanagement of highly security sensitive neurons, since it allows them to be maintained without hot keys or the secret key of\nthe principal, which can be kept in cold storage or even destroyed (so long as the associated balance of ICP  need never be\nunlocked). For example, the DFINITY  Foundation or the Internet Computer Association might publicize the address of special\nneurons that will be made to vote according to their wishes, so that others can configure their neurons to follow them and\nleverage their expertise and ef forts in governance. One problem with such practices is that they introduce the risk that secret\nkeys used in the management of the publicized neurons might be compromised, allowing hackers to take control and \u201ctrick\u201d\nlarge numbers of following neurons into voting according to their wishes. If the publicized neurons have admin proposals\nenabled, however , then they can be administered by the neurons they follow (their followees), which are typically controlled by25.09.2023, 21:22 Network Nervous System - Internet Computer Wiki\nhttps://wiki.internetcomputer .org/wiki/Network_Nervous_System 7/7a large number of team members who cannot be simultaneously extorted, without any need for the usage of secret keys\nwhatsoever .\nCommands\nThe principal that controls a neuron may instruct it to perform the following actions:\nStart Dissolving  The dissolve delay is like a kitchen timer that can only be turned in one direction. It can be arbitrarily\nincreased, but only reduced by turning on dissolve mode and counting down. The neuron can be instructed to start\n\u201cdissolving.\u201d When the neuron is dissolving, its dissolve delay falls over the passage of time until either it is stopped or it\nreaches zero. A neuron cannot vote (or earn rewards for voting) when its dissolve delay falls below six months. Once the\ndissolve delay reaches zero, it stops falling and the controlling principal can instruct the neuron to disburse.\nStop Dissolving  A neuron that is dissolving can be instructed to stop, whereupon its dissolve delay stops falling with time.\nDisburse  When the dissolve delay of the neuron is 0, its controlling principal can instruct it to disburse the neuron\u2019 s stake. Its\nlocked ICP  balance is transferred to a specified new ledger account, and the neuron and its own ledger account disappear .\nIncrease Dissolve Delay  The dissolve delay of a neuron can be increased up to a maximum of eight years.\nSpawn  When the maturity of a neuron has risen above a threshold, it can be instructed to spawn a new neuron. This creates a\nnew neuron that locks a new balance of ICP  on the ledger . The new neuron can remain controlled by the same principal as its\nparent, or be assigned to a new principal. When a neuron spawns a new neuron, its maturity falls to zero.\nAdd Hot Key  Add a new hot key that can be used to manage the neuron. This provides an alternative to using the principal\u2019 s\ncold key to manage the neuron, which might be onerous and dif ficult to keep secure, especially if it is used regularly . A hot key\nmight be a W ebAuthn key that is maintained inside a user device, such as a smartphone.\nRemove Hot Key  Remove a hot key that has been previously assigned to the neuron.\nThe following actions can be initiated using the principal or a hot key that has been configured:\nVote Have the neuron vote to either adopt or reject a proposal with a specified ID.\nFollow  Add a rule that enables the neuron to vote automatically on proposals that belong to a specific topic, by specifying a\ngroup of followee neurons whose majority vote is followed. The configuration of such follow rules can be used to: a) distribute\ncontrol over voting power amongst multiple entities, b) have a neuron vote automatically when its owner lacks time to evaluate\nnewly submitted proposals, c) have a neuron vote automatically when its own lacks the expertise to evaluate newly submitted\nproposals, and d) for other purposes. A follow rule specifies a set of followees. Once a majority of the followees votes to adopt\nor reject a proposal belonging to the specified topic, the neuron votes the same way . If it becomes impossible for a majority of\nthe followees to adopt (for example, because they are split 50\u201350 between adopt and reject), then the neuron votes to reject. If\na rule is specified where the proposal topic is null, then it becomes a catch-all follow rule, which will be used to vote\nautomatically on proposals belonging to topics for which no specific rule has been specified. If the list of followees is empty ,\nthis ef fectively removes a follow rule.\nSee Also\nThe Internet Computer project website (hosted on the IC): internetcomputer .org (https://internetcomputer .org/)",
  "Node providers _ Internet Computer.pdf": "25.09.2023, 21:24 Node providers | Internet Computer\nhttps://internetcomputer .org/node-providers 1/10Decentralized computing\nThe Internet Computer blockchain operates on a network of nodes owned and managed by a\ngrowing community of independent, vetted node providers distributed across the globe.Sovereign network\nThe Internet Computer is hosted by a decentralized collection of node machines \u2014\nphysical hardware devices run by independent node providers distributed across data\ncenters globally.\n25.09.2023, 21:24 Node providers | Internet Computer\nhttps://internetcomputer .org/node-providers 2/10Get more data on the dashboard\nNode providers\nData centers\nTotal node machines\nNode Providers\n+\n\u2212\n Leaflet  | \u00a9 OpenStreetMap  contributors \u00a9 CAR TO25.09.2023, 21:24 Node providers | Internet Computer\nhttps://internetcomputer .org/node-providers 3/10Independent machines\nTotal energy consumption\n25.09.2023, 21:24 Node providers | Internet Computer\nhttps://internetcomputer .org/node-providers 4/10Every node on the Internet Computer is a dedicated physical server called a node\nmachine. To provide true decentralization, each node machine is run by an\nindependent node provider, typically in a data center. This network of nodes is\nsovereign, as there is no reliance on corporate cloud service providers. So they\ncannot be switched o\u0000 or tampered with.\nThis is di\u0000erent to other blockchains where network nodes are created using simple\nsoftware that interacts with other nodes but are easy to spin up on centralized cloud.\nNode machines on the Internet Computer are also technically sovereign, built to\nstandardized public hardware speci\u0000cations that support the network when under\nload, and do not fall behind other nodes within the same subnet blockchain.\nAbout creating a sovereign network25.09.2023, 21:24 Node providers | Internet Computer\nhttps://internetcomputer .org/node-providers 5/10Node Providers\nTo preserve the decentralization of the network, each node provider is voted in by\ntoken-holders via the NNS, the DAO that governs the Internet Computer. Becoming a\nnode provider entails submitting a proposal along with a self-declaration document\nthat state provision of node machines, intent and proof of identity. Based on this\ninformation, the community votes on the onboarding proposal.\nIf node providers are accepted into the community and their node machines are up\nand running, they receive rewards for their services. Rewards are set by the NNS\nDAO, which follows the 30-day average price of ICP, and are distributed on the 15th\nof every month. The NNS DAO issues rewards depending on three main factors:\n25.09.2023, 21:24 Node providers | Internet Computer\nhttps://internetcomputer .org/node-providers 6/10generation of hardware (Gen 1 or Gen2), geographic location, and total number of\nnodes operated.\nMore on renumeration models\nThe hardware\nThe Internet Computer network consist of two generations of node machines \u2014 Gen\n1 and Gen 2 \u2014 with standardized public hardware speci\u0000cations. Gen 1 hardware is\nvendor speci\u0000c and used by node providers who joined the community before 2022.\nNew Gen 2 node machines are generic to support VM memory encryption and\n25.09.2023, 21:24 Node providers | Internet Computer\nhttps://internetcomputer .org/node-providers 7/10attestation, which will facilitate the future development of features on the Internet\nComputer. While Gen 2 machines follow generic speci\u0000cations, a list of hardware\ncon\u0000gurations has been validated by the community.\nSee hardware guide\nClimate friendly compute\nA key goal of the Internet Computer is to provide an energy e\u0000cient compute\nplatform at low carbon costs without compromising scalability and utility. Operating\nat 0.008 kW per transaction, it is one of the most sustainable blockchains out there,\n25.09.2023, 21:24 Node providers | Internet Computer\nhttps://internetcomputer .org/node-providers 8/10and has comparable energy consumption levels to traditional software running on big\ntech cloud services. Instantaneous power for each node is around 0.3 kW, which is\nroughly between 200 and 300 kWh a month, per node.\nThe Internet Computer is also the \u0000rst blockchain to join the Proof of Green (PoG)\ninitiative, which aims to set blockchain industry standards by making \u2018claims of green\u2019\ntransparent, veri\u0000able and accountable through metrics and real-time reporting. PoG\nis still in a pilot phase but a handful of nodes and their carbon emissions are already\nrepresented on a live dashboard. Further steps towards carbon footprint transparency\nare on the roadmap, including data sourcing, validation and incentive mechanisms.\nVisit the live dashboard\nNode provider commu nity\nThe growing ICP community of node providers includes independent entities across\nthe globe, including...\nJOIN THE NP COMMUNITY\n25.09.2023, 21:24 Node providers | Internet Computer\nhttps://internetcomputer .org/node-providers 9/10\nWhat you need to know about being\na node provider25.09.2023, 21:24 Node providers | Internet Computer\nhttps://internetcomputer .org/node-providers 10/10Where to start\nBefore making the decision to become a node provider, it is recommended to start by\nfamiliarizing yourself with the following:\nBrief intro to the Internet Computer\nThe Internet Computer architecture\nGovernance of the Internet Computer\nNode provider overview documentation\nOnboarding checklist\nNow that you have a basic understanding of how the Internet Computer works, you can begin\nthe onboarding process with the help of the following resources:\nFill out self-declaration form\nSubmit proposal and onboard your nodes to the Internet Computer\nJoin the node provider matrix channel\nChoose and purchase hardware\nSet up servers in a data center\nGET STARTED",
  "Overview _ Internet Computer.pdf": "25.09.2023, 21:21 Overview | Internet Computer\nhttps://internetcomputer .org/how-it-works/core-ic-protocol-overview/ 1/2\nCore Internet Compu ter Protocol \u2013\nOverview\nA subnet hosts canister smart contracts and executes messages sent to them either by users or\nother canister smart contracts (which may be hosted on the same or another subnet). Messages\non the IC are analogous to transactions on other blockchains. Messages addressed to a canister\nsmart contract are executed by the nodes on the corresponding subnet by running the Wasm\ncode of the canister. Canister code execution updates the canister state. In order to keep the\nstate on the subnet nodes on which a canister is hosted in sync, it must be ensured that every\nnode executes the same messages in the same order, i.e., fully deterministically. This is the core\nof the blockchain-based replicated state machine functionality realizing the IC.\nEach node on the Internet Computer runs a replica process. The replica process is structured in\na layered architecture consisting of the following 4 layers:\n\u0000\u0000\u0000Peer-to-peer\n\u0000\u0000\u0000Consensus\n\u0000\u0000\u0000Message routing\n\u0000\u0000\u0000Execution\nHow it works Overview\n25.09.2023, 21:21 Overview | Internet Computer\nhttps://internetcomputer .org/how-it-works/core-ic-protocol-overview/ 2/2\nThe 4-layer architecture of the Core IC Protocol\nThe Peer-to-Peer layer is responsible for accepting messages from users and exchanging\nmessages between nodes in a subnet. The consensus layer lets all the nodes on the subnet to\nagree on the messages to be processed, as well as their ordering. The message routing layer\npicks up the \u0000nalized blocks from consensus layer and routes the messages in the blocks to\nappropriate canisters. The execution layer determinstically executes canister code on the\nmessages received from the messaging layer.\nThe upper two layers realize deterministic execution of the block of messages for a round\nreceived from the lower two layers, on each node of the subnet. At the beginning of a round, all\n(honest) nodes hold the same state, representing the replicated state of the subnet (which\nincludes the current state on all canisters hosted on that subnet. By executing the messages of\nthe next block received from consensus in a completely deterministic manner, it is ensured that\nthe state after executing the messages of the block is the same on each node due to the\ndeterminism in execution.\nCanister smart contracts can communicate with each other by sending messages, regardless of\nwhether they are hosted on the same or di\u0000erent subnets. The IC core protocol handles both the\ninter-canister messages sent locally, i.e., on the same subnet, between canisters, as well as\ninter-canister messages sent across subnets, so called XNet messages. Local inter-canister\nmessages do not need to go through consensus, while XNet inter-canister messages do (making\nthe former more e\u0000cient in terms of throughput and incurring less latency).\nThe core IC protocol heavily relies on cha in-key cryptography for its operation. A key\ncomponent of chain-key cryptography is cha in-evolution techn ology, which facilitates the long-\nterm operation of the IC, such as allowing new nodes to easily and securely join a subnet.",
  "Peer-to-Peer _ Internet Computer.pdf": "25.09.2023, 21:21 Peer-to-Peer | Internet Computer\nhttps://internetcomputer .org/how-it-works/peer-to-peer-p2p/ 1/3\nPeer-to-Peer\nThe peer-to-peer layer (P2P) of the Internet Computer realizes the reliable and secure\ncommunication of network messages, also called artifacts, between the nodes of a subnet.\nArtifacts are the network messages that are to be broadcast in the subnet, including the input to\ncanister smart contracts submitted by users or protocol-originating messages such as the blocks\nproduced by the consensus layer. P2P guarantees the secure eventual broadcast delivery of an\nartifact to all nodes which require it to make progress. The P2P layer thereby is the\ncommunication fabric for the IC protocol stack and is used by the consensus layer, the next layer\nin the stack above it, to broadcast artifacts to the nodes in the subnet.\nIt is important to note that broadcast artifacts reach all necessary subnet nodes eventually, that\nis, no upper bound on when this happens can be given. This asynchr onous communication\nnetwork assumption is used for the ICP's communication and consensus layers as it re\u0000ects the\nproperties of real-world networks.\nGos sip Protoc ol\nThe P2P layer builds upon the basic principle of gossip. Gossip in communication networks\nworks along the same basic principle as gossip among people: A node in the subnet is\nconnected with a subset of the other nodes of the subnet \u2013 its peers. Whenever a node receives\nan artifact from a peer or creates one itself as part of the IC protocol, it gossips this artifact to all\nits peers. By every node in the network doing exactly this, every artifact eventually propagates\nthrough the whole subnet, despite potential connectivity issues or malicious node behavior.\nWhenever a subnet node receives or generates an artifact to be broadcast, the node makes the\nartifact available to all peers. Every node doing so ensures that the artifact will eventually be\ndelivered to all subnet nodes. However, doing so in a na\u00efve way by simply sending the artifact to\nall peers would result in nodes receiving as many copies of the same artifact as the node has\npeers, which unnec essarily consumes networking bandwidth for transmitting duplicate\nmessages and reduces the achievable throughput of the subnet.How it works Peer-to-Peer\n25.09.2023, 21:21 Peer-to-Peer | Internet Computer\nhttps://internetcomputer .org/how-it-works/peer-to-peer-p2p/ 2/3This duplication of delivered artifacts in the na\u00efve approach is mitigated by nodes sending\nadverts for artifacts to their peers instead of sending the artifacts themselves. An advert\nspeci\u0000es its corresponding artifact, but is a small message only containing the hash of the\nartifact to unambiguously refer to it and some additional metadata. A node only pushes adverts\nfor artifacts to its peers. After receiving an advert, a node may request the corresponding\nartifact from one or more of its peers who sent it an advert for that artifact.\nPriori tization  of Artifacts\nThe P2P layer allows the prioritization of artifacts such that the more crucial artifacts are\nbroadcast throughout the subnet nodes more quickly than the others. Prioritizing some artifacts\nover others is important to ensure that the protocol can always make progress and not be\nstarved of network bandwidth by \"less important\" tra\u0000c. This principle is well known from\ntraditional networking and applies equally well to a blockchain system.\nSecurity\nTo prevent Denial of Service (DOS) attacks, nodes will only request and accept connections with\nnodes in the same subnet. Subnet membership is managed by the Network Nervous System\n(NNS). Thanks to the information stored in the NNS canisters P2P can guarantee that all the\ncommunication between two nodes is encrypted and authenticated, by using TLS.\nGo E ven De eper\nP2P on the IC wiki\nBlogpost on P2P25.09.2023, 21:21 Peer-to-Peer | Internet Computer\nhttps://internetcomputer .org/how-it-works/peer-to-peer-p2p/ 3/3\n",
  "Tokenomics of the Internet Computer _ Internet Computer.pdf": "25.09.2023, 21:22 Tokenomics of the Internet Computer | Internet Computer\nhttps://internetcomputer .org/how-it-works/tokenomics/ 1/5\nTokenomics of the Internet\nComput er\nThe ICP utility token\nThe Internet Computer (IC) makes use of a utility token called ICP. This token is used for the\nfollowing functions on the platform: First, any ICP holder can participate in the governance of\nthe IC by staking ICP in order to vote on proposals and earn voting rewards. Second, you can\ntransform ICP into cycles, which are used as fuel for computation. Third, ICP tokens are used to\npay the entities who provide compute capacity by operating node machines. Last but not least,\nICP can be used in order to participate in token swaps of decentralized autonomous\norganizations (DAOs) on the IC. We will elaborate on these four use cases in the following. In\naddition to the aforementioned platform use cases, ICP can also be used as a medium of\nexchange, i.e., to pay for goods and services like NFTs, subscriptions, etc.\nGovernance and voting rewards\nAnyone can participate in the governance of the IC by staking ICP tokens in so-called neurons.\nNeuron holders can vote on proposals, which are suggestions on how the IC should be changed.\nThe neurons\u2019 voting power for decision making is proportional to the numb er of ICP staked\ninside. However, the voting power also depends on some other neuron characteristics, in\nparticular, for how long tokens are staked. For example, a neuron can boost its voting power by\n100% by setting the time staked to the maximum of 8 years. The increased voting power for\nneurons with longer staking time creates an incentive to vote on proposals with the aim of\ndriving decisions that maximize the value of their staked ICP over the long term.\nFor participation in governance, neurons receive voting rewards which can be converted into\nnewly minted ICP. Every day, the IC calculates a voting reward pot according to a schedule,\nwhich it then divides among all eligible neurons according to their relative voting power. The\nschedule for voting rewards is designed to incentivize early adoption: Initially at genesis, 10% ofHow it works Tokenomics of the Internet Computer\n25.09.2023, 21:22 Tokenomics of the Internet Computer | Internet Computer\nhttps://internetcomputer .org/how-it-works/tokenomics/ 2/5the total supply of ICP is distributed in voting rewards on an annua lized basis. Over the course of\neight years, this num ber falls to 5%.\nAs the daily reward amount is independent of the overall amount of staked ICP in the system,\nparticipants receive larger rewards if overall staking and participation in governance decreases.\nThis mechanism creates a natural incentive to stake ICP and participate in governance. As of\nNovember 2022, 266M ICP is staked, corresponding to 54% of the total supply. A signi\u0000cant\npart of staked ICP, namely 123M ICP (i.e., 46%), is staked for the maximum time of 8 years\nexpressing the long-term commitment of these stakers.\nNeurons can be con\u0000gured to vote automatically by following the votes of other neurons, in an\nadvanced form of \u201cliquid democracy.\u201d Neurons that vote automatically still receive their full\nshare of the voting reward, as they enable the IC community to reach decisions securely and\nquickly.\nThe following graph depicts annua lized voting rewards as a function of the staking time as of\nNovember 1, 2022. For current estimates of annua lized voting rewards, refer to the IC\nDashboard\u2019s Governance page.25.09.2023, 21:22 Tokenomics of the Internet Computer | Internet Computer\nhttps://internetcomputer .org/how-it-works/tokenomics/ 3/5\nCycles as fuel for computation\nICP can be used to pay for the usage of the IC. More speci\u0000cally, ICP tokens can be converted\nto cycles (i.e., burned), and these cycles are used by developers to pay for installing smart\ncontracts, called \u201ccanisters\u201d on the IC, for the resources that canisters use (storage, CPU, and\nbandwidth). The cycle price is pegged to a basket of \u0000at currencies, so the conversion rate ICP\nto cycle \u0000uctuates with the market price of ICP. Hence the cost to developers of acquiring fuel\nto run their application is predictable.\nIn the \"reverse gas model\" of the IC, developers pre-pay costs by loading canisters with\ncomputation cycles. As a consequence, users can interact with a decentralized application\n(dapp) without having to pay in tokens. Since cycles are stable in cost, developers know in\nadvance how much they will need to spend on computation & storage.25.09.2023, 21:22 Tokenomics of the Internet Computer | Internet Computer\nhttps://internetcomputer .org/how-it-works/tokenomics/ 4/5Node provider rewards\nICP tokens are used to pay the node providers\u2014these are the entities that own and operate the\ncomputing nodes that host the IC. Node provider rewards are paid via newly minted ICP and\ncomputed on a monthly basis for each node individually. The amount per node depends on two\nparameters: First, the location of the node, as hosting prices di\u0000er between locations. Second,\nthe type of the node, i.e., the hardware and connectivity speci\u0000cations.\nTo cover the investment & runni ng cost of nodes, which occur in \u0000at currency terms, node\nprovider rewards are speci\u0000ed in XDR, and are converted into ICP based on the average\nexchange rate over the last 30 days.\nInvesting in the IC ecosystem\nThe IC provides a plug & play solution for developers to transfer control of their dapps over to a\nDecentralized Autonomous Organization (DAO) and raise funds.\nAs part of a so-called decentralization swap, users can commit some ICP to a new DAO. In\nreturn, when the decentralization swap is complete, these users will receive tokens of the DAO\nwith everyone paying the same price. Developers can specify a time period and minimum &\nmaximum funding target of ICP to be collected, which determines when the sale is over.\nThe ICP funds raised by the decentralization swap are retained within the reserves of the fully\nautonomous DAO, rather than being forwarded to the original developers of the dapp or service.\nThese funds can be used to pay for future computation needs of the dapp and also to pay code\nbounties for future dapp enhancements.\nInvestments via decentralization swaps in DAOs act like rocket fuel for the IC ecosystem. It\nprovides easy and transparent access to exciting Web3 projects and channels funds to\nproductive usage of the platform.\nDevelopment of total supply\nThe IC has in\u0000ationary and de\u0000ationary mechanisms. Governance participants can convert\nvoting rewards to newly minted ICP. Also, node providers receive rewards in the form of newly\nminted ICP tokens. On the other hand, ICP is converted to cycles (i.e., burned) in order to pay for\ncomputation and storage. This is depicted in the following picture.25.09.2023, 21:22 Tokenomics of the Internet Computer | Internet Computer\nhttps://internetcomputer .org/how-it-works/tokenomics/ 5/5\n",
  "whitepaper.pdf": "The Internet Computer for Geeks\n(v1.3)\nThe DFINITY Team\u2217\nApril 19, 2022\nAbstract\nSmart contracts are a new form of software that will revolutionize how software is\nwritten, IT systems are maintained, and applications and whole businesses are built.\nSmart contracts are composable and autonomous pieces of software that run on decen-\ntralized blockchains, which makes them tamperproof and unstoppable. In this paper,\nwe describe the Internet Computer (IC), which is a radical new design of blockchain\nthat unleashes the full potential of smart contracts, overcoming the limitations of smart\ncontracts on traditional blockchains with respect to speed, storage costs, and compu-\ntational capacity. This allows smart contracts for the \frst time to implement fully\ndecentralized applications that are hosted end to end on blockchain. The IC consists\nof a set of cryptographic protocols that connects independently operated nodes into a\ncollection of blockchains. These blockchains host and execute \\canisters\", the IC's form\nof smart contracts. Canisters can store data, perform very general computations on\nthat data, and provide a complete technology stack, serving web pages directly to end\nusers. Computational and storage costs are covered by a \\reverse-gas model\", where\ncanister developers pre-pay costs in cycles that are obtained from ICP, the native token\nof the IC. ICP tokens are also used for governance: the IC is governed by a decentralized\nautonomous organization, or DAO, which, among other things, determines changes to\nthe topology of the network and upgrades to the protocol.\n1 Introduction\n1.1 Unleashing smart contracts\nBecause of their unique features, smart contracts are the key enabler of Web3, the new\napproach to the web where applications are fully controlled by their users and run on\ndecentralized blockchain platforms. Such decentralized applications (dapps) are typically\ntokenized, meaning tokens are distributed to users as rewards for participating in the dapps.\nParticipation can come in many di\u000berent forms, ranging from moderating and providing\ncontent to governing a dapp and to creating and maintaining a dapp. Usually, tokens\ncan also be bought on exchanges; indeed, selling tokens is a common way to \fnance dapp\ndevelopment. Finally, tokens are also used as a form of payment for the services or contents\na dapp o\u000bers. Smart contracts running on today's blockchain platforms, including all the\n\u2217https://dfinity.org/foundation/ ; contact author: Victor Shoup, victor.shoup@dfinity.org .\n1popular ones (such as Ethereum), su\u000ber from many limitations, such as high transaction and\nstorage costs, slow computational speed, and the inability to serve frontends to users. As\na result, many popular blockchain applications are not fully decentralized but are hybrids\nwhere most of the application is hosted on traditional cloud platforms and call out to smart\ncontracts on a blockchain for a small part of their overall functionality. Unfortunately, this\nrenders such applications non-decentralized, and opens them to many of the drawbacks of\ntraditional cloud-hosted applications, such as being at the mercy of cloud providers, and\nbeing vulnerable to many single points of failure.\nTheInternet Computer (IC) is a new platform for executing smart contracts .\nHere, we use the term \\smart contract\" in a very broad sense: a general-purpose ,tam-\nperproof computer program whose execution is performed autonomously on a decentralized\npublic network .\n\u2022Bygeneral purpose , we mean that the class of smart contract programs is Turing\ncomplete (i.e., anything computable can be computed by a smart contract).\n\u2022Bytamperproof , we mean that the instructions of the program are carried out faithfully\nand that intermediate and \fnal results are accurately stored and/or transmitted.\n\u2022Byautonomous , we mean that a smart contract is executed automatically by the\nnetwork, without the need for any action on the part of any individual.\n\u2022By a decentralized public network , we mean a network of computers that is publicly\naccessible, geographically distributed, and not under the control of a small number of\nindividuals or organizations.\nIn addition, smart contracts\n\u2022arecomposable , meaning that they may interact with one another, and\n\u2022support tokenization , meaning that they may use and trade digital tokens.\nCompared to existing smart contract platforms, the IC is designed to:\n\u2022bemore cost e\u000bective , in particular, allowing applications to compute and store data\nat a fraction of the cost of previous platforms;\n\u2022provide higher throughput and lower latency for processing smart contract transac-\ntions;\n\u2022bemore scalable , in particular, the IC can process unbounded volumes of smart con-\ntract data and computation natively because it can grow in capacity by adding more\nnodes to the network.\nAnother property that smart contracts may have is immutability , which means that,\nonce deployed, the code of a smart contract cannot be changed by a party unilaterally.\nWhile this feature is essential in some applications, it is not required in all applications,\nand can also be problematic if a smart contract has a bug that needs to be \fxed. The IC\nallows a range of mutability policies for smart contracts, ranging from purely immutable to\nunilaterally upgradable, with other options in between.\n2In addition to providing a smart contract platform, the IC is designed to act as a\ncomplete technology stack , such that systems and services can be built that run entirely on\nthe IC. In particular, smart contracts on the IC can service HTTP requests created by end\nusers, so that smart contracts can directly serve interactive web experiences. This means\nthat systems and services can be created without relying on corporate cloud hosting services\nor private servers, thus providing all of the bene\fts of smart contracts in a true end-to-end\nfashion.\nRealizing the vision of Web3. For end-users, accessing IC-based services is largely\ntransparent. Their personal data is more secure than when accessing applications on a\npublic or private cloud, but the experience of interacting with the application is the same.\nFor the people creating and managing those IC-based services, however, the IC elimi-\nnates many of the costs, risks, and complexities associated with developing and deploying\nmodern applications and microservices. For example, the IC platform provides an alterna-\ntive to the consolidation driven by large technology companies that are monopolizing the\nInternet. In addition, its secure protocol guarantees reliable message delivery, transparent\naccountability, and resilience without relying on \frewalls, backup facilities, load balancing\nservices, or failover orchestration.\nBuilding the IC is about restoring the Internet to its open, innovative, and creative roots\n| in other words, to realize the vision of Web3 . To focus on a few speci\fc examples, the\nIC does the following:\n\u2022Supports interoperability, shared functions, permanent APIs, and ownerless applica-\ntions, all of which reduce platform risk and encourages innovation and collaboration.\n\u2022Persists data automatically in memory, which eliminates the need for database servers\nand storage management, improves computational e\u000eciency, and simpli\fes software\ndevelopment.\n\u2022Simpli\fes the technology stack that IT organizations need to integrate and manage,\nwhich improves operational e\u000eciency\n1.2 High level view of the Internet Computer\nTo a \frst approximation, the IC is a network of interacting replicated state machines .\nThe notion of a replicated state machine is a fairly standard concept in distributed systems\n[Sch90], but we give a brief introduction here, beginning with the notion of a state machine .\nAstate machine is a particular model of computation. Such a machine maintains a\nstate , which corresponds to main memory or other forms of data storage in an ordinary\ncomputer. Such a machine executes in discrete rounds : in each round, it takes an input ,\napplies a state transition function to the input and the current state , obtaining an\noutput and a new state . The new state becomes the current state in the next round.\nThe state transition function of the IC is a universal function , meaning that some\nof the inputs and data stored in the state may be arbitrary programs which act on other\ninputs and data. Thus, such a state machine represents a general (i.e., Turing complete)\nmodel of computation.\n3To achieve fault tolerance , the state machine may be replicated . A replicated state\nmachine comprises a subnet ofreplica s, each of which is running a copy of the same state\nmachine. A subnet should continue to function | and to function correctly | even if some\nreplicas are faulty .\nIt is essential that each replica in a subnet processes the same inputs in the same order.\nTo achieve this, the replicas in a subnet must run a consensus protocol [Fis83], which\nensures that all replicas in a subnet process inputs in the same order. Therefore, the internal\nstate of each replica will evolve over time in exactly the same way, and each replica will\nproduce exactly the same sequence of outputs. Note that an input to a replicated state\nmachine on the IC may be an input generated by an external user, or an output generated\nby another replicated state machine. Similarly, an output of a replicated state machine may\nbe either an output directed to an external user, or an input to another replicated state\nmachine.\n1.3 Fault Models\nIn the distributed systems area of computer science, one typically considers two types of\nreplica failures: crash faults andByzantine faults . Acrash fault occurs when a replica\nabruptly stops and does not resume. Byzantine faults are failures in which a replica may\ndeviate in an arbitrary way from its prescribed protocol. Moreover, with Byzantine faults,\none or possibly several replicas may be directly under the control of a malicious adversary\nwho may coordinate the behavior of these replicas. Of the two types of faults, Byzantine\nfaults are potentially far more disruptive.\nProtocols for consensus and for realizing replicated state machines typically make as-\nsumptions about how many replicas may be faulty and to what degree (crash or Byzan-\ntine) they may be faulty. In the IC, the assumption is that if a given subnet has nreplicas,\nthen less than n=3 of these replicas are faulty and these faults may be Byzantine. (Note\nthat the di\u000berent subnets in the IC may have di\u000berent sizes.)\n1.4 Communication Models\nProtocols for consensus and for implementing replicated state machines also typically make\nassumptions about the communication model , which characterizes the ability of an ad-\nversary to delay the delivery of messages between replicas. At opposite ends of the spectrum,\nwe have the following models:\n\u2022In the synchronous model , there exists some known \fnite time bound \u000e, such that\nfor any message sent, it will be delivered in less than time \u000e.\n\u2022In the asynchronous model , for any message sent, the adversary can delay its\ndelivery by any \fnite amount of time, so that there is no bound on the time to deliver\na message.\nSince the replicas in an IC-subnet are typically distributed around the globe, the syn-\nchronous communication model would be highly unrealistic. Indeed, an attacker could\n4compromise the correct behavior of the protocol by delaying honest replicas or the commu-\nnication between them. Such an attack is generally easier to mount than gaining control\nover and corrupting an honest replica.\nIn the setting of a globally distributed subnet, the most realistic and robust model\nis the asynchronous model. Unfortunately, there are no known consensus protocols in\nthis model that are truly practical (more recent asynchronous consensus protocols, as in\n[MXC+16], attain reasonable throughput, but not very good latency). So like most other\npractical Byzantine fault tolerant systems that do not rely on synchronous communication\n(e.g., [CL99, BKM18, YMR+18]), the IC opts for a compromise: a partial synchrony\ncommunication model [DLS88]. Such partial synchrony models can be formulated in various\nways. The partial synchrony assumption used by the IC says, roughly speaking, that for\neach subnet, communication among replicas in that subnet is periodically synchronous for\nshort intervals of time; moreover, the synchrony bound \u000edoes not need to be known in\nadvance. This partial synchrony assumption is only needed to ensure that the consensus\nprotocol makes progress (the so-called liveness property). The partial synchrony assumption\nis not needed to ensure correct behavior of consensus (the so-called safety property), nor is\nit needed anywhere else in the IC protocol stack.\nUnder the assumption of partial synchrony and Byzantine faults, it is known that our\nbound off <n= 3 on the number of faults is optimal.\n1.5 Permission Models\nThe earliest protocols for consensus (e.g., PBFT [CL99]) were permissioned , in the sense\nthat the replicas comprising a replicated state machine are governed by a centralized or-\nganization, which determines which entities provide replicas, the topology of the network,\nand possibly also implements some kind of centralized public-key infrastructure. Permis-\nsioned consensus protocols are typically the most e\u000ecient, and while they do avoid a single\npoint of failure, the centralized governance is undesirable for certain applications, and it is\nantithetical to the spirit of the burgeoning Web3 era.\nMore recently, we have seen the rise of permissionless consensus protocols, such as\nBitcoin [Nak08], Ethereum [But13], and Algorand [GHM+17]. Such protocols are based\non ablockchain and either a proof of work (PoW) (e.g., Bitcoin, Ethereum prior to\nv2.0) or a proof of stake (PoS) (e.g., Algorand, Ethereum v2.0) . While such protocols\nare completely decentralized, they are much less e\u000ecient than permissioned protocols. We\nalso point out that, as observed in [PSS17], PoW-based consensus protocols such as Bitcoin\ncannot guarantee correctness (i.e., safety) in an asynchronous communication network.\nThe IC's permission model is a hybrid model , obtaining the e\u000eciency of a permissioned\nprotocol while o\u000bering many of the bene\fts of a decentralized PoS protocol. This hybrid\nmodel is called a DAO-controlled network and (roughly speaking) works as follows:\neach subnet runs a permissioned consensus protocol, but a decentralized autonomous\norganization (DAO) determines which entities provide replicas, con\fgures the topology of\nthe network, provides a public-key infrastructure, and controls which version of the protocol\nis deployed to the replicas. The IC's DAO is called the network nervous system (NNS) ,\nand is based on a PoS, so that all decisions taken by the NNS are made by community\nmembers whose voting power is determined by how much of the IC's native governance\n5token they have staked in the NNS (see Section 1.8 for more in this token). Through this\nPoS-based governance system, new subnets can be created, replicas may be added to or\nremoved from existing subnets, software updates may be deployed, and other modi\fcations\nto the IC may be e\u000bected. The NNS is itself a replicated state machine, which (like any\nother) runs on a particular subnet whose membership is determined via the same PoS-based\ngovernance system. The NNS maintains a database called the registry , which keeps track\nof the topology of the IC: which replicas belong to which subnets, the public keys of the\nreplicas, and so on. (See Section 1.10 for a few more details on the NNS.)\nThus, one sees that the IC's DAO-controlled network allows the IC to achieve many of\nthe practical bene\fts of a permissioned network (in terms of more e\u000ecient consensus), while\nmaintaining many of the bene\fts of a decentralized network (with governance controlled by\na DAO).\nThe replicas running the IC protocol are hosted on servers in geographically distributed,\nindependently operated data centers. This also bolsters the security and decentralized\nnature of the IC.\n1.6 Chain-key cryptography\nThe IC's consensus protocol does, in fact, use a blockchain, but it also uses public-key\ncryptography, speci\fcally, digital signatures: the registry maintained by the NNS is used\nto bind public keys to replicas and subnets as a whole. This enables a unique and pow-\nerful collection of technologies that we call chain-key cryptography , which has several\ncomponents.\n1.6.1 Threshold signatures\nThe \frst component of chain-key cryptography is threshold signatures : this is a well es-\ntablished cryptographic technique that allows a subnet to have a public signature-veri\fcation\nkey whose corresponding secret signing key is split into shares , which are distributed among\nall of the replicas in a subnet in such a way that the shares held by the corrupt replicas\ndo not let them forge any signatures, while the shares held by the honest replicas allow the\nsubnet to generate signatures consistent with the policies and protocols of the IC.\nOne critical application of these threshold signatures is that\nan individual output of one subnet may be veri\fed by another subnet or external\nuser by simply validating a digital signature with respect to the public signature-\nveri\fcation key of the (\frst) subnet.\nNote that the public signature-veri\fcation key for a subnet may be obtained from the NNS\n| this public signature-veri\fcation key remains constant over the lifetime of a subnet (even\nas the membership of a subnet may change over that lifetime). This stands in contrast to\nmany non-scalable blockchain-based protocols, which require the entire blockchain to be\nvalidated in order to validate any single output.\nAs we will see, these threshold signatures have a number of other applications within\nthe IC. One such application is to give each replica in a subnet access to unpredictable\npseudorandom bits (derived from such signatures). This is the basis for the Random\nBeacon used in consensus and the Random Tape used in execution.\n6In order to securely deploy threshold signatures, the IC uses an innovative distributed\nkey generation (DKG) protocol that constructs a public signature-veri\fcation key and\nprovisions each replica with a share of the corresponding secret signing key, and works\nwithin our fault and communication model.\n1.6.2 Chain-evolution technology\nChain-key cryptography also includes a sophisticated collection of technologies for robustly\nand securely maintaining a blockchain based replicated state machine over time, which\ntogether form what we call chain-evolution technology . Each subnet operates in epochs\nof many rounds (typically on the order of a few hundreds of rounds). Using threshold\nsignatures and a number of other techniques, chain-evolution technology implements many\nessential maintenance activities that are executed periodically with a cadence that is tied\nto epochs:\nGarbage collection: At the end of each epoch, all inputs that have been processed, and all\nconsensus-level protocol messages needed to order those inputs, may safely be purged\nfrom the memory of each replica. This is essential in keeping the storage requirements\nfor the replicas from growing without bound. This is in contrast to many non-scalable\nblockchain-based protocols, where the entire blockchain from the genesis block must\nbe stored.\nFast forwarding: If a replica in a subnet falls very far behind its peers (because it is\ndown or disconnected from the network for a long time), or a new replica is added to\na subnet, it can be fast forwarded to the beginning of the most recent epoch, without\nhaving to run the consensus protocol and process all of the inputs up to that point.\nThis is in contrast to many non-scalable blockchain-based protocols, where the entire\nblockchain from the genesis block must be processed.\nSubnet membership changes: The membership of the subnet (as determined by the\nNNS, see Section 1.5) may change over time. This can only happen at an epoch\nboundary, and needs to be done with care to ensure consistent and correct behavior.\nPro-active resharing of secrets: We mentioned above in Section 1.6.1 how the IC uses\nchain-key cryptography | speci\fcally, threshold signatures | for output veri\fcation.\nThis is based on secret sharing , which avoids any single point of failure by splitting\nup a secret (in this case, a secret signing key) into shares that are stored among the\nreplicas. At the beginning of each epoch, these shares are pro-actively reshared .\nThis achieves two goals:\n\u2022When the membership of a subnet changes, the resharing will ensure that any\nnew members have an appropriate share of the secret, while any replicas that\nare no longer members no longer have a share of the secret.\n\u2022If a small number of shares are leaked to an attacker in any one epoch, or even\ninevery epoch, those shares will not do an attacker any good.\n7Protocol upgrades: When the IC protocol itself needs to be upgraded, to \fx bugs or add\nnew features, this can be done automatically using a special protocol at the beginning\nof an epoch.\n1.7 Execution Models\nAs already mentioned, replicated state machines in the IC can execute arbitrary programs.\nThe basic computational unit in the IC is called a canister , which is roughly the same as\nthe notion of a process , in that it comprises both a program and its state (which changes\nover time).\nCanister programs are encoded in WebAssembly , orWasm for short, which is a binary\ninstruction format for a stack-based virtual machine. Wasm is an open standard.1While it\nwas initially designed to enable high-performance applications on web pages, it is actually\nvery well suited to general-purpose computation.\nThe IC provides a run-time environment for executing Wasm programs in a canister, and\nto communicate with other canisters and external users (via message passing). While, in\nprinciple, one can write a canister program in any language that may be compiled to Wasm,\na language called Motoko has been designed that is well aligned with the operational se-\nmantics of the IC. Motoko is a strongly typed, actor-based2programming language with\nbuilt-in support for orthogonal persistence3and asynchronous message passing . Orthogo-\nnal persistence simply means that all memory maintained by a canister is automatically\npersisted (i.e., it does not have to be written to a \fle). Motoko has a number of productiv-\nity and safety features, including automatic memory management, generics, type inference,\npattern matching, and both arbitrary and \fxed-precision arithmetic.\nIn addition to Motoko, the IC also provides a messaging interface de\fnition language\nand wire format called Candid , for typed, high-level, and cross-language interoperability.\nThis allows any two canisters, even if written in di\u000berent high-level languages, to easily\ncommunicate with one another.\nTo fully support canister development in any given programming language, besides a\nWasm compiler for that language, certain run-time support must also be provided. At the\npresent time, in addition to Motoko, the IC also fully supports canister development in the\nRust programming language.\n1.8 Utility token\nThe IC makes use of a utility token called ICP. This token is used for the following\nfunctions:\nStaking in the NNS: As already discussed in Section 1.5, ICP tokens may be staked in\nthe NNS to acquire voting rights so as to participate in the DAO that controls the\nIC network. Users that have ICP tokens staked in the NNS and who participate in\n1Seehttps://webassembly.org/ .\n2Seehttps://en.wikipedia.org/wiki/Actor_model .\n3See https://en.wikipedia.org/wiki/Persistence_(computer_science)#Orthogonal_or_\ntransparent_persistence .\n8the NNS governance also receive newly minted ICP tokens as a voting reward . The\namount of the award is determined by policies established and enforced by the NNS.\nConversion to Cycles: ICP is used to pay for the usage of the IC. More speci\fcally, ICP\ntokens can be converted to cycles (i.e., burned ), and these cycles are used to pay for\ncreating canisters (see Section 1.7) and for the resources that canisters use (storage,\nCPU, and bandwidth). The rate at which ICP is converted to cycles is determined\nby the NNS.\nPayment to Node Providers: ICP tokens are used to pay the node providers|these\nare the entities that own and operate the computing nodes that host the replicas that\nmake up the IC. At regular intervals (currently monthly), the NNS decides on the\nnumber of newly minted tokens that each node provider should receive, and sends the\ntokens to the node provider's account. Payment of tokens is conditioned on providing\nreliable service to the IC, according to speci\fc policies established and enforced by\nthe NNS.\n1.9 Boundary Nodes\nBoundary nodes provide the network edge services of the IC. In particular, they o\u000ber\n\u2022clearly de\fned entry points to the IC,\n\u2022denial of service protection for the IC,\n\u2022seamless access to the IC from legacy clients (e.g., web browsers).\nTo facilitate seamless access to the IC from a legacy client, boundary nodes provide func-\ntionality to translate a standard HTTPS request from a user to an ingress message directed\ntoward a canister on the IC, and then route this ingress message to speci\fc replicas on the\nsubnet where this canister resides. Furthermore, boundary nodes o\u000ber additional services\nto improve the user experience: caching, load balancing, rate limiting, and the ability for\nlegacy clients to authenticate responses from the IC.\nA canister is identi\fed by a URL on the ic0.app domain. Initially, a legacy client looks\nup the corresponding DNS record for the URL, obtains an IP address of a boundary node,\nand then sends an initial HTTPS request to this address. The boundary node returns a\njavascript-based \\service worker\" that will be executed in the legacy client. After this, all\ninteractions between the legacy client and the boundary node will be done via this service\nworker.\nOne of the essential tasks carried out by the service worker is to authenticate responses\nfrom the IC using chain-key cryptography (see Section 1.6). To do this, the public veri\fca-\ntion key for the NNS is hard-coded in the service worker.\nThe boundary node itself is responsible for routing requests to a replica on the subnet\non which the speci\fed canister is hosted. The information needed to perform this routing is\nobtained by the boundary node from the NNS. The boundary node keeps a list with replicas\nthat provide timely replies and selects a random replica from this list.\n9All communication between legacy clients and boundary nodes and between boundary\nnodes and replicas is secured via TLS.4\nIn addition to legacy clients, it is also possible to interact with boundary nodes using \\IC\nnative\" clients, which already include the service-worker logic, and do not need to retrieve\nthe service worker program from the boundary node.\nJust as for replicas, the deployment and con\fguration of boundary nodes is controlled\nby the NNS.\n1.10 More details of the NNS\nAs already mentioned in Section 1.5, the network nervous system (NNS) is an algorithmic\ngovernance system that controls the IC. It is realized by a set of canisters on a special sys-\ntem subnet . This subnet is like any other subnet, but is con\fgured somewhat di\u000berently\n(as one example, canisters on the system subnet are not charged for the cycles they use).\nSome of the most relevant NNS canisters are\n\u2022theregistry canister , which stores the con\fguration of the IC, i.e., which repli-\ncas belong to which subnet, the public keys associated with subnets and individual\nreplicas, and so on.\n\u2022thegovernance canister , which manages the decision making and voting on how\nthe IC should be evolved, and\n\u2022theledger canister , which keeps track of the users' ICP utility token accounts and\nthe transactions between them.\n1.10.1 Decision making on the NNS\nAnyone can participate in NNS governance by staking ICP tokens in so-called neurons .\nNeuron holders can then suggest and vote on proposals , which are suggestions on how the\nIC should be changed, e.g., how the subnet topology or the protocol should be changed. The\nneurons' voting power for decision making is based on proof of stake. Intuitively, neurons\nwith more staked ICP tokens have more voting power. However, the voting power also\ndepends on some other neuron characteristics, e.g., more voting power is given to neuron\nholders that are committed to keep their tokens staked for a longer period of time.\nEach proposal has a determined voting period. A proposal is adopted if at the voting\nperiod's end, a simple majority of the total voting power has voted in favor of the proposal\nand these Yes-votes constitute a given quorum (currently 3%) of the total voting power.\nOtherwise, the proposal is rejected . In addition, a proposal is adopted or rejected at any\npoint if an absolute majority (more than half of the total voting power) is in favor or against\nthe proposal, respectively.\nIf a proposal is adopted, the governance canister automatically executes the decision.\nFor example, if a proposal suggests changing the network topology and is adopted, the\ngovernance canister automatically updates the registry with the new con\fgurations.\n4Seehttps://en.wikipedia.org/wiki/Transport_Layer_Security .\n10Figure 1: The layers of the Internet Computer Protocol\n1.11 Work in progress\nThe architecture of the IC is still evolving and expanding. Here are a few new features that\nwill be deployed soon:\nDAO-controlled canisters. Just like the overall con\fguration of the IC is controlled by\nthe NNS, any canister may also be controlled by its own DAO, called the service\nnervous system (SNS) . The DAO controlling a canister can control updates to the\ncanister logic, as well as issuing privileged commands to be carried out by the canister.\nThreshold ECDSA. ECDSA signatures [JMV01] are used in cryptocurrencies, such as\nBitcoin and Ethereum, as well as in many other applications. While threshold signa-\ntures are already an essential ingredient in the IC, these are not threshold ECDSA\nsignatures. This new feature will allow individual canisters to control an ECDSA sign-\ning key, which is securely distributed among all of the replicas on the subnet hosting\nthe canister.\nBitcoin and Ethereum integration. Building on the new threshold ECDSA feature,\nthis feature will allow canisters to interact with the Bitcoin and Ethereum blockchains,\nincluding the ability to sign transactions.\nHTTP integration. This feature will allow canisters to read arbitrary web pages (external\nto the IC).\n2 Architecture overview\nAs illustrated in Figure 1, the Internet Computer Protocol consists of four layers:\n\u2022peer-to-peer layer (see Section 4);\n\u2022consensus layer (see Section 5);\n\u2022routing layer (see Section 6);\n11\u2022execution layer (see Section 7).\nChain-key cryptography impacts several layers, and is discussed in detail in Sections 3\n(threshold signatures) and 8 (chain-evolution technology).\n2.1 Peer-to-peer layer\nThe peer-to-peer layer's task is to transport protocol messages between the replicas in a\nsubnet. These protocol messages consist of\n\u2022messages used to implement consensus,\n\u2022input messages generated by an external user.\nBasically, the service provided by the peer-to-peer is a \\best e\u000bort\" broadcast channel:\nif an honest replica broadcasts a message, then that message will eventually be\nreceived by all honest replicas in the subnet.\nDesign goals include the following:\n\u2022Bounded resources. All algorithms must work with bounded resources (memory,\nbandwidth, CPU).\n\u2022Prioritization. Di\u000berent messages may be treated with di\u000berent priorities, depend-\ning on certain attributes (e.g., type, size, round), and these priorities may change over\ntime.\n\u2022E\u000eciency. High throughput is more important than low latency.\n\u2022DOS/SPAM resilience. Corrupt replicas should not prevent honest replicas from\ncommunicating with one another.\n2.2 Consensus layer\nThe job of the consensus layer of the IC is to order inputs so that all replicas in a subnet\nwill process such inputs in the same order. There are many protocols in the literature for\nthis problem. The IC uses a new consensus protocol, which is described here at a high level.\nAny secure consensus protocol should guarantee two properties, which (roughly stated)\nare:\n\u2022safety : all replicas in fact agree on the same ordering of inputs, and\n\u2022liveness : all replicas should make steady progress.\nThe IC consensus protocol is designed to be\n\u2022extremely simple, and\n\u2022robust: performance degrades gracefully when some replicas are malicious.\n12As discussed above, we assume f <n= 3 faulty (i.e., Byzantine) replicas. Also, liveness\nholds under a partial synchrony assumption, while safety is guaranteed, even in a completely\nasynchronous network.\nLike a number of consensus protocols, the IC consensus protocol is based on a blockchain.\nAs the protocol progresses, a tree of blocks is grown, starting from a special genesis block\nthat is the root of the tree. Each non-genesis block in the tree contains (among other\nthings) a payload , consisting of a sequence of inputs, and a hash of the block's parent in\nthe tree. The honest replicas have a consistent view of this tree: while each replica may\nhave a di\u000berent, partial view of this tree, all the replicas have a view of the same tree. In\naddition, as the protocol progresses, there is always a path of \fnalized blocks in this tree.\nAgain, the honest replicas have a consistent view of this path: while each replica may have\na di\u000berent, partial view of this path, all the replicas have a view of the same path. The\ninputs in the payloads of the blocks along this path are the ordered inputs will be processed\nby the execution layer of the Internet Computer.\nThe protocol proceeds in rounds . In round hof the protocol, one or more blocks of\nheighthare added to the tree. That is, the blocks added in round hare always at a distance\nof exactlyhfrom the root. In each round, a pseudo-random process is used to assign each\nreplica a unique rank , which is an integer in the range 0 ;:::;n\u00001. This pseudo-random\nprocess is implemented using a Random Beacon (this makes use of threshold signatures,\nmentioned above in Section 1.6.1 and discussed in more detail in Section 3). The replica\nof lowest rank is the leader of that round. When the leader is honest and the network is\nsynchronous, the leader will propose a block, which will be added to the tree; moreover,\nthis will be the only block added to the tree in this round and it will extend the \fnalized\npath. If the leader is not honest or the network is not synchronous, some other replicas\nof higher rank may also propose blocks, and also have their blocks added to the tree. In\nany case, the logic of the protocol gives highest priority to the leader's proposed block\nand some block or blocks will be added to this tree in this round. Even if the protocol\nproceeds for a few rounds without extending the \fnalized path, the height of the tree will\ncontinue to grow with each round, so that when the \fnalized path is extended in round h,\nthe \fnalized path will be of length h. A consequence of this, even if the latency occasionally\nincreases because of faulty replicas or unexpectedly high network latency, the throughput of\nthe protocol remains essentially constant.\nThe consensus protocol relies on digital signatures to authenticate messages sent between\nreplicas. To implement the protocol, each replica is associated with a public veri\fcation\nkey for a signature scheme. The association of replicas to public keys is obtained from the\nregistry maintained by the NNS.\n2.3 Message routing\nAs discussed in Section 1.7, basic computational unit in the IC is called a canister . The IC\nprovides a run-time environment for executing programs in a canister, and to communicate\nwith other canisters and external users (via message passing).\nThe consensus layer bundles inputs into payloads , which get placed into blocks , and\nas blocks are \fnalized, the corresponding payloads are delivered to the message routing\nlayer, then processed by the execution environment , which updates the state of the\n13canisters on the replicated state machine and generates outputs, and these outputs are\nprocessed by the message routing layer.\nIt is useful to distinguish between two types of inputs:\ningress messages: these are messages from external users;\ncross-subnet messages: these are messages from canisters on other subnets.\nWe can also distinguish between two types of outputs:\ningress message responses :these are responses to ingress messages (which may be re-\ntrieved by external users);\ncross-subnet messages: these are messages to canisters on other subnets.\nUpon receiving a payload from consensus, the inputs in that payload are placed into\nvarious input queues . For each canister Crunning on a subnet, there are several input\nqueues | there is one queue speci\fcally for ingress messages to C, and each other canister\nC0, with whom Ccommunicates, gets its own queue. (In the case where C0is not located\non the same subnet as C, these are cross-subnet messages.) In each round, the execution\nlayer will consume some of the inputs in these queues, update the replicated state of the\nrelevant canisters, and place outputs in various output queues . For each canister C\nrunning on a subnet, there are several output queues | each other canister C0, with whom\nCcommunicates, gets its own queue. (In the case where C0is not located on the same\nsubnet asC, these are cross-subnet messages.) The message routing layer will take the\nmessages in these output queues and place them into subnet-to-subnet streams to be\nprocessed by a crossnet transfer protocol , whose job it is to actually transport these\nmessages to other subnets.\nIn addition to these output queues, there is also an ingress history data structure.\nOnce an ingress message has been processed by a canister, a response to that ingress\nmessage will be recorded in this data structure. At that point, the external user who\nprovided the ingress message will be able to retrieve the corresponding response. (Note\nthat ingress history does not maintain the full history of all ingress messages.)\nNote that the replicated state comprises the state of the canisters, as well as \\system\nstate\", including the above-mentioned queues and streams, as well as the ingress history data\nstructure. Thus, both the message routing and execution layers are involved in updating\nand maintaining the replicated state of a subnet. It is essential that all of this state is\nupdated in a completely deterministic fashion, so that all replicas maintain exactly the\nsame state.\nAlso note that the consensus layer is decoupled from the message routing and execution\nlayers, in the sense that any forks in the consensus blockchain are resolved before their\npayloads are passed to message routing, and in fact, consensus does not have to keep in\nlock step with message routing and consensus and is allowed to run a bit ahead.\n2.3.1 Per-round certi\fed state\nIn each round, some of the state of a subnet will be certi\fed . The per-round certi\fed\nstate is certi\fed using chain-key cryptography. Among other things, the certi\fed state in\na given round consists of\n14\u2022cross-subnet messages that were recently added to the subnet-to-subnet streams;\n\u2022other metadata, including the ingress history data structure.\nTheper-round certi\fed state is certi\fed using a threshold signature (see Section 1.6.1).\nPer-round certi\fed state is used in several ways in the IC:\n\u2022Output authentication. Cross-subnet messages and responses to ingress messages are\nauthenticated using per-round certi\fed state.\n\u2022Preventing and detecting non-determinism. Consensus guarantees that each replica\nprocesses inputs in the same order. Since each replica processes these inputs determin-\nistically, each replica should obtain the same state. However, the IC is designed with\nan extra layer of robustness to prevent and detect any (accidental) non-deterministic\ncomputation, should it arise. The per-round certi\fed state is one of the mechanisms\nused to do this.\n\u2022Coordination with consensus. The per-round certi\fed state is also used to coordinate\nthe execution and consensus layers, in two di\u000berent ways:\n{If consensus is running ahead of execution (whose progress is determined by the\nlast round whose state is certi\fed), consensus will be \\throttled\".\n{Inputs to consensus must pass certain validity checks, and these validity checks\nmay depend on certi\fed state, which all replicas must agree upon.\n2.3.2 Query calls vs update calls\nAs we have described it so far, ingress messages must pass through consensus so that\nthey are processed in the same order by all replicas on a subnet. However, an important\noptimization is available to those ingress messages whose processing does not modify the\nreplicated state of a subnet. These are called query calls | as opposed to other ingress\nmessages, which are called update calls . Query calls are allowed to perform computations\nwhich read and possibly update the state of a canister, but any updates to the state of a\ncanister are never committed to the replicated state. As such, a query call may be processed\ndirectly by a single replica without passing through consensus, which greatly reduces the\nlatency for obtaining a response from a query call.\nIn general, a response to a query call is not recorded in the ingress history data structure,\nand therefore cannot be authenticated using the per-round certi\fed state mechanism as\ndescribed above. However, the IC makes it possible for canisters to store data (while\nprocessing update calls) in special certi\fed variables , which canbe authenticated by this\nmechanism; as such, query calls that return as their value a certi\fed variable can still be\nauthenticated.\n2.3.3 External user authentication\nOne of the main di\u000berences between an ingress message and a cross-subnet message is the\nmechanism used for authenticating these messages. While chain-key cryptography is used\n15to authenticate cross-subnet messages, a di\u000berent mechanism is used to authenticate ingress\nmessages from external users.\nThere is no central registry for external users. Rather, an external user identi\fes himself\nto a canister using a user identi\fer (aka principal ), which is a hash of a public signature-\nveri\fcation key. The user holds a corresponding secret signing key, which is used to sign\ningress messages. Such a signature, as well as the corresponding public key, is sent along\nwith the ingress message. The IC automatically authenticates the signature and passes the\nuser identi\fer to the appropriate canister. The canister may then authorize the requested\noperation, based on the user identi\fer and other parameters to the operation speci\fed in\nthe ingress message.\nFirst-time users generate a key pair and derive their user identi\fer from the public key\nduring their \frst interaction with the IC. Returning users are authenticated using the secret\nkey that is stored by the user agent. A user may associate several key pairs with a single\nuser identity, using signature delegation. This is useful, as it allows a single user to access\nthe IC from several devices using the same user identity.\n2.4 Execution layer\nThe execution layer processes one input at a time. This input is taken from one of the\ninput queues, and is directed to one canister. Based on this input and the state of the\ncanister, the execution environment updates the state of the canister, and additionally may\nadd messages to output queues and update the ingress history (possibly with a response to\nan earlier ingress message).\nEach subnet has access to a distributed pseudorandom generator (PRG) . Pseudo-\nrandom bits are derived from a seed that itself is a threshold signature called the Random\nTape (see Section 1.6.1 and more detail in Section 3). There is a di\u000berent Random Tape\nfor each round of the consensus protocol.\nThe basic properties of the random tape are:\n1. Before a block at height his \fnalized by any honest replica, the Random Tape at\nheighth+ 1 is guaranteed to be unpredictable.\n2. By the time block at height h+ 1 is \fnalized by any honest replica, that replica will\ntypically have all the shares it needs to construct the Random Tape at height h+ 1.\nTo obtain pseudorandom bits, a subnet must make a request for these bits via a \\system\ncall\" from the execution layer in some round, say h. The system will then respond to that\nrequest later, using the Random Tape at height h+1. By property (1) above, it is guaranteed\nthat the requested pseudorandom bits are unpredictable at the time the request is made.\nConsensus will actually deliver to message routing both the Random Tape and payload at\nh+ 1 at the same time; by property (2) above, this will typically not incur any additional\ndelay.\n2.5 Putting it all together\nWe trace through the typical \row to process a user request on the IC.\n16Query call\n1. A user's query call Mto a canister Cis sent by the user's client to a boundary node\n(see Section 1.9), and the boundary node sends Mto a replica on the subnet that\nhosts canister C. After receiving M, this replica will compute the response and send\nit back to the user via the boundary node.\nUpdate call\n1. A user's request Mto a canister Cis sent by the user's client to a boundary node (see\nSection 1.9), and the boundary node sends Mto a replica on the subnet that hosts\ncanisterC.\n2. After receiving M, this replica will broadcast Mto all other replicas on the subnet,\nusing the peer-to-peer layer (see Section 2.1).\n3. Having received M, the leader for the next round of consensus (see Section 2.2) will\nbundleMwith other inputs to form the payload for a block Bthat the leader proposes.\n4. Some time later, block Bis \fnalized and the payload is sent to the message routing\nlayer (see Section 2.3) for processing. Note that the peer-to-peer layer is also used by\nconsensus to \fnalize this block.\n5. The message routing layer will place Min the input queue of the canister C.\n6. Some time later, the execution layer (see Section 2.4) will process M, updating the\ninternal state of the canister C.\nIn some situations, the canister Cwill be able to immediately compute a response R\nto the request M. In this case, Ris placed in the ingress history data structure.\nIn other situations, processing the request Mmay require making a request to another\ncanister. In this example, let us suppose that to process this particular request M,\nthe canister Cmust make a request M0to another canister C0that resides on another\nsubnet. This second request M0will be placed in the output queue of C, and then\nthe following steps are performed.\n7. Some time later, message routing will move M0into an appropriate cross-subnet\nstream, and this will eventually be transported to the subnet hosting C0.\n8. On the second subnet, the request M0will be obtained from the \frst subnet, and\neventually pass through consensus and message routing on the second subnet and\nthen be processed by execution. The execution layer will update the internal state of\ncanisterC0and generate a response R0to the request M0. The response R0will go\nin the output queue of canister C0, and eventually be placed in a cross-subnet stream\nand transported back to the \frst subnet.\n9. Back on the \frst subnet, the response R0will be obtained from the second subnet,\nand eventually pass through consensus and message routing on the \frst subnet and\nthen be processed by execution. The execution layer will update the internal state\n17of canister Cand generate a response Rto the original request message M. This\nresponse will be recorded in the ingress history data structure.\nRegardless of which execution path is taken, the response Rto requestMwill eventually\nbe recorded in the ingress history data structure on the subnet that hosts canister C. To\nobtain this response, the user's client must perform a kind of \\query call\" (see Section 2.3.2).\nAs discussed in Section 2.3.1, this response will be authenticated via chain-key cryptography\n(speci\fcally, using a threshold signature). The authentication logic itself (i.e., threshold\nsignature veri\fcation) will be performed by the client using the service worker originally\nobtained by the client from the boundary node.\n3 Chain-key crytography I: threshold signatures\nA critical component of the IC's chain-key cryptography is a threshold signature scheme\n[Des87]. The IC uses threshold signatures for a number of purposes. Let nbe the number\nof replicas in a subnet and let fbe a bound on the number of corrupt replicas.\n\u2022The Consensus Layer makes use of an ( f+ 1)-out-of- nthreshold signature to realize\narandom beacon (see Section 5.5).\n\u2022The Execution Layer makes use of an ( f+ 1)-out-of- nthreshold signature to realize\narandom tape , which is used to provide unpredictable pseudorandom numbers to\ncanisters (see Section 7.1).\n\u2022The Execution Layer makes use of an ( n\u0000f)-out-of-nthreshold signature to certify\nthe replicated state . This is used both to authenticate the outputs of a subnet (see\nSection 6.1) and to implement the fast-forwarding feature of the IC's chain-evolution\ntechnology (see Section 8.2).\nFor the \frst two applications (the random beacon and random tape), it is essential that\nthe threshold signatures are unique , i.e., for a given public key and message, there is only\none valid signature. This is required as we use the signature as a seed to a pseudorandom\ngenerator, and all replicas who compute such a threshold signature must agree on the same\nseed.\n3.1 Threshold BLS signatures\nWe implement threshold signatures based on the BLS signature scheme [BLS01], which is\ntrivial to adapt to the threshold setting.\nThe ordinary (i.e., non-threshold) BLS signature scheme makes use of two groups, G\nandG0, both of prime order q. We assume that Gis generated by g2GandG0is generated\nbyg02G0. We also assume a hash function HG0that maps its inputs to G0(and which is\nmodeled as a random oracle). The secret signing key is an element x2Zqand the public\nveri\fcation key is V:=gx2G.\nIn the non-threshold setting, to sign a message m, the signer computes h0 HG0(m)2\nG0and then computes the signature \u001b:= (h0)x2G0. To verify that such a signature is valid,\none must test if logh0\u001b= loggV. To be able to perform this test e\u000eciently, the BLS scheme\n18uses the notion of a pairing on the groups GandG0, which is an algebraic operation that\nis available when GandG0areelliptic curves of a special type. We shall not be able to\ngo into the details of pairings and elliptic curves here. See [BLS01] for more details. BLS\nsignatures have the nice property (mentioned above) that signatures are unique.\nIn thet-out-of-nthreshold setting, we have nreplicas, any tof which may be used\nto generate a signature on a message. In somewhat more detail, each replica Pjholds\na sharexj2Zqof the secret signing key x2Zq, which is privately held by Pj, while\nthe group element Vj:=gxjis publicly available. The shares ( x1;:::;xn) are at-out-of-n\nsecret-sharing of x(see Section 3.4).\nGiven a message m, replicaPjcan generate a signature share\n\u001bj:= (h0)xj2G0;\nwhereh0:=HG0(m) as before. To verify that such a signature share is valid, one must\ntest if logh0\u001bj= loggVj. Computing the discrete logarithms is intractable, but this can\nbe checked using a pairing | in fact, this is exactly the same as the validity test for an\nordinary BLS signature with public key Vj.\nThis scheme satis\fes the following reconstruction property :\nGiven any collection of tvalid signature shares \u001bjon a message m(contributed\nby distinct replicas), we can e\u000eciently compute a valid BLS signature \u001bonm\nunder the public veri\fcation key.\nIn fact,\u001bcan be computed as\n\u001b Y\nj\u001b\u0015j\nj; (1)\nwhere the\u0015j's can be e\u000eciently computed just from the indices of the tcon-\ntributing replicas.\nUnder reasonable intractability assumptions for G, and modeling HG0as a random\noracle, this scheme satis\fes the following security property :\nAssume that at most freplicas may be corrupted by an adversary. Then it is\ninfeasible for the adversary to compute a valid signature on a message unless it\nobtains signature shares on that message from at least t\u0000fhonest replicas.\n3.2 Distributed key distribution\nTo implement threshold BLS, we need a way to distribute the shares of the secret signing\nkey to the replicas. One way to do this would be to have a trusted party compute all\nof these shares directly and distribute them to all the replicas. Unfortunately, this would\ncreate a single point of failure. Instead, we use a distributed key generation (DKG)\nprotocol , which allows the replicas to essentially carry out the logic of such a trusted party\nusing a secure distributed protocol.\nWe sketch the high level ideas of the protocol currently implemented. We refer the\nreader to [Gro21] for more details. The DKG protocol used is essentially non-interactive.\nIt uses two essential ingredients:\n19\u2022apublicly veri\fable secret sharing (PVSS) scheme, and\n\u2022aconsensus protocol.\nAlthough any consensus protocol could be used, not surprisingly, the one we use is that in\nSection 5 (see also Section 8).\n3.3 Assumptions\nThe basic assumptions made are the same as outlined in Section 1:\n\u2022asynchronous communication, and\n\u2022f <n= 3.\nWe only indirectly make use of a partial synchrony assumption (as in Section 5.1) to ensure\nthat the consensus protocol attains liveness.\nWe also assume that for a t-out-of-nthreshold signature scheme, we have\nf <t\u0014n\u0000f;\nwhich (among other things) ensures that (1) the corrupt replicas cannot sign all by them-\nselves, and (2) the honest replicas can sign all by themselves.\nWe also assume that every replica is associated with some public keys, where each replica\nalso holds the corresponding private key. One public key is the signing key (the same one\nas in Section 5.4). Another public key is a public encryption key for a speci\fc public-key\nencryption scheme needed to implement the PVSS scheme (details follow).\n3.4 PVSS scheme\nLetGbe the group of prime order qgenerated by g2Gintroduced above. Let s2Zqbe\na secret. Recall that a t-out-of-nShamir secret-sharing of sis a vector ( s1;:::;sn)2Zn\nq,\nwhere\nsj:=a(j) (j= 1;:::;n ):\nand\na(x):=a0+a1x+\u0001\u0001\u0001+at\u00001xt\u000012Zq[x]\nis a polynomial of degree less than twitha0:=s. The key properties of such a secret\nsharing are\n\u2022from any collection of tof thesj's, we can e\u000eciently compute (via polynomial inter-\npolation) the secret s=a0=a(0), and\n\u2022ifa1;:::;at\u00001are chosen uniformly and independently over Zq, then any collection of\nfewer than tof thesj's reveals no information about the secret s.\nAt a high level, a PVSS scheme allows one replica, Pi, called the dealer , to take such\na sharing, and compute an object called a dealing , which contains\n\u2022a vector of group elements ( A0;:::;At\u00001), whereAk:=gakfork= 0;:::;t\u00001,\n20\u2022a vector of ciphertexts ( c1;:::;cn), wherecjis the encryption of sjunderPj's public\nencryption key,\n\u2022a non-interactive zero-knowledge proof \u0019that eachcjdoes indeed encrypt such a\nshare | more precisely, that each cjdecrypts the value sjsatisfying\ngsj=t\u00001Y\nk=0Ajk\nk=ga(j): (2)\nWe note that to establish the overall security of our DKG protocol, the PVSS scheme\nmust provide an appropriate level of chosen ciphertext security. Speci\fcally, the dealer\nmust embed its identity as associated data in the dealing, and the encrypted shares must\nremain hidden, even under a chosen ciphertext attack wherein an adversary is allowed to\ndecrypt arbitrary dealings which are decrypted under associated data that is distinct from\nthe associated data used to create the dealing.\nIt is easy to realize a PVSS scheme, if one is not too concerned about e\u000eciency. The\nidea is to use an ElGamal-like encryption scheme to encrypt each sjbit by bit, and then\nuse a standard non-interactive zero-knowledge proof for the relation (2), which would be\nbased on a standard application of the Fiat-Shamir transform (see [FS86]) to an appropriate\nSigma protocol (see [CDS94]). While this yields a polynomial-time scheme, it is not that\npractical. However, there are many possible ways to optimize this type of scheme. See\n[Gro21] for the details on the highly optimized PVSS scheme used in the IC.\n3.5 The basic DKG protocol\nUsing the PVSS scheme and a consensus protocol, the basic DKG protocol is very simple.\n1. Each replica broadcasts a signed dealing of a random secret to all other replicas.\nSuch a signed dealing includes a dealing, along with the identity of the dealer and a\nsignature on the dealing under the dealer's public signing key.\nSuch a signed dealing is called valid if it has the right syntactic form, and the signature\nand non-interactive zero knowledge proof are valid.\n2. Using consensus the replicas agree on a set Soff+ 1 valid signed dealings (from\ndistinct dealers).\n3. Suppose that the ith dealing in the set Scontains the vector of group elements\n(Ai;0;:::;Ai;t\u00001) and the vector of ciphertexts ( ci;1;:::;ci;n).\nThen the public veri\fcation key for the threshold signature scheme is\nV:=Y\niAi;0:\nNote that the secret signing key is implicitly de\fned as\nx:= loggV:\n21Pj's share of the secret signing key xis\nxj:=X\nisi;j;\nwheresi;jis the decryption of ci;junderPj's secret decryption key.\nThe public veri\fcation key for replica Pjis\nVj:=Y\nit\u00001Y\nk=0Ajk\ni;k=gxj:\nNote that the shares xjcomprise a t-out-of-nShamir secret-sharing of x. As such, the\n\u0015jvalues appearing in (1) are just Lagrange interpolation coe\u000ecients. This establishes\nthereconstruction property stated in Section 3.1. As for the security property stated in\nSection 3.1, this can be proved to hold modeling HG0as a random oracle, and assuming\nthat the PVSS scheme is secure, and that the groups GandG0(with a pairing) satisfy a\ncertain type of one-more Di\u000ee-Hellman hardness assumption, which can be stated as\nsaying that no e\u000ecient adversary can win the following game with non-negligible probability:\nThe challenger chooses \u00161;:::;\u0016k2Zqand\u00171;:::;\u0017`2Zqat random, and gives\nfg\u0016igk\ni=1andf(g0)\u0017jg`\nj=1to the adversary.\nThe adversary makes a sequence of queries to the challenger, each of which is a\nvector of the form f\u0014i;jgi;j, to which the challenger responds with\nY\ni;j\u0010\n(g0)\u0016i\u0017j\u0011\u0014i;j:\nTo end the game, the adversary outputs a vector f\u0015i;jgi;jand a group element\nh02G0, and wins the game if\nh0=Y\ni;j\u0010\n(g0)\u0016i\u0017j\u0011\u0015i;j\nand the output vector f\u0015i;jgi;jis not a linear combination of the query vectors.\nWhile this type of one-more Di\u000ee-Hellman assumption is needed in the case where\nt>f + 1, one can get by with a weaker assumption when t=f+ 1 (the so-called co-CDH\nassumption, on which the security of the ordinary BLS scheme is based).\n3.6 A resharing protocol\nThe basic DKG protocol can be easily modi\fed so that instead of creating a sharing of a\nfresh random secret x, it instead creates a fresh, random sharing of a previously shared\nsecret.\n\u2022Step 1 of the basic protocol is modi\fed so that each replica broadcasts a signed dealing\nof its existing share.\n22\u2022Step 2 is modi\fed so that a set of tvalid signed dealings is agreed upon. Also, each\ndealing is veri\fed to ensure that it is indeed a dealing of the appropriate existing share\n(this means that the value of Ai;0in theith dealing should be equal to the old value\nofVi).\n\u2022In Step 3, the computation of the new xj(andVj) values weight the sum (and product)\noniLagrange interpolation coe\u000ecients.\n4 Peer-to-peer layer\nThe peer-to-peer layer's task is to transport protocol messages between the replicas in a\nsubnet. These protocol messages consist of\n\u2022messages used to implement consensus, e.g., block proposals, notarizations, etc. (see\nSection 5);\n\u2022ingress messages (see Section 6).\nBasically, the service provided by the peer-to-peer is a \\best e\u000bort\" broadcast channel:\nif an honest replica broadcasts a message, then that message will eventually be\nreceived by all honest replicas in the subnet.\nDesign goals include the following:\n\u2022Bounded resources. All algorithms must work with bounded resources (memory,\nbandwidth, CPU).\n\u2022Prioritization. Di\u000berent messages may be treated with di\u000berent priorities, depend-\ning on certain attributes (e.g., type, size, round), and these priorities may change over\ntime.\n\u2022E\u000eciency. High throughput is more important than low latency.\n\u2022DOS/SPAM resilience. Corrupt replicas should not prevent honest replicas from\ncommunicating with one another.\nObserve that in the consensus protocol, some messages, notably block proposals (which\ncan be quite large), will be rebroadcast by all replicas. This is necessary to ensure correct\nbehavior of that protocol. However, if implemented naively, this would be a huge waste\nof resources. To avoid having all replicas broadcasting the same message, the peer-to-peer\nlayer makes use of an advertise-request-deliver mechanism. Instead of broadcasting a\n(large) message directly, it will instead broadcast a (small) advertisement for the message:\nif a replica receives such an advertisement, has not already received, and deems the message\nto be important, it will request that the message is delivered . This strategy decreases\nbandwidth utilization at the cost of higher latency. For small messages, this trade-o\u000b is\nnot worthwhile, and it makes more sense to just send the message directly, rather than an\nadvertisement.\n23For relatively small subnets, a replica that wishes to broadcast a message will send an\nadvertisement to all replicas in the subnet, each of which may then request that the message\nis delivered. For larger subnets, this advertise-request-deliver mechanism may operate over\nanoverlay network . An overlay network is a connected, undirected graph whose vertices\ncomprise the replicas in a subnet. Two replicas are peers if there is an edge connecting\nthem in this graph, and a replica only communicates with its peers. So when a replica\nwishes to broadcast a message, it sends an advertisement for that message to its peers.\nThose peers may request that the message be delivered, and upon receiving the message,\nif certain conditions are met, those peers will advertise the message to their peers. This is\nessentially a gossip network . This strategy again decreases bandwidth utilization at the\ncost of even higher latency.\n5 Consensus Layer\nThe job of the consensus layer of the IC is to order inputs so that all replicas in a subnet\nwill process such inputs in the same order. There are many protocols in the literature for\nthis problem. The IC uses a new consensus protocol, which is described here at a high level.\nFor more details, see the paper [CDH+21] (in particular, Protocol ICC1 in that paper).\nAny secure consensus protocol should guarantee two properties, which (roughly stated)\nare:\n\u2022safety : all replicas in fact agree on the same ordering of inputs, and\n\u2022liveness : all replicas should make steady progress.\nThe paper [CDH+21] proves that the IC consensus protocol satis\fes both of these prop-\nerties\nThe IC consensus protocol is designed to be\n\u2022extremely simple, and\n\u2022robust: performance degrades gracefully when some replicas are malicious.\n5.1 Assumptions\nAs discussed in the introduction, we assume\n\u2022a subnet of nreplicas, and\n\u2022at mostf <n= 3 of the replicas are faulty.\nFaulty replicas may exhibit arbitrary, malicious (i.e., Byzantine) behavior.\nWe assume that communication is asynchronous , with no a priori bound on the delay\nof messages sent between replicas. In fact, the scheduling of message delivery may be\ncompletely under adversarial control. The IC consensus protocol guarantees safety under\nthis very weak communication assumption. However, to guarantee liveness, we need to\nassume a form of partial synchrony , which (roughly stated) says that the network will\nbe periodically synchronous for short intervals of time. In such intervals of synchrony, all\n24undelivered messages will be delivered in less than time \u000e, for some \fxed bound \u000e. The\nbound\u000edoes not have to be known in advance (the protocol is initialized with a reasonable\nbound, but will dynamically adapt and increase this bound if it is too small). Regardless of\nwhether we are assuming an asynchronous or a partially synchronous network, we assume\nthat every message sent from one honest replica to another will eventually be delivered.\n5.2 Protocol overview\nLike a number of consensus protocols, the IC consensus protocol is based on a blockchain.\nAs the protocol progresses, a tree of blocks is grown, starting from a special genesis block\nthat is the root of the tree. Each non-genesis block in the tree contains (among other\nthings) a payload , consisting of a sequence of inputs, and a hash of the block's parent in\nthe tree. The honest replicas have a consistent view of this tree: while each replica may\nhave a di\u000berent, partial view of this tree, all the replicas have a view of the same tree. In\naddition, as the protocol progresses, there is always a path of \fnalized blocks in this tree.\nAgain, the honest replicas have a consistent view of this path: while each replica may have\na di\u000berent, partial view of this path, all the replicas have a view of the same path. The\ninputs in the payloads of the blocks along this path are the ordered inputs will be processed\nby the execution layer of the Internet Computer (see Section 7).\nThe protocol proceeds in rounds . In round hof the protocol, one or more blocks of\nheighthare added to the tree. That is, the blocks added in round hare always at a\ndistance of exactly hfrom the root. In each round, a pseudo-random process is used to\nassign each replica a unique rank , which is an integer in the range 0 ;:::;n\u00001. This\npseudo-random process is implemented using a random beacon (see Section 5.5 below).\nThe replica of lowest rank is the leader of that round. When the leader is honest and the\nnetwork is synchronous, the leader will propose a block, which will be added to the tree;\nmoreover, this will be the only block added to the tree in this round and it will extend the\n\fnalized path. If the leader is not honest or the network is not synchronous, some other\nreplicas of higher rank may also propose blocks, and also have their blocks added to the\ntree. In any case, the logic of the protocol gives highest priority to the leader's proposed\nblock and some block or blocks will be added to this tree in this round. Even if the protocol\nproceeds for a few rounds without extending the \fnalized path, the height of the tree will\ncontinue to grow with each round, so that when the \fnalized path is extended in round h,\nthe \fnalized path will be of length h. A consequence of this, even if the latency occasionally\nincreases because of faulty replicas or unexpectedly high network latency, the throughput of\nthe protocol remains essentially constant.\n5.3 Additional properties\nAn additional property enjoyed by the IC consensus protocol (just like PBFT [CL99] and\nHotStu\u000b [YMR+18], and unlike others, such as Tendermint [BKM18]) is optimistic respon-\nsiveness [PS18], which means that when the leader is honest, the protocol may proceed at\nthe pace of the actual network delay, rather than some upper bound on the network delay.\nWe note that the simple design of the IC consensus protocol also ensures that its per-\nformance degrades quite gracefully when and if Byzantine failures actually do occur. As\npointed out in [CWA+09], much of the recent work on consensus has focused so much\n25on improving the performance in the \\optimistic case\" where there are no failures, that\nthe resulting protocols are dangerously fragile, and may become practically unusable when\nfailures do occur. For example, [CWA+09] show that the throughput of existing implemen-\ntations of PBFT drops to zero under certain types of (quite simple) Byzantine behavior.\nThe paper [CWA+09] advocates for robust consensus, in which peak performance under\noptimal conditions is partially sacri\fced in order to ensure reasonable performance when\nsome parties actually are corrupt (but still assuming the network is synchronous). The IC\nconsensus protocols is indeed robust in the sense of [CWA+09]: in any round where the\nleader is corrupt (which itself happens with probability less than 1 =3), the protocol will\ne\u000bectively allow another party to take over as leader for that round, with very little fuss,\nto move the protocol forward to the next round in a timely fashion.\n5.4 Public keys\nTo implement the protocol, each replica is associated with a public key for the BLS signature\nscheme [BLS01], and each replica also holds the corresponding secret signing key. The\nassociation of replicas to public keys is obtained from the registry maintained by the NNS\n(see Section 1.5). These BLS signatures will be used to authenticate messages sent by\nreplicas.\nThe protocol also uses the signature aggregation feature of BLS signatures [BGLS03],\nwhich allows many signatures on the same message to be aggregated into a compact multi-\nsignature. The protocol will use these multi-signatures for notarizations (see Section 5.7)\nand\fnalizations (see Section 5.8), which are aggregations of n\u0000fsignatures on messages\nof a certain form.\n5.5 Random Beacon\nIn addition to BLS signatures and multi-signatures as discussed above, the protocol makes\nuse of a BLS threshold signature scheme to implement the above-mentioned random beacon.\nThe random beacon for height his a (f+ 1)-threshold signature on a message unique to\nheighth. In each round of the protocol, each replica broadcasts its share of the beacon for\nthe next round, so that when the next round begins, all replicas should have enough shares\nto reconstruct the beacon for that round. As discussed above, the random beacon at height\nhis used to assign a pseudo-random rank to each replica that will be used in round hof\nthe protocol. Because of the security properties of the threshold signature, an adversary\nwill not be able to predict the ranking of the replicas more than one round in advance,\nand these rankings will e\u000bectively be as good as random. See Section 3 for more on BLS\nthreshold signatures.\n5.6 Block making\nEach replica may at di\u000berent points in time play the role of a block maker . As a block\nmaker in round h, the replica proposes a block Bof heighththat to be child of a block B0\nof heighth\u00001 in the tree of blocks. To do this, the block maker \frst gathers together a\npayload consisting of all inputs it knows about (but not including those already included\nin payloads in blocks in the path through the tree ending at B0). The block Bconsists of\n26\u2022the payload,\n\u2022the hash of B0,\n\u2022the rank of the block maker,\n\u2022the heighthof the block.\nAfter forming the block B, the block maker forms a block proposal , consisting of\n\u2022the blockB,\n\u2022the block maker's identity, and\n\u2022the block maker's signature on B.\nA block maker will broadcast its block proposal to all other replicas.\n5.7 Notarization\nA block is e\u000bectively added to the tree of blocks when it becomes notarized . For a block\nto become notarized, n\u0000fdistinct replicas must support its notarization.\nGiven a proposed block Bat heighth, a replica will determine if the proposal is valid ,\nwhich means that Bhas the syntactic form described above. In particular, Bshould\ncontain the hash of a block B0of heighth0that is already in the tree of blocks (i.e., already\nnotarized). In addition, the payload of Bmust satisfy certain conditions (in particular,\nall of the inputs in the payload must satisfy various constraints, but these constraints are\ngenerally independent of the consensus protocol). Also, the rank of the block maker (as\nrecorded in the block B) must match the rank assigned in round hby the random beacon\nto the replica that proposed the block (as recorded in the block proposal) .\nIf the block is valid and certain other constraints hold, the replica will support the\nnotarization of the block by broadcasting a notarization share forB, consisting of\n\u2022the hash of B,\n\u2022the heighthofB,\n\u2022the identity of the supporting replica, and\n\u2022the supporting replica's signature on a message comprising the hash of Band the\nheighth.\nAny set ofn\u0000fnotarization shares on Bmay be aggregated together to form a nota-\nrization forB, consisting of\n\u2022the hash of B,\n\u2022the heighthofB,\n\u2022the set of identities of the n\u0000fsupporting replicas,\n27\u2022an aggregation of the n\u0000fsignatures on the message comprising the hash of Band\nthe heighth.\nAs soon as a replica obtains a notarized block of height h, it will \fnish round h, and will\nsubsequently not support the notarization of any other blocks at height h. At this point\nin time, such a replica will also relay this notarization to all other replicas . Note that this\nreplica may have obtained the notarization either by (1) receiving it from another replica,\nor (2) aggregating n\u0000fnotarization shares that it has received.\nThegrowth invariant states that each honest replica will eventually complete each\nround and start the next, so that the tree of notarized blocks continues to grow (and this\nholds only assuming asynchronous eventual delivery, and not partial synchrony). We prove\nthe growth invariant below (see Section 5.11.4).\n5.8 Finalization\nThere may be more than one notarized block at a given height h. However, if a block is\n\fnalized , then we can be sure that there is no other notarized block at height h. Let us\ncall this the safety invariant .\nFor a block to become \fnalized, n\u0000fdistinct replicas must support its \fnalization.\nRecall that round hends for a replica when it obtains a notarized block Bof heighth. At\nthat point in time, such a replica will check if it supported the notarization of any block\nat heighthother than block B(it may or may not have supported the notarization of B\nitself). If not, the replica will support the \fnalization of Bby broadcasting a \fnalization\nshare forB. A \fnalization share has exactly the same format as a notarization share\n(but is tagged in such a way notarization shares and \fnalization shares cannot be confused\nwith one another). Any set of n\u0000f\fnalization shares on Bmay be aggregated together\nto form a \fnalization forB, which has exactly the same format as a notarization (but\nagain, is appropriately tagged). Any replica that obtains a \fnalized block will broadcast\nthe \fnalization to all other replicas.\nWe prove the safety invariant below (see Section 5.11.5). One consequence of the safety\ninvariant is the following. Suppose two blocks BandB0are \fnalized, where Bhas heighth,\nB0has heighth0\u0014h. Then the safety invariant implies that the path in the tree of notarized\nblocks ending at B0is a pre\fx of the path ending at B(if not, then there would be two\nnotarized blocks at height h0, contradicting the \fnalization invariant). Thus, whenever\na replica sees a \fnalized block B, it may view all ancestors of Bas being implicitly\n\fnalized , and because of the safety invariant, the safety property is guaranteed to hold for\nthese (explicitly and implicitly) \fnalized blocks | that is, all replicas agree on the ordering\nof these \fnalized blocks.\n5.9 Delay functions\nThe protocol makes use of two delay functions , \u0001mand \u0001 n, which control the timing\nof block making and notarization activity. Both of these functions map the rank rof the\nproposing replica to a nonnegative delay amount, and it is assumed that each function\nis monotonely increasing in r, and that \u0001 m(r)\u0014\u0001n(r) for allr= 0;:::;n\u00001. The\nrecommended de\fnition of these functions is \u0001 m(r) = 2\u000erand \u0001 n(r) = 2\u000er+\u000f, where\u000eis\n2830 Rank 0N\u202631 Rank 131 Rank 2NN32 Rank 0N33 Rank 0N34 Rank 1N35 Rank 0N36 Rank 0N\n34 Rank 2N37 Rank 0FNFigure 2: An example tree of blocks\nan upper bound on the time to deliver messages from one honest replica to another, and\n\u000f\u00150 is a \\governor\" to keep the protocol from running too fast. With these de\fnitions,\nliveness will be ensured in those rounds in which (1) the leader is honest, and (2) messages\nreally are delivered between honest replicas within time \u000e. Indeed, if (1) and (2) both hold\nin a given round, then the block proposed by the leader in that round will be \fnalized. Let\nus call this the liveness invariant . We prove this below (see Section 5.11.6).\n5.10 An example\nFigure 2 illustrates a block tree. Each block is labeled with its height (30, 31, 32, . . . ) and\nthe rank of its block maker. The \fgure also shows that each block in the tree is notarized,\nas indicated by the \u0006Nsymbol. This means that for each notarized block in the tree, at least\nn\u0000fdistinct replicas supported its notarization. As one can see, there can be more than\none notarized block in the tree at a given height. For example, at height 31, we see there are\ntwo notarized blocks, proposed by block makers of rank 1 and 2. The same thing happens\nat height 34. We can also see that the block at height 36 is also explicitly \fnalized, as\nindicated by the \u0006Fsymbol. This means that n\u0000fdistinct replicas supported this block's\n\fnalization, which means that these replicas (or at least, the honest replicas among these)\ndid not support the notarization of any other block. All of the ancestors of this block, which\nare shaded gray, are considered implicitly \fnalized.\n5.11 Putting it all together\nWe now describe in more detail how the protocol works; speci\fcally, we describe more\nprecisely when a replica will propose a block and when a replica will support the notarization\nof a block. A given replica Pwill record the time at which it enters a given round h, which\nhappens when it has obtained (1) some notarization for a block of height h\u00001, and (2) the\nrandom beacon for round h. Since the random beacon for round hhas been determined, P\ncan determine its own rank rP, as well as the rank rQof each other replica Qfor roundh.\n295.11.1 Random beacon details\nAs soon as a replica has received the random beacon for round h, or enough shares to\ncontruct the random beacon for round h, it will relay the random beacom for round hto all\nother replicas . As soon as a replica enters round h, it will generate and broadcast its share\nof the random beacon at round h+ 1.\n5.11.2 Block making details\nReplicaPwill only propose its own block BPprovided (1) at least \u0001 m(rP) time units\nhave passed since the beginning of the round, and (2) there is no valid lower ranked block\ncurrently seen by P.\nNote that since Pis guaranteed to have a notarized block of height h\u00001 when it\nenters round h, it can make its proposed block a child of this notarized block (or any other\nnotarized block of height h\u00001 that it may have). Also note that when pbroadcasts its\nproposal for BP, it must also ensure that it also has relayed the notarization of BP's parent\nto all replicas .\nSuppose a replica Qsees a valid block proposal from a replica Pof rankrP<rQsuch\nthat (1) at least \u0001 m(rP) time units have passed since the beginning of the round, and (2)\nthere is no block of rank less than rPcurrently seen by Q. Then at this point in time, if it\nhas not already done so, Qwillrelay this block proposal (along with the notarization of the\nproposed block's parent) to all other replicas .\n5.11.3 Notarization details\nReplicaPwill support the notarization of a valid block BQproposed by a replica Qof rank\nrQprovided (1) at least \u0001 n(rQ) time units have passed since the beginning of the round,\nand (2) there is no block of rank less than rQcurrently seen by P.\n5.11.4 Proof of growth invariant\nThe growth invariant states that each honest replica will eventually complete each round\nand start the next. Assume that all honest replicas have started round h. Letr\u0003be the rank\nof the lowest ranked honest replica P\u0003in roundh. Eventually, P\u0003will either (1) propose\nits own block, or (2) relay a valid block proposed by a lower ranked replica. In either case,\nsome block must eventually be supported by all honest replicas, which means that some\nblock will become notarized and all honest replicas will \fnish round h. All honest replicas\nwill also receive the shares needed to construct the random beacon for round h+ 1, and so\nwill start round h+ 1.\n5.11.5 Proof of safety invariant\nThesafety invariant states that if a block is \fnalized in a given round, then no other\nblock may be notarized in that round. Here is a proof of the safety invariant:\n1. Suppose that the number of corrupt replicas is exactly f\u0003\u0014f <n= 3.\n302. If a block Bis \fnalized, then its \fnalization must have been supported by a set Sof\nat leastn\u0000f\u0000f\u0003honest replicas (by the security property for aggregate signatures).\n3. Suppose (by way of contradiction) that another block B06=Bwere notarized. Then\nits notarization must have been supported by a set S0of at leastn\u0000f\u0000f\u0003honest\nreplicas (again, by the security property for aggregate signatures).\n4. The sets SandS0are disjoint (by the \fnalization logic).\n5. Therefore, n\u0000f\u0003\u0015jS[S0j=jSj+jS0j\u00152(n\u0000f\u0000f\u0003), which implies n\u00143f, a\ncontradiction.\n5.11.6 Proof of liveness invariant\nWe say that the network is \u000e-synchronous at time tif all messages that have been sent\nby honest replicas at or before time tarrive at their destinations before time t+\u000e.\nTheliveness invariant may be stated as follows. Suppose that \u0001 n(1)\u0015\u0001m(0) + 2\u000e.\nAlso suppose that in a given round h, we have\n\u2022the leaderPin roundhis honest,\n\u2022the \frst honest replica Qto enter round hdoes so at time t, and\n\u2022the network is \u000e-synchronous at times tandt+\u000e+ \u0001 m(0).\nThen the block proposed by Pin roundhwill be \fnalized.\nHere is a proof of the liveness invariant:\n1. Under partial synchrony at time t, all honest replicas will enter round hbefore time\nt+\u000e(the notarization that ended round h\u00001 forQas well as the random beacon for\nroundhrandom will arrive at all honest replicas before this time).\n2. The leader Pin roundhwill propose a block Bbefore time t+\u000e+ \u0001 m(0), and again\nby partial synchrony, this block proposal will be delivered to all other replicas before\ntimet+ 2\u000e+ \u0001 m(0).\n3. Since \u0001 n(1)\u0015\u0001m(0) + 2\u000e, the protocol logic guarantees that each honest replica\nsupports the notarization of block Band no other block, and thus Bwill become\nnotarized and \fnalized.\n5.12 Other issues\n5.12.1 Growth latency\nUnder a partial synchrony assumption, we can also formulate and prove a quantitative\nversion of the growth invariant. For simplicity, assume that the delay functions are de\fned\nas recommended above: \u0001 m(r) = 2\u000erand \u0001 n(r) = 2\u000er+\u000f, and further assume that \u000f\u0014\u000e.\nSuppose that at time t, the highest numbered round entered by any honest replica is h. Let\nr\u0003be the rank of the lowest ranked honest replica P\u0003in roundh. Finally, suppose that\nthe network is \u000e-synchronous at all times in the interval [ t;t+ (3r\u0003+ 2)\u000e]. Then all honest\nreplicas will start round h+ 1 before time t+ 3(r\u0003+ 1)\u000e.\n315.12.2 Locally adjusted delay functions\nWhen a replica does not see any \fnalized blocks for several rounds, it will start increasing\nits own delay function \u0001 nfor notarization. Replicas need not agree on these locally adjusted\nnotarization delay functions.\nAlso, while replicas do not explicitly adjust the delay function \u0001 p, we can mathemati-\ncally model local clock drift by locally adjusting both delay functions.\nThus, there are many delay functions, parameterized by replica and round. The critical\ncondition \u0001 n(1)\u0015\u0001m(0) + 2\u000eneeded for liveness then becomes max \u0001 n(1)\u0015min \u0001 m(0) +\n2\u000e, where the max and min are taken over all the honest replicas in a given round. Thus,\nif \fnalization fails for enough rounds, all honest replicas will eventually increase their no-\ntarization delay until this holds and \fnalization will then resume. If some honest replicas\nincrease their notarization latency function more than other replicas, there is no penalty in\nterms of liveness (but there may be in terms of growth latency).\n5.12.3 Fairness\nAnother property that is important in consensus protocols is fairness . Rather than give a\ngeneral de\fnition, we simply observe that the liveness invariant also implies a useful fairness\nproperty. Recall that the liveness invariant basically says that in any round where the leader\nis honest and the network is synchronous, then the block proposed by the leader will be\n\fnalized. In those rounds where this happens, the fact that the leader is honest ensures\nthat it will include in the payload of its block all of the inputs it knows about (modulo\nlimits on the payload size). So, very roughly speaking, any input that is disseminated to\nenough replicas will be included in a \fnalized block in a reasonable amount of time with\nhigh probability.\n6 Message Routing Layer\nAs discussed in Section 1.7, basic computational unit in the IC is called a canister , which\nis roughly the same as the notion of a process , in that it comprises both a program and its\nstate. The IC provides a run-time environment for executing programs in a canister, and\nto communicate with other canisters and external users (via message passing).\nThe consensus layer (see Section 5) bundles inputs into payloads , which get placed\nintoblocks , and as blocks are \fnalized, the corresponding payloads are delivered to the\nmessage routing layer, then processed by the execution environment , which updates\nthe state of the canisters on the replicated state machine and generates outputs, and these\noutputs are processed by the message routing layer.\nIt is useful to distinguish between two types of inputs:\ningress messages: these are messages from external users;\ncross-subnet messages: these are messages from canisters on other subnets.\nWe can also distinguish between two types of outputs:\ningress message responses :these are responses to ingress messages (which may be re-\ntrieved by external users);\n32Finalized BlocksMessage Routing LayerExecution Layer\nTake inputs from \ufb01nalized blocks and put them into input queues of the respective canistersTake input messages from input  queues, execute them and put  produced messages in output queues\nCROSSNET MESSAE ROUTINGTake messages from output  queues, route them to subnet-to-subnet streams\u2026\u2026\u2026\u2026\u2026\u2026Stream to subnet 2Stream to subnet 3Stream to subnet N\u2026Canister 3Canister 1Canister 2Figure 3: Message routing and execution layers\ncross-subnet messages: these are messages to canisters on other subnets.\nUpon receiving a payload from consensus, the inputs in that payload are placed into\nvarious input queues . For each canister Crunning on a subnet, there are several input\nqueues | there is one queue speci\fcally for ingress messages to C, and each other canister\nC0, with whom Ccommunicates, gets its own queue. (In the case where C0is not located on\nthe same subnet as C, these are cross-subnet messages.) As described below in more detail,\nin a each round, the execution layer will consume some of the inputs in these queues, update\nthe replicated state of the relevant canisters, and place outputs in various output queues .\nFor each canister Crunning on a subnet, there are several output queues | each other\ncanisterC0, with whom Ccommunicates, gets its own queue. (In the case where C0is not\nlocated on the same subnet as C, these are cross-subnet messages.) The message routing\nlayer will take the messages in these output queues and place them into subnet-to-subnet\nstreams to be processed by a crossnet transfer protocol , whose job it is to actually\ntransport these messages to other subnets.\nIn addition to these output queues, there is also an ingress history data structure.\nOnce an ingress message has been processed by a canister, a response to that ingress\nmessage will be recorded in this data structure. At that point, the external user who\nprovided the ingress message will be able to retrieve the corresponding response. (Note\nthat ingress history does not maintain the full history of all ingress messages.)\nWe also should mention that in addition to cross-subnet messages, there are also intra-\nsubnet messages , which are messages from one canister to another on the same subnet .\nThe message routing layer moves such messages directly from output queues to correspond-\ning input queues.\nFigure 3 illustrates the basic functionality of the message routing and execution layers.\nNote that the replicated state comprises the the state of the canisters, as well as \\system\n33state\", including the above-mentioned queues and streams, as well as the ingress history data\nstructure. Thus, both the message routing and execution layers are involved in updating\nand maintaining the replicated state of a subnet. It is essential that all of this state is\nupdated in a completely deterministic fashion, so that all replicas maintain exactly the\nsame state.\nAlso note that the consensus layer is decoupled from the message routing and execution\nlayers, in the sense that any forks in the consensus blockchain are resolved before their\npayloads are passed to message routing, and in fact, consensus does not have to keep in\nlock step with message routing and consensus and is allowed to run a bit ahead.\n6.1 Per-round certi\fed state\nIn each round, some of the state of a subnet will be certi\fed . The per-round certi\fed\nstate is certi\fed using chain-key cryptography (see Section 1.6), speci\fcally, using the\n(n\u0000f)-out-of-nthreshold signature scheme mentioned in Section 3. In more detail, after\neach replica generates the per-round certi\fed state for a given round, it will generate a\nshare of the corresponding threshold signature and broadcast this to all other replicas in its\nsubnet. Upon collecting n\u0000fsuch shares, each replica can construct the resulting threshold\nsignature, which serves as the certi\fcate for the per-round certi\fed state for that round.\nNote that before signing, the per-round certi\fed state is hashed as a Merkle tree [Mer87].\nThe per-round certi\fed state in a given round consists of\n1.cross-subnet messages that were recently added to the subnet-to-subnet streams;\n2. other metadata, including the ingress history data structure;\n3. the Merkle-tree root hash of the per-round certi\fed state from the previous round.\nNote that the per-round certi\fed state does notinclude the entire replicated state of a\nsubnet, as this in general will be quite huge and it would be impractical to certify allof this\nstate in every round.5\nFigure 4 illustrates how the per-round certi\fed state may be organized into a tree. The\n\frst branch of the tree stores various metadata about each canister (but not the entire\nreplicated state of the canister). The second branch stores the ingress history data struc-\nture. The third branch stores information about the subnet-to-subnet streams, including\na \\window\" of recently added cross-subnet messages for each stream. The other branches\nstore other types of metadata, not discussed here. This tree structure may then be hashed\ninto a Merkle tree, which has essentially the same size and shape as this tree.\nPer-round certi\fed state is used in several ways in the IC:\n\u2022Output authentication. Cross-subnet messages and responses to ingress messages\nare authenticated using per-round certi\fed state. Using the Merkle tree structure, an\nindividual output (cross-subnet message or ingress message response) may be authen-\nticated to any party by providing a threshold signature on the root of the Merkle tree,\nalong with hash values on (and adjacent to) the path in the Merkle tree from the root\n5But see Section 8.2\n34<latexit sha1_base64=\"Azvu/MT4S372jteKUTB90Po1ZUI=\">AAAB8HicbVBNSwMxEJ34WetX1aOXYBE8ld0e1GPRi8cK9kPapWTTbBuaZJckK5Slv8KLB0W8+nO8+W/MtnvQ1gcDj/dmmJkXJoIb63nfaG19Y3Nru7RT3t3bPzisHB23TZxqylo0FrHuhsQwwRVrWW4F6yaaERkK1gknt7nfeWLa8Fg92GnCAklGikecEuukR0qU2+H8QaXq1bw58CrxC1KFAs1B5as/jGkqmbJUEGN6vpfYICPacirYrNxPDUsInZAR6zmqiGQmyOYHz/C5U4Y4irUrZfFc/T2REWnMVIauUxI7NsteLv7n9VIbXQcZV0lqmaKLRVEqsI1x/j0ecs2oFVNHCNXc3YrpmGhC8wzKLgR/+eVV0q7X/Muad1+vNm6KOEpwCmdwAT5cQQPuoAktoCDhGV7hDWn0gt7Rx6J1DRUzJ/AH6PMHKRSQow==</latexit>canisters<latexit sha1_base64=\"TqbRBfFJBrvdoh86U2e/TdMNCcA=\">AAAB+HicbVBNS8NAEN3Ur1o/GvXoZbEInkrSg3osevFYwX5AG8pmO2mXbnbD7kaIob/EiwdFvPpTvPlv3LY5aOuDgcd7M8zMCxPOtPG8b6e0sbm1vVPereztHxxW3aPjjpapotCmkkvVC4kGzgS0DTMceokCEoccuuH0du53H0FpJsWDyRIIYjIWLGKUGCsN3SoTYwVa44ndJVU2dGte3VsArxO/IDVUoDV0vwYjSdMYhKGcaN33vcQEOVGGUQ6zyiDVkBA6JWPoWypIDDrIF4fP8LlVRjiSypYweKH+nshJrHUWh7YzJmaiV725+J/XT010HeRMJKkBQZeLopRjI/E8BTxiCqjhmSWEKmZvxXRCFKHGZlWxIfirL6+TTqPuX9a9+0ateVPEUUan6AxdIB9doSa6Qy3URhSl6Bm9ojfnyXlx3p2PZWvJKWZO0B84nz81opNx</latexit>ingress history<latexit sha1_base64=\"YErPG0+eom/dIfQjd/OgkJ3DYwU=\">AAAB7nicbVDLSsNAFL2pr1pfVZduBovgqiRdqMuiG5cV7APaUCbTSTt0MgkzN0IJ/Qg3LhRx6/e482+ctFlo64GBwznnMveeIJHCoOt+O6WNza3tnfJuZW//4PCoenzSMXGqGW+zWMa6F1DDpVC8jQIl7yWa0yiQvBtM73K/+8S1EbF6xFnC/YiOlQgFo2ilrsE8bIbVmlt3FyDrxCtIDQq0htWvwShmacQVMkmN6Xtugn5GNQom+bwySA1PKJvSMe9bqmjEjZ8t1p2TC6uMSBhr+xSShfp7IrMbmVkU2GREcWJWvVz8z+unGN74mVBJilyx5UdhKgnGJL+djITmDOXMEsq0sLsSNqGaMrQNVWwJ3urJ66TTqHtXdfehUWveFnWU4QzO4RI8uIYm3EML2sBgCs/wCm9O4rw4787HMlpyiplT+APn8weiuI/C</latexit>streams\n<latexit sha1_base64=\"bzlxl0nvFr5YEoK+AGgdk5clavg=\">AAAB7XicbVBNS8NAEJ34WetX1aOXxSJ4KkkP6rHoxWMF+wFtKJvNpl27yYbdiVBC/4MXD4p49f9489+4bXPQ1gcDj/dmmJkXpFIYdN1vZ219Y3Nru7RT3t3bPzisHB23jco04y2mpNLdgBouRcJbKFDybqo5jQPJO8H4duZ3nrg2QiUPOEm5H9NhIiLBKFqp3ZehQjOoVN2aOwdZJV5BqlCgOah89UPFspgnyCQ1pue5Kfo51SiY5NNyPzM8pWxMh7xnaUJjbvx8fu2UnFslJJHSthIkc/X3RE5jYyZxYDtjiiOz7M3E/7xehtG1n4skzZAnbLEoyiRBRWavk1BozlBOLKFMC3srYSOqKUMbUNmG4C2/vEra9Zp3WXPv69XGTRFHCU7hDC7AgytowB00oQUMHuEZXuHNUc6L8+58LFrXnGLmBP7A+fwBvSWPOw==</latexit>...<latexit sha1_base64=\"bzlxl0nvFr5YEoK+AGgdk5clavg=\">AAAB7XicbVBNS8NAEJ34WetX1aOXxSJ4KkkP6rHoxWMF+wFtKJvNpl27yYbdiVBC/4MXD4p49f9489+4bXPQ1gcDj/dmmJkXpFIYdN1vZ219Y3Nru7RT3t3bPzisHB23jco04y2mpNLdgBouRcJbKFDybqo5jQPJO8H4duZ3nrg2QiUPOEm5H9NhIiLBKFqp3ZehQjOoVN2aOwdZJV5BqlCgOah89UPFspgnyCQ1pue5Kfo51SiY5NNyPzM8pWxMh7xnaUJjbvx8fu2UnFslJJHSthIkc/X3RE5jYyZxYDtjiiOz7M3E/7xehtG1n4skzZAnbLEoyiRBRWavk1BozlBOLKFMC3srYSOqKUMbUNmG4C2/vEra9Zp3WXPv69XGTRFHCU7hDC7AgytowB00oQUMHuEZXuHNUc6L8+58LFrXnGLmBP7A+fwBvSWPOw==</latexit>...\n<latexit sha1_base64=\"bzlxl0nvFr5YEoK+AGgdk5clavg=\">AAAB7XicbVBNS8NAEJ34WetX1aOXxSJ4KkkP6rHoxWMF+wFtKJvNpl27yYbdiVBC/4MXD4p49f9489+4bXPQ1gcDj/dmmJkXpFIYdN1vZ219Y3Nru7RT3t3bPzisHB23jco04y2mpNLdgBouRcJbKFDybqo5jQPJO8H4duZ3nrg2QiUPOEm5H9NhIiLBKFqp3ZehQjOoVN2aOwdZJV5BqlCgOah89UPFspgnyCQ1pue5Kfo51SiY5NNyPzM8pWxMh7xnaUJjbvx8fu2UnFslJJHSthIkc/X3RE5jYyZxYDtjiiOz7M3E/7xehtG1n4skzZAnbLEoyiRBRWavk1BozlBOLKFMC3srYSOqKUMbUNmG4C2/vEra9Zp3WXPv69XGTRFHCU7hDC7AgytowB00oQUMHuEZXuHNUc6L8+58LFrXnGLmBP7A+fwBvSWPOw==</latexit>...<latexit sha1_base64=\"bzlxl0nvFr5YEoK+AGgdk5clavg=\">AAAB7XicbVBNS8NAEJ34WetX1aOXxSJ4KkkP6rHoxWMF+wFtKJvNpl27yYbdiVBC/4MXD4p49f9489+4bXPQ1gcDj/dmmJkXpFIYdN1vZ219Y3Nru7RT3t3bPzisHB23jco04y2mpNLdgBouRcJbKFDybqo5jQPJO8H4duZ3nrg2QiUPOEm5H9NhIiLBKFqp3ZehQjOoVN2aOwdZJV5BqlCgOah89UPFspgnyCQ1pue5Kfo51SiY5NNyPzM8pWxMh7xnaUJjbvx8fu2UnFslJJHSthIkc/X3RE5jYyZxYDtjiiOz7M3E/7xehtG1n4skzZAnbLEoyiRBRWavk1BozlBOLKFMC3srYSOqKUMbUNmG4C2/vEra9Zp3WXPv69XGTRFHCU7hDC7AgytowB00oQUMHuEZXuHNUc6L8+58LFrXnGLmBP7A+fwBvSWPOw==</latexit>...\n<latexit sha1_base64=\"6A3hk9eiPVp9DLs2XoL++ish0j8=\">AAAB7HicbVA9TwJBEJ3DL8Qv1NJmI5hYkTsKtSTaWGLiAQlcyN4yBxv29i67eyaE8BtsLDTG1h9k579xgSsUfMkkL+/NZGZemAqujet+O4WNza3tneJuaW//4PCofHzS0kmmGPosEYnqhFSj4BJ9w43ATqqQxqHAdji+m/vtJ1SaJ/LRTFIMYjqUPOKMGiv5Vdb3qv1yxa25C5B14uWkAjma/fJXb5CwLEZpmKBadz03NcGUKsOZwFmpl2lMKRvTIXYtlTRGHUwXx87IhVUGJEqULWnIQv09MaWx1pM4tJ0xNSO96s3F/7xuZqKbYMplmhmUbLkoygQxCZl/TgZcITNiYgllittbCRtRRZmx+ZRsCN7qy+ukVa95VzX3oV5p3OZxFOEMzuESPLiGBtxDE3xgwOEZXuHNkc6L8+58LFsLTj5zCn/gfP4ApS2N6g==</latexit>c1<latexit sha1_base64=\"7Tp9DaP+pOZpK7+otwrcYtpBPG4=\">AAAB7HicbVA9TwJBEJ3DL8Qv1NJmI5hYkTsKtSTaWGLiAQlcyN4ywIa9vcvungm58BtsLDTG1h9k579xgSsUfMkkL+/NZGZemAiujet+O4WNza3tneJuaW//4PCofHzS0nGqGPosFrHqhFSj4BJ9w43ATqKQRqHAdji5m/vtJ1Sax/LRTBMMIjqSfMgZNVbyq6xfr/bLFbfmLkDWiZeTCuRo9stfvUHM0gilYYJq3fXcxAQZVYYzgbNSL9WYUDahI+xaKmmEOsgWx87IhVUGZBgrW9KQhfp7IqOR1tMotJ0RNWO96s3F/7xuaoY3QcZlkhqUbLlomApiYjL/nAy4QmbE1BLKFLe3EjamijJj8ynZELzVl9dJq17zrmruQ73SuM3jKMIZnMMleHANDbiHJvjAgMMzvMKbI50X5935WLYWnHzmFP7A+fwBprKN6w==</latexit>c2<latexit sha1_base64=\"4kFgiwGxot+bfGky/kM/tcW8pBQ=\">AAAB+XicbVC7TsMwFL0pr1JeAUYWixaJqUo6AGMFC2OR6ENqo8hxndaq4wTbqVRF/RMWBhBi5U/Y+BucNgO0HMnS0Tn36h6fIOFMacf5tkobm1vbO+Xdyt7+weGRfXzSUXEqCW2TmMeyF2BFORO0rZnmtJdIiqOA024wucv97pRKxWLxqGcJ9SI8EixkBGsj+bZdG0RYj5nOJH2a+27Nt6tO3VkArRO3IFUo0PLtr8EwJmlEhSYcK9V3nUR7GZaaEU7nlUGqaILJBI9o31CBI6q8bJF8ji6MMkRhLM0TGi3U3xsZjpSaRYGZzGOqVS8X//P6qQ5vvIyJJNVUkOWhMOVIxyivAQ2ZpETzmSGYSGayIjLGEhNtyqqYEtzVL6+TTqPuXtWdh0a1eVvUUYYzOIdLcOEamnAPLWgDgSk8wyu8WZn1Yr1bH8vRklXsnMIfWJ8/EkOTSQ==</latexit>req1<latexit sha1_base64=\"EP2SF1MYzxq+WdEy3RyUvSEaXoY=\">AAAB+XicbVC7TsMwFHXKq5RXgJHFokViqpIOwFjBwlgk+pDaKHLcm9aq4wTbqVRF/RMWBhBi5U/Y+BucNgO0HMnS0Tn36h6fIOFMacf5tkobm1vbO+Xdyt7+weGRfXzSUXEqKbRpzGPZC4gCzgS0NdMceokEEgUcusHkLve7U5CKxeJRzxLwIjISLGSUaCP5tl0bRESPmc4kPM39Rs23q07dWQCvE7cgVVSg5dtfg2FM0wiEppwo1XedRHsZkZpRDvPKIFWQEDohI+gbKkgEyssWyef4wihDHMbSPKHxQv29kZFIqVkUmMk8plr1cvE/r5/q8MbLmEhSDYIuD4UpxzrGeQ14yCRQzWeGECqZyYrpmEhCtSmrYkpwV7+8TjqNuntVdx4a1eZtUUcZnaFzdIlcdI2a6B61UBtRNEXP6BW9WZn1Yr1bH8vRklXsnKI/sD5/ABPIk0o=</latexit>req2<latexit sha1_base64=\"zpRRNBL4JX5xu3IR0Ms1UnUAB2U=\">AAAB/HicbVC7TsMwFHXKq5RXoCOLRYvEVCUdgLGChbFI9CG1UeS4bmvVcSL7BimKyq+wMIAQKx/Cxt/gtBmg5UiWjs65V/f4BLHgGhzn2yptbG5t75R3K3v7B4dH9vFJV0eJoqxDIxGpfkA0E1yyDnAQrB8rRsJAsF4wu8393iNTmkfyAdKYeSGZSD7mlICRfLtaH4YEphwynQSSwdx3675dcxrOAniduAWpoQJt3/4ajiKahEwCFUTrgevE4GVEAaeCzSvDRLOY0BmZsIGhkoRMe9ki/ByfG2WEx5EyTwJeqL83MhJqnYaBmcyT6lUvF//zBgmMr72MyzgBJuny0DgRGCKcN4FHXDEKIjWEUMVNVkynRBEKpq+KKcFd/fI66TYb7mXDuW/WWjdFHWV0is7QBXLRFWqhO9RGHURRip7RK3qznqwX6936WI6WrGKniv7A+vwBiUmUsA==</latexit>subnet1<latexit sha1_base64=\"Os4kKfwp71J5OR/A33AALwELwVg=\">AAAB/HicbVC7TsMwFHXKq5RXoCOLRYvEVCUdgLGChbFI9CG1UeS4bmvVcSL7BimKyq+wMIAQKx/Cxt/gtBmg5UiWjs65V/f4BLHgGhzn2yptbG5t75R3K3v7B4dH9vFJV0eJoqxDIxGpfkA0E1yyDnAQrB8rRsJAsF4wu8393iNTmkfyAdKYeSGZSD7mlICRfLtaH4YEphwynQSSwdxv1n275jScBfA6cQtSQwXavv01HEU0CZkEKojWA9eJwcuIAk4Fm1eGiWYxoTMyYQNDJQmZ9rJF+Dk+N8oIjyNlngS8UH9vZCTUOg0DM5kn1ateLv7nDRIYX3sZl3ECTNLloXEiMEQ4bwKPuGIURGoIoYqbrJhOiSIUTF8VU4K7+uV10m023MuGc9+stW6KOsroFJ2hC+SiK9RCd6iNOoiiFD2jV/RmPVkv1rv1sRwtWcVOFf2B9fkDis6UsQ==</latexit>subnet2\n<latexit sha1_base64=\"bzlxl0nvFr5YEoK+AGgdk5clavg=\">AAAB7XicbVBNS8NAEJ34WetX1aOXxSJ4KkkP6rHoxWMF+wFtKJvNpl27yYbdiVBC/4MXD4p49f9489+4bXPQ1gcDj/dmmJkXpFIYdN1vZ219Y3Nru7RT3t3bPzisHB23jco04y2mpNLdgBouRcJbKFDybqo5jQPJO8H4duZ3nrg2QiUPOEm5H9NhIiLBKFqp3ZehQjOoVN2aOwdZJV5BqlCgOah89UPFspgnyCQ1pue5Kfo51SiY5NNyPzM8pWxMh7xnaUJjbvx8fu2UnFslJJHSthIkc/X3RE5jYyZxYDtjiiOz7M3E/7xehtG1n4skzZAnbLEoyiRBRWavk1BozlBOLKFMC3srYSOqKUMbUNmG4C2/vEra9Zp3WXPv69XGTRFHCU7hDC7AgytowB00oQUMHuEZXuHNUc6L8+58LFrXnGLmBP7A+fwBvSWPOw==</latexit>...\n<latexit sha1_base64=\"bzlxl0nvFr5YEoK+AGgdk5clavg=\">AAAB7XicbVBNS8NAEJ34WetX1aOXxSJ4KkkP6rHoxWMF+wFtKJvNpl27yYbdiVBC/4MXD4p49f9489+4bXPQ1gcDj/dmmJkXpFIYdN1vZ219Y3Nru7RT3t3bPzisHB23jco04y2mpNLdgBouRcJbKFDybqo5jQPJO8H4duZ3nrg2QiUPOEm5H9NhIiLBKFqp3ZehQjOoVN2aOwdZJV5BqlCgOah89UPFspgnyCQ1pue5Kfo51SiY5NNyPzM8pWxMh7xnaUJjbvx8fu2UnFslJJHSthIkc/X3RE5jYyZxYDtjiiOz7M3E/7xehtG1n4skzZAnbLEoyiRBRWavk1BozlBOLKFMC3srYSOqKUMbUNmG4C2/vEra9Zp3WXPv69XGTRFHCU7hDC7AgytowB00oQUMHuEZXuHNUc6L8+58LFrXnGLmBP7A+fwBvSWPOw==</latexit>...<latexit sha1_base64=\"bzlxl0nvFr5YEoK+AGgdk5clavg=\">AAAB7XicbVBNS8NAEJ34WetX1aOXxSJ4KkkP6rHoxWMF+wFtKJvNpl27yYbdiVBC/4MXD4p49f9489+4bXPQ1gcDj/dmmJkXpFIYdN1vZ219Y3Nru7RT3t3bPzisHB23jco04y2mpNLdgBouRcJbKFDybqo5jQPJO8H4duZ3nrg2QiUPOEm5H9NhIiLBKFqp3ZehQjOoVN2aOwdZJV5BqlCgOah89UPFspgnyCQ1pue5Kfo51SiY5NNyPzM8pWxMh7xnaUJjbvx8fu2UnFslJJHSthIkc/X3RE5jYyZxYDtjiiOz7M3E/7xehtG1n4skzZAnbLEoyiRBRWavk1BozlBOLKFMC3srYSOqKUMbUNmG4C2/vEra9Zp3WXPv69XGTRFHCU7hDC7AgytowB00oQUMHuEZXuHNUc6L8+58LFrXnGLmBP7A+fwBvSWPOw==</latexit>...<latexit sha1_base64=\"bzlxl0nvFr5YEoK+AGgdk5clavg=\">AAAB7XicbVBNS8NAEJ34WetX1aOXxSJ4KkkP6rHoxWMF+wFtKJvNpl27yYbdiVBC/4MXD4p49f9489+4bXPQ1gcDj/dmmJkXpFIYdN1vZ219Y3Nru7RT3t3bPzisHB23jco04y2mpNLdgBouRcJbKFDybqo5jQPJO8H4duZ3nrg2QiUPOEm5H9NhIiLBKFqp3ZehQjOoVN2aOwdZJV5BqlCgOah89UPFspgnyCQ1pue5Kfo51SiY5NNyPzM8pWxMh7xnaUJjbvx8fu2UnFslJJHSthIkc/X3RE5jYyZxYDtjiiOz7M3E/7xehtG1n4skzZAnbLEoyiRBRWavk1BozlBOLKFMC3srYSOqKUMbUNmG4C2/vEra9Zp3WXPv69XGTRFHCU7hDC7AgytowB00oQUMHuEZXuHNUc6L8+58LFrXnGLmBP7A+fwBvSWPOw==</latexit>...\n<latexit sha1_base64=\"bzlxl0nvFr5YEoK+AGgdk5clavg=\">AAAB7XicbVBNS8NAEJ34WetX1aOXxSJ4KkkP6rHoxWMF+wFtKJvNpl27yYbdiVBC/4MXD4p49f9489+4bXPQ1gcDj/dmmJkXpFIYdN1vZ219Y3Nru7RT3t3bPzisHB23jco04y2mpNLdgBouRcJbKFDybqo5jQPJO8H4duZ3nrg2QiUPOEm5H9NhIiLBKFqp3ZehQjOoVN2aOwdZJV5BqlCgOah89UPFspgnyCQ1pue5Kfo51SiY5NNyPzM8pWxMh7xnaUJjbvx8fu2UnFslJJHSthIkc/X3RE5jYyZxYDtjiiOz7M3E/7xehtG1n4skzZAnbLEoyiRBRWavk1BozlBOLKFMC3srYSOqKUMbUNmG4C2/vEra9Zp3WXPv69XGTRFHCU7hDC7AgytowB00oQUMHuEZXuHNUc6L8+58LFrXnGLmBP7A+fwBvSWPOw==</latexit>...<latexit sha1_base64=\"bzlxl0nvFr5YEoK+AGgdk5clavg=\">AAAB7XicbVBNS8NAEJ34WetX1aOXxSJ4KkkP6rHoxWMF+wFtKJvNpl27yYbdiVBC/4MXD4p49f9489+4bXPQ1gcDj/dmmJkXpFIYdN1vZ219Y3Nru7RT3t3bPzisHB23jco04y2mpNLdgBouRcJbKFDybqo5jQPJO8H4duZ3nrg2QiUPOEm5H9NhIiLBKFqp3ZehQjOoVN2aOwdZJV5BqlCgOah89UPFspgnyCQ1pue5Kfo51SiY5NNyPzM8pWxMh7xnaUJjbvx8fu2UnFslJJHSthIkc/X3RE5jYyZxYDtjiiOz7M3E/7xehtG1n4skzZAnbLEoyiRBRWavk1BozlBOLKFMC3srYSOqKUMbUNmG4C2/vEra9Zp3WXPv69XGTRFHCU7hDC7AgytowB00oQUMHuEZXuHNUc6L8+58LFrXnGLmBP7A+fwBvSWPOw==</latexit>...Figure 4: Per-round certi\fed state organized as a tree\nto the leaf representing that output. The number of hash values needed to authen-\nticate an individual output is therefore proportional to the depth of the Merkle tree,\nwhich is typically quite small, even if the sizeof the Merkle tree is very large. Thus,\na single threshold signature can be used to e\u000eciently authenticate many individual\noutputs.\n\u2022Preventing and detecting non-determinism. Consensus guarantees that each\nreplica processes inputs in the same order. Since each replica processes these in-\nputs deterministically, each replica should obtain the same state. However, the IC\nis designed with an extra layer of robustness to prevent and detect any (accidental)\nnon-deterministic computation, should it arise. The per-round certi\fed state is one of\nthe mechanisms used to do this. Since we use an ( n\u0000f)-out-of-nthreshold signature\nfor certi\fcation, and since f <n= 3, there can only be one sequence of states that is\ncerti\fed.\nTo see why state chaining is important, consider the following example. Suppose\nwe have 4 replicas, P1;P2;P3;P4, and one is corrupt, say P4. Each of the replicas\nP1;P2;P3start out in the same state.\n{In round 1, because of a non-deterministic computation, P1;P2compute a mes-\nsagem1to send to subnet A, whileP3computes a message m0\n1to send to subnet\nA.\n{In round 2, P1;P3compute a message m2to send to subnet B, whileP2computes\na messagem0\n2to send to subnet B.\n{In round 3, P2;P3compute a message m3to send to subnet C, whileP1computes\na messagem0\n3to send to subnet C.\nThis is illustrated in the following table:\n35P1m1!A m 2!B m0\n3!C\nP2m1!A m0\n2!B m 3!C\nP3m0\n1!A m 2!B m 3!C\nWe are assuming that replicas P1,P2, andP3each individually perform a valid se-\nquence of computations, but that because of non-determinism, these sequences are\nnot identical. (Even though there is not supposed to be any non-determinism, in this\nexample, we are supposing that there is.)\nNow suppose we did not chain the states. Because P4is corrupt and may sign anything,\nhe could create a 3-out-of-4 signature on a round-1 state that says \\ m1!A\", and\nsimilarly on a round-2 state that says \\ m2!B\", and on a round-3 state that says\n\\m3!C\",even though the corresponding sequence\nm1!A; m 2!B; m 3!C\nmay not be compatible with any valid sequence of computations . Worse yet, such\nan invalid sequence of computations could then lead to inconsistent states on other\nsubnets.\nBy chaining, we ensure that even if there is some non-determinism, any sequence of\ncerti\fed states corresponds to some valid sequence of computations that was actually\ncarried out by honest replicas.\n\u2022Coordination with consensus. The per-round certi\fed state is also used to coor-\ndinate the execution and consensus layers, in two di\u000berent ways:\n{Consensus throttling. Each replica will keep track of the latest round for which\nit has a certi\fed state | this is called the certi\fed height . It will also keep\ntrack of the latest round for which it has a notarized block | this is called\nthenotarized height . If the notarized height is signi\fcantly greater than the\ncerti\fed height, this is a signal that execution is lagging consensus, and that\nconsensus needs to be throttled . This lagging could be due to non-deterministic\ncomputation, or it could just be due to a more benign performance mismatch\nbetween the layers. Consensus is throttled by means of the delay functions\ndiscussed in Section 5.9 | speci\fcally, each replica will increase the \\governor\"\nvalue\u000fas the gap between notarized height and certi\fed height grows (this makes\nuse of the notion of \\locally adjusted delay functions, as in Section 5.12.2).\n{State-speci\fc payload validation. As discussed in Section 5.7, the inputs in a pay-\nload must pass certain validity checks. In fact, these validity checks may depend\nto a certain degree on the state. A detail we skipped is that each block includes\na round number, with the understanding that these validity checks should be\nmade with respect to the certi\fed state for that round number. A replica that\nneeds to perform this validation will wait until the state for that round number\nhas been certi\fed, and then use the certi\fed state for that round to perform\nthe validation. This ensures that even with non-deterministic computation, all\nreplicas are performing the same validity tests (as otherwise, consensus could get\nstuck).\n366.2 Query calls vs update calls\nAs we have described it so far, ingress messages must pass through consensus so that\nthey are processed in the same order by all replicas on a subnet. However, an important\noptimization is available to those ingress messages whose processing does not modify the\nreplicated state of a subnet. These are called query calls | as opposed to other ingress\nmessages, which are called update calls . Query calls are allowed to perform computations\nwhich read and possibly update the state of a canister, but any updates to the state of a\ncanister are never committed to the replicated state. As such, a query call may be processed\ndirectly by a single replica without passing through consensus, which greatly reduces the\nlatency for obtaining a response from a query call.\nNote that a response to a query call is not recorded in the ingress history data structure.\nAs such, we cannot directly use the per-round certi\fed state mechanism to authenticate\nresponses to query calls. However, a separate mechanism for authenticating such responses\nis provided: certi\fed variables . As a part of the per-round certi\fed state, each canister\non a subnet is allocated a small number of bytes, which is the certi\fed variable for that\ncanister , whose value may be updated via update calls, and may be authenticated using\nthe per-round certi\fed state mechanism. Moreover, a canister may use its certi\fed variable\nto store a root of a Merkle tree. In this way, a response to a query call to a canister may\nbe authenticated so long the response is a leaf in the Merkle tree rooted at the certi\fed\nvariable for that canister.\n6.3 External user authentication\nOne of the main di\u000berences between an ingress message and a cross-subnet message is\nthe mechanism used for authenticating these messages. We have already seen above (see\nSection 6.1) how threshold signatures are used to authenticate cross-subnet messages. The\nNNS registry (see Section 1.5) holds the public veri\fcation keys for the threshold signatures\nused to authenticate cross-subnet messages.\nThere is no central registry for external users. Rather, an external user identi\fes himself\nto a canister using a user identi\fer (aka principal ), which is a hash of a public signature-\nveri\fcation key. The user holds a corresponding secret signing key, which is used to sign\ningress messages. Such a signature, as well as the corresponding public key, is sent along\nwith the ingress message. The IC automatically authenticates the signature and passes the\nuser identi\fer to the appropriate canister. The canister may then authorize the requested\noperation, based on the user identi\fer and other parameters to the operation speci\fed in\nthe ingress message.\nFirst-time users generate a key pair and derive their user identi\fer from the public key\nduring their \frst interaction with the IC. Returning users are authenticated using the secret\nkey that is stored by the user agent. A user may associate several key pairs with a single\nuser identity, using signature delegation. This is useful, as it allows a single user to access\nthe IC from several devices using the same user identity.\n377 Execution Layer\nThe execution environment processes one input at a time. This input is taken from one of\nthe input queues, and is directed to one canister. Based on this input and the state of the\ncanister, the execution environment updates the state of the canister, and additionally may\nadd messages to output queues and update the ingress history (possibly with a response to\nan earlier ingress message).\nIn a given round, the execution environment will process several inputs. A scheduler\ndetermines which inputs are executed in a given round, and in which order. Without going\ninto all the details of the scheduler, we highlight some of the goals:\n\u2022it must be deterministic , i.e., only depend on the given data;\n\u2022it should distribute workloads fairly among canisters (but optimizing for throughput\nover latency ).\n\u2022the total amount of work done in each round, measured in terms of cycles (see Sec-\ntion 1.8), should be close to some pre-determined amount.\nAnother task that the execution environment (together with the message router) must\ndeal with are situations where a canister on one subnet is producing cross-subnet messages\nfaster than they can be consumed by a canister on another subnet. For this, a self-regulating\nmechanism is implemented that throttles the producing canister.\nThere are many other resource management and bookkeeping tasks that are dealt with\nby the execution environment. However, all of these tasks must be dealt with determinis-\ntically .\n7.1 Random tape\nEach subnet has access to a distributed pseudorandom generator (PRG) . As men-\ntioned in Section 3, pseudorandom bits are derived from a seed that itself is an ( f+ 1)-out-\nof-nBLS signature, called the Random Tape . There is a di\u000berent Random Tape for each\nround of the consensus protocol. While this BLS signature is similar to that used for the\nRandom Beacon used in consensus (see Section 5.5), the mechanics are somewhat di\u000berent.\nIn the consensus protocol, as soon as a block at height his \fnalized, each honest replica\nwill release its share of Random Tape for height h+ 1. This has two implications:\n1. Before a block at height his \fnalized by any honest replica, the Random Tape at\nheighth+ 1 is guaranteed to be unpredictable.\n2. By the time block at height h+ 1 is \fnalized by any honest replica, that replica will\ntypically have all the shares it needs to construct the Random Tape at height h+ 1.\nTo obtain pseudorandom bits, a subnet must make a request for these bits. Such a\npseudorandom-bit request will be made as a \\system call\" from the execution layer in some\nround, say h. The system will then respond to that request later, when the Random Tape\nof heighth+ 1 is available. By property (1) above, it is guaranteed that the requested\npseudorandom bits are unpredictable at the time the request is made. By property (2)\n38above, the requested random bits will typically be available at the time the next block is\n\fnalized. In fact, in the current implementation, at the time a block of height his \fnalized,\nthe Consensus Layer (see Section 5) will deliver both (the payload of) the block of height\nhand the Random Tape of height h+ 1 simultaneously to the message routing layer for\nprocessing.\n8 Chain-key cryptography II: chain-evolution technology\nAs mentioned in Section 1.6.2, chain-key cryptography includes a collection of technologies\nfor robustly and securely maintaining a blockchain-based replicated state machine over time,\nwhich together form what is called chain-evolution technology . Each subnet operates\ninepochs of many rounds (typically on the order of a few hundreds of rounds). Chain-\nevolution technology implements many essential maintenance activities that are executed\nperiodically with a cadence that is tied to epochs: garbage collection ,fast forwarding ,subnet\nmembership changes ,pro-active resharing of secrets , and protocol upgrades .\nThere are two essential ingredients to chain-evolution technology: summary blocks\nandcatch-up packages (CUPs) .\n8.1 Summary blocks\nThe \frst block in each epoch is a summary block . A summary block contains special\ndata that will be used to manage the shares of the various threshold signature schemes (see\nSection 3). There are two threshold schemes:\n\u2022one (f+ 1)-out-of- nscheme, for which a new signing key is generated every epoch;\n\u2022one (n\u0000f)-out-of-nscheme, for which the signing key is reshared once every epoch.\nThe low-threshold scheme is used for the random beacon and the random tape , while the\nhigh-threshold scheme is used to certify the replicated state of the subnet.\nRecall that the DKG protocol (see Section 3.5) requires that for each signing key, we\nhave a set of dealings, and that each replica can non-interactively obtain its share of the\nsigning key from this set of dealings.\nAlso recall that NNS maintains a registry that, among other things, determines the\nmembership of a subnet (see Section 1.5). The registry (and hence the subnet membership)\nmay change over time. Thus, subnets must agree on which registry version they use at\nvarious times for various purposes. This information is also stored in the summary block.\nThe summary block for epoch icontains the following data \felds.\n\u2022currentRegistryVersion . This registry version will determine the consensus committee\nused throughout epoch i| all tasks performed by the consensus layer (block making,\nnotarization, \fnalization) will be performed by this committee.\n\u2022nextRegistryVersion . In each round of consensus, a block maker will include in its\nproposal the latest registry version it knows about (which must be no earlier than the\nblock the proposed block extends). This ensures that the value nextRegistryVersion\nin the summary block of epoch iis fairly up to date.\n39The value of currentRegistryVersion in epochiis set to the value of nextRegistryVer-\nsion in epochi\u00001.\n\u2022currentDealingSets . These are the dealing sets that determine the threshold signing\nkeys that will be used to sign messages in epoch i.\nAs we will see, the threshold signing committee for epochi(i.e., the replicas that hold\nthe corresponding threshold signing key shares) is the consensus committee for epoch\ni\u00001 .\n\u2022nextDealingSets . This is where dealings that are collected during epoch i\u00001 are\ngathered and stored.6The value of currentDealingSets in epochiwill be set to the\nvalue of nextDealingSets in epochi\u00001 (which itself consists of dealings collected in\nepochi\u00002).\n\u2022collectDealingParams . This describes the parameters that de\fne the dealing sets to\nbecollected during epoch i. During epoch i, block makers will include dealings in\ntheir proposed blocks that are validated relative to these parameters.\nThe receiving committee for these dealings is based on the nextRegistryVersion value\nof the summary block of epoch i.\nFor the low-threshold scheme, the dealing committee is the consensus committee for\nepochi.\nFor the high-threshold scheme, the shares to be reshared are based on the value of\nnextDealingSets of epochi. Therefore, the dealing committee is the receiving committee\nfor epochi\u00001, which is also the consensus committee for epochi.\nAlso observe that the threshold signing committee for epochiis the receiving committee\nin epochi\u00002, which is the consensus committee for epochi\u00001 .\nConsensus in epoch irelies on the values currentRegistryVersion andcurrentDealingSets\nin epochi| in particular, the makeup of the consensus committee itself is based on curren-\ntRegistryVersion and the random beacon used in consensus is based on currentDealingSets .\nMoreover, just like any other block, there could be more than one summary block notarized\nat the beginning of epoch i, and that ambiguity needs to be resolved by consensus in epoch\ni. This seeming circularity is resolved by insisting that a summary block at the beginning\nof epochi\u00001 has been \fnalized before epoch istarts, since the relevant values in the newer\nsummary block are copied directly from that older summary block. This is actually an\nimplicit synchrony assumption , but it is quite an academic assumption. Indeed, because\nof the \\consensus throttling\" discussed in Section 5.12.2 to ensure liveness, and because of\nthe length of an epoch is quite large, this can essentially never happen in practice: long\nbefore consensus could reach the end of epoch i\u00001 without \fnalizing a summary block for\nepochi\u00001, the notarization delay function would grow to be astronomically large, and so\n6A detail we have omitted is that if we fail to collect all the required dealings in epoch i\u00001, then as\na fallback, the value of nextDealingSets in epoch iwill e\u000bectively be set to the value of currentDealingSets\nin epoch i. If this happens, then the protocol will make use of dealing committees andthreshold signing\ncommittees from further in the past, as appropriate.\n40the partial synchrony assumption needed for \fnalization will be satis\fed (essentially) with\ncertainty (for all practical purposes).7\n8.2 CUPs\nBefore describing a CUP, we \frst point out one detail of random beacon: the random\nbeacon for each round depends on the random beacon for the previous round. This is not\nan essential feature, but it impacts the design of the CUP.\nACUP is a special message (not on the blockchain) that has (mostly) everything a\nreplica needs to begin working in a given epoch, without knowing anything about previous\nepochs. It consists of the following data \felds:\n\u2022The root of a Merkle hash tree for the entire replicated state (as opposed to the\npartial, per-round certi\fed state as in Section 6.1).\n\u2022The summary block for the epoch.\n\u2022The random beacon for the \frst round of the epoch.\n\u2022A signature on the above \felds under the ( n\u0000f)-out-of-nthreshold signing key for\nthe subnet.\nTo generate a CUP for a given epoch, a replica must wait until the summary block\nfor that epoch is \fnalized and the corresponding per-round state is certi\fed. As already\nmentioned, the entire replicated state must be hashed as a Merkle tree | even though a\nnumber of techniques are used to accelerate this process, this is still quite expensive, which\nis why it is only done once per epoch. Since a CUP contains only the root of this Merkle\ntree, a special state sync subprotocol is used that allows a replica to pull any state that it\nneeds from its peers | again, a number of techniques are used to accelerate this process,\nbut it is still quite expensive. Since we are using a high-threshold signature for a CUP, we\ncan be sure that there is only one valid CUP in any epoch, and moreover, there will be\nmany peers from which the state may be pulled. Also, since the public key of the threshold\nsignature scheme remains constant over time, the CUP can be validated without knowing\nthe current participants of the subnet.\n8.3 Implementing chain-evolution technology\nGarbage collection: Because of the information contained in a CUP for a given epoch, it\nis safe for each replica to purge all inputs that have been processed, and all consensus-\nlevel protocol messages needed to order those inputs, prior to that epoch.\nFast forwarding: If a replica in a subnet falls very far behind its peers (because it is\ndown or disconnected from the network for a long time), or a new replica is added to\na subnet, it can be fast forwarded to the beginning of the most recent epoch, without\nhaving to run the consensus protocol and process all of the inputs up to that point.\n7Also note that dealings that are collected in epoch idepend on data in the summary block for epoch i,\nin particular, the values of nextDealingSets andnextRegistryVersion . As such, these dealings should not be\ngenerated and cannot be validated until a summary block for epoch ihas been \fnalized.\n41102103104NNNF103104\nRB 102RB 103RB 104102\nFCUP 101\n101101\nRB 101Replicated states\nBlocksRandom beaconsFigure 5: Fast forwarding\nSuch a replica may do so by obtaining the most recent CUP. Using the summary block\nand random beacon contained in the CUP, along with protocol messages from other\nreplicas (which have not yet been purged), this replica may run the consensus protocol\nforward from the beginning of the corresponding epoch. The replica will also use the\nstate sync subprotocol to obtain the replicated state corresponding to the beginning\nof the epoch, so that it may also process the inputs generated by consensus.\nFigure 5 illustrates fast forwarding. Here, we assume that a replica that needs to catch\nup has a CUP at the beginning of an epoch, which starts (say) at height 101. The CUP\ncontains the root of the Merkle tree for the replicated state at height 101, the summary\nblock at height 101 (shown in green), and the random beacon at height 101. This\nreplica will use the state sync subprotocol to obtain from its peers the full replicated\nstate at height 101, using the root of the Merkle tree in the CUP to validate this state.\nHaving obtained this state, the replica can then participate in the protocol, obtaining\nfrom its peers blocks (and other messages associated with consensus) at heights 102,\n103, and so on, and updating its copy of the replicated state. If its peers have already\n\fnalized blocks at greater heights, this replica will process those \fnalized blocks as\nquickly as it can obtain them (and their notarizations and \fnalizations) from its peers\n(and as quickly as the execution layer will allow).\nSubnet membership changes: We have already discussed how summary blocks are used\nto encode which version of the registry is in force in a given epoch, and how that is\nused to determine the subnet membership, and more speci\fcally, the membership\ncommittees for various tasks. Note that even after a replica is removed from a subnet,\nit should (if possible) participate in its assigned committee duties for one additional\nepoch.\nPro-active resharing of secrets: We have already discussed how summary blocks are\nused to generate and reshare signing keys. If necessary, the required summary block\n42may be obtained from a CUP.\nProtocol upgrades: CUPs are also used to implement protocol upgrades. Protocol up-\ngrades are initiated by the NNS (see Section 1.5). The basic idea, without going into\nall the details, is this:\n\u2022when it is time to install a new version of the protocol, the summary block at\nthe beginning of an epoch will indicate this;\n\u2022the replicas running the old version of the protocol will continue running con-\nsensus long enough to \fnalize the summary block and to create a corresponding\nCUP; however, they will create only empty blocks and not pass along any pay-\nloads to message routing and execution;\n\u2022the new version of the protocol will be installed, and the replicas running the\nnew version of the protocol will resume running the full protocol from the above\nCUP.\nReferences\n[BGLS03] D. Boneh, C. Gentry, B. Lynn, and H. Shacham. Aggregate and Veri\fably\nEncrypted Signatures from Bilinear Maps. In E. Biham, editor, Advances in\nCryptology - EUROCRYPT 2003, International Conference on the Theory and\nApplications of Cryptographic Techniques, Warsaw, Poland, May 4-8, 2003,\nProceedings , volume 2656 of Lecture Notes in Computer Science , pages 416{\n432. Springer, 2003.\n[BKM18] E. Buchman, J. Kwon, and Z. Milosevic. The latest gossip on BFT consensus,\n2018. arXiv:1807.04938, http://arxiv.org/abs/1807.04938 .\n[BLS01] D. Boneh, B. Lynn, and H. Shacham. Short Signatures from the Weil Pairing.\nIn C. Boyd, editor, Advances in Cryptology - ASIACRYPT 2001, 7th Interna-\ntional Conference on the Theory and Application of Cryptology and Information\nSecurity, Gold Coast, Australia, December 9-13, 2001, Proceedings , volume 2248\nofLecture Notes in Computer Science , pages 514{532. Springer, 2001.\n[But13] V. Buterin. Ethereum whitepaper, 2013. https://ethereum.org/en/\nwhitepaper/ .\n[CDH+21] J. Camenisch, M. Drijvers, T. Hanke, Y.-A. Pignolet, V. Shoup, and\nD. Williams. Internet Computer Consensus. Cryptology ePrint Archive, Report\n2021/632, 2021. https://ia.cr/2021/632 .\n[CDS94] R. Cramer, I. Damg\u0017 ard, and B. Schoenmakers. Proofs of Partial Knowledge\nand Simpli\fed Design of Witness Hiding Protocols. In Advances in Cryptology\n- CRYPTO '94, 14th Annual International Cryptology Conference, Santa Bar-\nbara, California, USA, August 21-25, 1994, Proceedings , volume 839 of Lecture\nNotes in Computer Science , pages 174{187. Springer, 1994.\n43[CL99] M. Castro and B. Liskov. Practical Byzantine Fault Tolerance. In M. I. Seltzer\nand P. J. Leach, editors, Proceedings of the Third USENIX Symposium on Op-\nerating Systems Design and Implementation (OSDI), New Orleans, Louisiana,\nUSA, February 22-25, 1999 , pages 173{186. USENIX Association, 1999.\n[CWA+09] A. Clement, E. L. Wong, L. Alvisi, M. Dahlin, and M. Marchetti. Making\nByzantine Fault Tolerant Systems Tolerate Byzantine Faults. In J. Rexford and\nE. G. Sirer, editors, Proceedings of the 6th USENIX Symposium on Networked\nSystems Design and Implementation, NSDI 2009, April 22-24, 2009, Boston,\nMA, USA , pages 153{168. USENIX Association, 2009. http://www.usenix.\norg/events/nsdi09/tech/full_papers/clement/clement.pdf .\n[Des87] Y. Desmedt. Society and Group Oriented Cryptography: A New Concept. In\nC. Pomerance, editor, Advances in Cryptology - CRYPTO '87, A Conference\non the Theory and Applications of Cryptographic Techniques, Santa Barbara,\nCalifornia, USA, August 16-20, 1987, Proceedings , volume 293 of Lecture Notes\nin Computer Science , pages 120{127. Springer, 1987.\n[DLS88] C. Dwork, N. A. Lynch, and L. J. Stockmeyer. Consensus in the presence of\npartial synchrony. J. ACM , 35(2):288{323, 1988.\n[Fis83] M. J. Fischer. The Consensus Problem in Unreliable Distributed Systems (A\nBrief Survey). In Fundamentals of Computation Theory, Proceedings of the 1983\nInternational FCT-Conference, Borgholm, Sweden, August 21-27, 1983 , volume\n158 of Lecture Notes in Computer Science , pages 127{140. Springer, 1983.\n[FS86] A. Fiat and A. Shamir. How to Prove Yourself: Practical Solutions to Identi\fca-\ntion and Signature Problems. In Advances in Cryptology - CRYPTO '86, Santa\nBarbara, California, USA, 1986, Proceedings , volume 263 of Lecture Notes in\nComputer Science , pages 186{194. Springer, 1986.\n[GHM+17] Y. Gilad, R. Hemo, S. Micali, G. Vlachos, and N. Zeldovich. Algorand: Scaling\nByzantine Agreements for Cryptocurrencies. Cryptology ePrint Archive, Report\n2017/454, 2017. https://eprint.iacr.org/2017/454 .\n[Gro21] J. Groth. Non-interactive distributed key generation and key resharing. Cryp-\ntology ePrint Archive, Report 2021/339, 2021. https://ia.cr/2021/339 .\n[JMV01] D. Johnson, A. Menezes, and S. A. Vanstone. The Elliptic Curve Digital Sig-\nnature Algorithm (ECDSA). Int. J. Inf. Sec. , 1(1):36{63, 2001.\n[Mer87] R. C. Merkle. A Digital Signature Based on a Conventional Encryption Func-\ntion. In Advances in Cryptology - CRYPTO '87, A Conference on the Theory\nand Applications of Cryptographic Techniques, Santa Barbara, California, USA,\nAugust 16-20, 1987, Proceedings , volume 293 of Lecture Notes in Computer Sci-\nence, pages 369{378. Springer, 1987.\n44[MXC+16] A. Miller, Y. Xia, K. Croman, E. Shi, and D. Song. The Honey Badger of\nBFT Protocols. In E. R. Weippl, S. Katzenbeisser, C. Kruegel, A. C. My-\ners, and S. Halevi, editors, Proceedings of the 2016 ACM SIGSAC Conference\non Computer and Communications Security, Vienna, Austria, October 24-28,\n2016, pages 31{42. ACM, 2016.\n[Nak08] S. Nakamoto. Bitcoin: A peer-to-peer electronic cash system, 2008. https:\n//bitcoin.org/bitcoin.pdf .\n[PS18] R. Pass and E. Shi. Thunderella: Blockchains with Optimistic Instant Con-\n\frmation. In J. B. Nielsen and V. Rijmen, editors, Advances in Cryptology -\nEUROCRYPT 2018 - 37th Annual International Conference on the Theory and\nApplications of Cryptographic Techniques, Tel Aviv, Israel, April 29 - May 3,\n2018 Proceedings, Part II , volume 10821 of Lecture Notes in Computer Science ,\npages 3{33. Springer, 2018.\n[PSS17] R. Pass, L. Seeman, and A. Shelat. Analysis of the Blockchain Protocol in\nAsynchronous Networks. In Advances in Cryptology - EUROCRYPT 2017 -\n36th Annual International Conference on the Theory and Applications of Cryp-\ntographic Techniques, Paris, France, April 30 - May 4, 2017, Proceedings, Part\nII, volume 10211 of Lecture Notes in Computer Science , pages 643{673, 2017.\n[Sch90] F. B. Schneider. Implementing Fault-Tolerant Services Using the State Machine\nApproach: A Tutorial. ACM Comput. Surv. , 22(4):299{319, 1990.\n[YMR+18] M. Yin, D. Malkhi, M. K. Reiter, G. G. Gueta, and I. Abraham. HotStu\u000b: BFT\nConsensus in the Lens of Blockchain, 2018. arXiv:1803.05069, http://arxiv.\norg/abs/1803.05069 .\n45"
}